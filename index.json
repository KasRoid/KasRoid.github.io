[{"content":" 본 포스팅은 다음 버전을 기준으로 작성되었습니다.\nSwift 5.3 iOS 14.1 Intro 오늘은 DatePicker 에서 제공하는 Mode 중 하나인 .countDownTimer 를 사용해 실제로 구동 가능한 타이머를 만들어보겠습니다.\nPrerequisite 타이머 구현 및 실습을 위해 DatePicker 를 배치하고, 상단에는 타이머의 남은 시간을 표시할 UILabel 을, 하단에는 사용자가 설정한 시간을 기준으로 타이머 구동을 시작할 UIButton 을 배치했습니다.\nimport UIKit class CountDownViewController: UIViewController { let label = UILabel() let picker = UIDatePicker() let button = UIButton(type: .system) override func viewDidLoad() { super.viewDidLoad() configureUI() } // MARK: - UI private func configureUI() { setAttributes() setContraints() } private func setAttributes() { label.text = \u0026#34;0\u0026#34; label.textColor = .black label.font = UIFont.systemFont(ofSize: 30) picker.datePickerMode = .countDownTimer button.setTitle(\u0026#34;Start\u0026#34;, for: .normal) button.addTarget(self, action: #selector(handleButton(_:)), for: .touchUpInside) } private func setContraints() { [label, picker, button].forEach { view.addSubview($0) $0.translatesAutoresizingMaskIntoConstraints = false } NSLayoutConstraint.activate([ label.centerXAnchor.constraint(equalTo: view.centerXAnchor), label.bottomAnchor.constraint(equalTo: picker.topAnchor, constant: -100), picker.centerYAnchor.constraint(equalTo: view.centerYAnchor), picker.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 10), picker.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -10), button.centerXAnchor.constraint(equalTo: view.centerXAnchor), button.topAnchor.constraint(equalTo: picker.bottomAnchor, constant: 150) ]) } // MARK: - Selectors @objc private func handleButton(_ sender: UIButton) { print(picker.countDownDuration) print(#function) } } 이제 Simulator 를 실행하고 버튼을 눌러보면 Console 에 사용자가 선택한 시간이 출력되는 것을 확인할 수 있어요.\nAnalyzing Methods 이제 DatePicker 의 설정을 실습에 맞게 바꿔주고, Timer 기능을 수행할 코드를 작성해보도록 할게요.\nCountDown Duration 조절하기 이 옵션은 datePicker 가 .countdownTimer 로 설정되어 있을 때만 사용할 수 있고, 최초에 설정되어 있는 값을 조절할 수 있습니다. 초 단위 설정이 가능하기는 하지만 화면에 표시될 때는 분 단위로 표시되기 때문에 60의 배수로 설정해주세요.\npicker.countDownDuration = 600 앱을 실행하자마자 기본 시간이 10분으로 설정되어 있습니다.\nMinute 선택 간격 조절하기 사용자가 datePicker 를 스크롤하며 선택할 수 있는 옵션을 제어합니다.\npicker.minuteInterval = 5 이 옵션을 적용하고 실행해보면 타이머가 5분 간격으로 선택되는 것을 확인할 수 있을거에요.\nTimer 기능 구현하기 DatePicker 자체는 타이머 기능을 수행할 수 있는 어떤 옵션도 없습니다. 단지 인터페이스의 역할만 수행할 뿐이에요.\n그래서 우리가 Timer 인스턴스를 직접 생성하고 남은 시간을 관리해야 타이머 기능을 구현할 수 있습니다. 버튼이 눌렸을 때 사용자가 설정한 시간을 입력받아 해당 값을 기준으로 타이머 기능을 만들어주도록 하겠습니다.\n먼저 타이머가 0초가 되었을 때 알람을 실행하도록 만들어볼게요. AudioServicesPlaySystemSound 를 사용해 기본 사운드를 재생하고 이 method 를 사용하기 위해 AVFoundation 을 import 합니다.\nimport AVFoundation 사용자가 설정한 값을 입력받을 변수가 하나 필요합니다. ViewController 상단에 변수를 하나 생성하도록 할게요.\nvar duration: Int = 0 이제 버튼과 연결해 놓은 함수에 타이머와 관련된 코드를 작성하겠습니다.\n@objc private func handleButton(_ sender: UIButton) { duration = Int(picker.countDownDuration) label.text = \u0026#34;\\(duration)\u0026#34; Timer.scheduledTimer( withTimeInterval: 1, repeats: true) { (timer) in self.duration -= 1 self.label.text = \u0026#34;\\(self.duration)\u0026#34; if self.duration == 0 { timer.invalidate() AudioServicesPlaySystemSound(1315) } } } Timer 는 반드시 직접 종료해주어야 하는 것을 잊지마세요. 해제는 .invalidate method 를 사용해 구현할 수 있습니다.\nWrap Up 이렇게 DatePicker 를 .countDownTimer 모드로 사용할 수 있는 방법과, Timer 인스턴스와 연계해 실제로 타이머 기능을 구현할 수 있는 방법에 대해 공부해보았습니다. 이제 DatePicker 의 주요 기능들에 대해 충분히 공부했으니 필요한 프로젝트에 적용해 보세요!\nEntire Code import UIKit import AVFoundation class CountDownViewController: UIViewController { let label = UILabel() let picker = UIDatePicker() let button = UIButton(type: .system) var duration: Int = 0 override func viewDidLoad() { super.viewDidLoad() configureUI() } // MARK: - UI private func configureUI() { setAttributes() setContraints() } private func setAttributes() { label.text = \u0026#34;0\u0026#34; label.textColor = .black label.font = UIFont.systemFont(ofSize: 30) picker.datePickerMode = .countDownTimer picker.countDownDuration = 60 picker.minuteInterval = 1 button.setTitle(\u0026#34;Start\u0026#34;, for: .normal) button.addTarget(self, action: #selector(handleButton(_:)), for: .touchUpInside) } private func setContraints() { [label, picker, button].forEach { view.addSubview($0) $0.translatesAutoresizingMaskIntoConstraints = false } NSLayoutConstraint.activate([ label.centerXAnchor.constraint(equalTo: view.centerXAnchor), label.bottomAnchor.constraint(equalTo: picker.topAnchor, constant: -100), picker.centerYAnchor.constraint(equalTo: view.centerYAnchor), picker.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 10), picker.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -10), button.centerXAnchor.constraint(equalTo: view.centerXAnchor), button.topAnchor.constraint(equalTo: picker.bottomAnchor, constant: 150) ]) } // MARK: - Selectors @objc private func handleButton(_ sender: UIButton) { duration = Int(picker.countDownDuration) label.text = \u0026#34;\\(duration)\u0026#34; Timer.scheduledTimer( withTimeInterval: 1, repeats: true) { (timer) in self.duration -= 1 self.label.text = \u0026#34;\\(self.duration)\u0026#34; if self.duration == 0 { timer.invalidate() AudioServicesPlaySystemSound(1315) } } } } ","permalink":"https://kasroid.github.io/posts/ios/20201107-uikit-timer-with-date-picker/","summary":"본 포스팅은 다음 버전을 기준으로 작성되었습니다.\nSwift 5.3 iOS 14.1 Intro 오늘은 DatePicker 에서 제공하는 Mode 중 하나인 .countDownTimer 를 사용해 실제로 구동 가능한 타이머를 만들어보겠습니다.\nPrerequisite 타이머 구현 및 실습을 위해 DatePicker 를 배치하고, 상단에는 타이머의 남은 시간을 표시할 UILabel 을, 하단에는 사용자가 설정한 시간을 기준으로 타이머 구동을 시작할 UIButton 을 배치했습니다.\nimport UIKit class CountDownViewController: UIViewController { let label = UILabel() let picker = UIDatePicker() let button = UIButton(type: .","title":"UIKit - Date Picker 를 이용해 Timer 구현하기"},{"content":" 본 포스팅은 다음 버전을 기준으로 작성되었습니다.\nSwift 5.3 iOS 14.1 Intro 이전 포스트에서 Date 에 관해 알아보았으니 이번에는 사용자가 아이폰에서 날짜를 고를 때 자주 마주치게되는 인터페이스 중 하나인 DatePicker 에 대해 같이 공부해보겠습니다.\niOS 14 가 업데이트 되면서 기존까지와는 다른 스타일의 DatePicker 가 추가되었는데요. 아이폰 기본 알람앱을 자주 사용하는 분이라면 이미 알고 계셨을거에요 ㅎㅎ 아무튼 공부하는 김에 이 새로운 스타일의 DatePicker 도 함께 알아보도록 할게요.\nPrerequisite 먼저 실습을 위해 간단하게 ViewController 위에 DatePicker 를 올려놓았습니다.\nimport UIKit class ViewController: UIViewController { private let datePicker = UIDatePicker() override func viewDidLoad() { super.viewDidLoad() configureUI() } // MARK: - UI private func configureUI() { setAttributes() setContraints() } private func setAttributes() { datePicker.preferredDatePickerStyle = .automatic datePicker.datePickerMode = .dateAndTime datePicker.locale = Locale(identifier: \u0026#34;ko-KR\u0026#34;) datePicker.timeZone = .autoupdatingCurrent datePicker.addTarget(self, action: #selector(handleDatePicker(_:)), for: .valueChanged) } private func setContraints() { view.addSubview(datePicker) datePicker.translatesAutoresizingMaskIntoConstraints = false NSLayoutConstraint.activate([ datePicker.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 10), datePicker.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -10), datePicker.centerYAnchor.constraint(equalTo: view.centerYAnchor), ]) } // MARK: - Selectors @objc private func handleDatePicker(_ sender: UIDatePicker) { print(sender.date) } } 기본적인 레이아웃 및 Target 작업을 진행해 주었습니다.\nDatePicker 는 Intrinsic Size 로 Height 값을 갖고 있으므로 따로 높이를 지정해 줄 필요가 없습니다. 즉 넓이를 세팅해주고 Picker 가 올라갈 위치만 잡아주면 된다는거에요. 그리고 DatePicker 를 Target Action 으로 구현하고자 할 때는 .valueChanged 옵션을 써야한다는 것을 꼭 기억하세요.\nBasics 그럼 DatePicker 에서 사용할 수 있는 기본적인 method 에 관해 함께 공부해보겠습니다.\nDatePicker Style iOS 14가 업데이트 되면서 DatePicker 에 새로운 스타일이 추가되었다고 했는데요. 먼저 어떤 스타일들이 있는지 함께 확인해보도록 하겠습니다. 종류는 총 3가지가 존재하며 기본값은 .automatic 으로 되어있어 시스템이 현재 뷰에 가장 알맞은 스타일을 선택해 준다고해요. 자동으로하면 나는 항상 compact 만 되는 것 같던데??\ndatePicker.preferredDatePickerStyle = .automatic 일단은 .automatic 상태로 코드를 작성해 놓았습니다. 이제 이걸 하나씩 바꿔가며 어떻게 바뀌는지 살펴볼거에요.\n.compact 아무것도 설정하지 않으면 이게 기본값처럼 실행되는 것으로 봐서는 이게 Apple 에서 가장 추천하는 최신 스타일이 아닌가해요. 다른 DatePicker 스타일에 비해서 정말 심플하기도 하고, 공간도 덜 차지한다는 장점이 있는 디자인입니다. 시간이 적혀있는 label 을 사용자가 탭하여 원하는 값으로 수정할 수 있습니다.\n.inline 이건 .compact 스타일에서 탭하면 보이는 달력을 미리 펼쳐놓은 형태에요. 그동안 Apple 에서 기본적으로 제공하는 캘린더가 없었다고 생각해보면, 이걸 어떻게 사용하느냐에 따라서 어느정도 간단한 기능의 캘린더는 대체할 수도 있지 않을까 생각이 드네요.\n.wheel 익숙한 스타일이죠. 우리가 자주 썼었던 예전 스타일의 DatePicker 도 계속 사용할 수 있습니다.\n이제 앱을 실행시켜서 원하는 날짜를 DatePicker 에서 골라보세요. Console 에 시간이 정상적으로 출력됩니다. 근데 혹시 한가지 이상한 점을 눈치채셨나요?\n콘솔에 출력되는 시간이 DatePicker 에서 고른 시각과 다르게 나오고 있어요. 이건 코드에 잘못된 부분이 있는게 아니라 기본적으로 표시되는 시간이 GMT Format 을 따르기 때문인데요.\n나중에 NSDateFormatter 를 사용해서 우리가 원하는 시간대로 출력되도록 바꿔줄 수 있습니다. DateFormatter 까지 알아보려면 포스트가 너무 길어지니 일단 지금은 그냥 넘어가고 다음에 더 자세히 알아보기로 해요 ㅎㅎ\nDatePicker Mode .preferredDatePickerStyle 이 새롭게 제공되는 기능이라면, 이전부터 제공되던 .datePickerMode 라는 기능도 있습니다.\n모드로는 총 4가지의 옵션이 존재합니다.\n.dateAndTime .date .time .countDownTimer 처음 3 가지는 이름만 봐도 비슷하다는게 느껴지나요? 날짜와 시간을 모두 고르게할지 날짜 혹은 시간만 선택할 수 있도록 할지 결정해주는 것입니다. .countDownTimer 만 조금 다른데요. 이건 method 이름처럼 사용자에게 타이머 기능을 제공하고자 할 때 사용할 수 있는 인터페이스 입니다.\nLocale .locale 은 DatePicker 에 사용하는 국가를 입력할 수 있습니다. 아무런 설정도 건드리지 않으면 아이폰 기본설정을 사용합니다.\ndatePicker.locale = Locale(identifier: \u0026#34;ko-KR\u0026#34;) 한국으로 설정이 필요하다면 이렇게 코드를 입력하세요.\nminuteInterval .minuteInterval 은 사용자가 스크롤을 돌려 시간을 설정할 때 나타나는 분 단위 간격을 조절할 수 있습니다. 기본값은 1분으로 되어있고요. 최대 30분까지 입력이 가능합니다. 이 설정을 사용할 때는 1시간은 60분이니까 60의 약수 내에서 입력하도록 하세요.\ndatePicker.minuteInterval = 5 이렇게 설정하면 분 단위 설정이 5분 간격으로 가능합니다.\nDate 최초에 선택되어 있는 날짜를 설정할 수가 있는 method 에요! 단 DatePicker 의 Mode 가 .countDownTimer 로 설정되어 있을 때는 작동하지 않습니다.\ndatePicker.date = Date(timeIntervalSinceNow: -3600 * 24 * 3) 이렇게 코드를 입력하면 DatePicker 가 현재 날짜를 기준으로 3일 전의 날짜로 선택되어 시작합니다.\nsetDate .date 의 역할을 포함하고, 추가로 애니메이션 작동 여부를 설정하는 역할을 합니다.\ndatePicker.setDate(Date(), animated: true) 여러가지 실험을 해봤지만 어느 부분에서 애니메이션이 작동하는지 확인하기가 어렵더라고요\u0026hellip; 나중에 혹시 알아내게 된다면 업데이트 하겠습니다.. 아무튼 이 애니메이션의 기본값은 false 라고 합니다.\nminimumDate, maximumDate 사용자가 선택할 수 있는 날짜나 시간을 한정할 수 있게 도와주는 method 입니다.\n.wheel 모드에서는 사용자가 우리가 지정해놓은 한계 이상으로 스크롤을 했을 경우 처음 기본값 상태로 되돌아오게 됩니다. 그리고 새로나온 .compact 나 .inline 모드에서는 선택할 수 있는 날짜가 연한 회색으로 비활성화되는 방식으로 사용자에게 이 날짜는 선택할 수 없다는 것을 직관적으로 알 수 있게 합니다.\nvar components = DateComponents() components.day = 10 let maxDate = Calendar.autoupdatingCurrent.date(byAdding: components, to: Date()) components.day = -10 let minDate = Calendar.autoupdatingCurrent.date(byAdding: components, to: Date()) datePicker.maximumDate = maxDate datePicker.minimumDate = minDate 위 코드를 입력하면 현재 날짜를 기준으로 앞뒤 10일까지만 선택이 가능해집니다.\n현재 날짜를 기준으로 10일 이전의 날짜가 회색으로 표시되며 비활성화 된 것이 보이죠? ㅎㅎ\nCalendar, timeZone .calendar, .timeZone 에 대한 설정은 스토리보드에서는 불가능하고 코드로만 설정이 가능한데요. 저는 코드파라 사실 불편함이 없더라고요 ㅎㅎㅎ 아무튼 이 설정에 대해서는 자세히 설명하지 않겠습니다.\nCalendar 가 아직 익숙하지 않다면 UIKit - Calendar 와 Date 기초 익히기 포스팅을 참고해주세요.\nWrap Up 오늘은 iOS 14 에서 새롭게 리뉴얼된 DatePicker 에 대해 공부해보았는데요. 날짜를 다루는데 어느정도 익숙한 분이라면 크게 어렵게 느낄만한 부분은 없었던 것 같네요. 이렇게 하나하나 파헤쳐보는게 바로 개발의 맛 아닐까요?\n다음 포스트에서는 오늘 이런 모드가 있다 얘기만 하고 넘어간 DatePicker 의 .countDownTimer 모드를 사용해 타이머를 만드는 방법에 대해 알아보도록 하겠습니다~!\n","permalink":"https://kasroid.github.io/posts/ios/20201030-uikit-date-picker/","summary":"본 포스팅은 다음 버전을 기준으로 작성되었습니다.\nSwift 5.3 iOS 14.1 Intro 이전 포스트에서 Date 에 관해 알아보았으니 이번에는 사용자가 아이폰에서 날짜를 고를 때 자주 마주치게되는 인터페이스 중 하나인 DatePicker 에 대해 같이 공부해보겠습니다.\niOS 14 가 업데이트 되면서 기존까지와는 다른 스타일의 DatePicker 가 추가되었는데요. 아이폰 기본 알람앱을 자주 사용하는 분이라면 이미 알고 계셨을거에요 ㅎㅎ 아무튼 공부하는 김에 이 새로운 스타일의 DatePicker 도 함께 알아보도록 할게요.\nPrerequisite 먼저 실습을 위해 간단하게 ViewController 위에 DatePicker 를 올려놓았습니다.","title":"UIKit - Date Picker 사용하기, iOS 14 변경사항 정리"},{"content":"Intro App 을 만들다보면 날짜를 다뤄야하는 상황을 종종 마주치게 되는데요. 그동안은 원하는 정보를 적당히 구글에서 찾아 문제를 해결하고 따로 공부하는 시간을 가져본 적이 없었습니다. 날짜는 여러가지 앱에서 사용되는 빈도가 높은만큼 제대로 공부하고 지나가면 앞으로 도움이 많이 될 것 같아 공부해 봅니다.\nPrerequisite Cocoa Touch Framework 에는 날짜를 구현할 수 있는 다양한 방법이 존재하는데요. Swift 언어 이전에는 class 타입으로 구성되어 있는 구현방식을 제공했습니다. 아마 개발을 시작한지 어느정도 되었다면 자주 보았을 만한 NS 접두어로 시작하는 것들이 바로 그것이에요 ㅎㅎ\n하지만 Swift 라는 언어가 생겨난 이후부터는 struct 타입을 사용해 구현된 방식이 제공되었고, 현재는 대부분 이 struct 방식을 사용한 날짜처리로 코드가 구현됩니다. 왜 struct 를 사용하게 된건지는 저도 아직 잘 모릅니다\n아무튼!! class 를 사용하는 방식은 Objective-C 에서 주로 사용되었고 지금은 거의 사용되지 않는만큼, 이번 포스팅에서는 struct 로 구현된 방식에 대해서만 공부하도록 하겠습니다.\n사실 두 가지가 사용법이 어느정도 비슷하기 때문에 하나만 제대로 공부하면 나머지도 어떻게 사용하면 될 지 감이 온다고 하네요. 진짜로!??\nclass: NSdate, NSCalendar, NSDateComponents, NSTimeZone, NSLocale struct: Date, Calendar, DateComponents, TimeZone, Locale 참고로 위에 나열된 Date, Calendar 등의 타입은 모두 브릿징을 지원하기 때문에 필요한 상황에 as 연산자로 간단하게 타입을 캐스팅해서 사용이 가능합니다.\nPractice UIKit 에서 날짜를 구현할 수 있는 방법과 그 종류 대해 알아보았으니 이제 직접 코드를 작성해 보면서 Calendar 와 Date 를 인스턴스화 하고, 원하는 값을 지정할 수 있도록 연습해 보겠습니다. 백날 이론만 읽어봐야 실제로 직접 한번 써보는 것만 못하더라고요.\nCalendar 생성하기 캘린더를 인스턴스화할 수 있는 방법은 3가지가 있습니다. 이 중 2번째와 3번째 방법이 비슷하게 생각될 수 있고 실제로도 어느정도 비슷한데요. 차이점을 적어놨으니 잘 살펴보시고 그래도 이해가 잘 되지않는다면 설정에서 캘린더 종류를 바꿔가며 차이점을 확인해보세요.\n캘린더를 생성할 수 있는 방법 3가지는 이렇습니다.\nidentifier 를 지정하여 특정 종류의 캘린더를 사용하는 방법 사용자가 아이폰에 설정해 놓은 캘린더의 종류를 시스템 설정으로부터 최초에 한번 전달받아 사용하는 방법 사용자가 아이폰에 설정해 놓은 캘린더의 종류를 시스템 설정으로부터 전달받아 사용하며, 이후 설정에서 사용자가 캘린더의 종류를 변경하면 함께 적용할 수 있는 캘린더를 사용하는 방법 정말 2번째와 3번째 방법이 비슷해보이죠? 아래 코드처럼 캘린더를 인스턴스화하고 print 를 찍어가며 설정을 바꿔보면 차이점이 좀 더 명확해집니다.\n.current 를 사용한 캘린더는 설정에서 캘린더 종류를 바꿔도 적용되지 않고 .autoupdatingCurrent 는 적용이 됩니다.\nlet customCalendar = Calendar(identifier: .gregorian) // 직접 캘린더의 종류를 설정, enum 형태로 만들어져 있어 gregorian 외에도 다양한 종류의 캘린더를 확인할 수 있음 let systemCalendar = Calendar.current // 사용자의 아이폰 설정 캘린더 정보를 가져와서 사용하지만, 날짜가 로드된 이후 사용자가 설정에서 변경하는 내용은 적용되지 않음 let autoUpdatingSystemCalendar = Calendar.autoupdatingCurrent // 아이폰에서 설정되어 있는 달력을 기준으로 값을 리턴 이렇게 3가지 방법을 사용해 달력을 생성할 수 있지만, 특별한 이유가 없다면 .current 나 .autoupdatingCurrent 를 통해 사용자가 아이폰에서 설정해 놓은 달력을 기준으로 사용하는 것이 좋습니다.\nDate 생성하기 이제 Date 를 구현하는 방법을 알아보겠습니다.\n시간은 각 나라마다 다를 수 있는데 만약 별도로 TimeZone 을 명시하지 않는다면 사용자의 아이폰 기본설정을 따라가게 됩니다. 그럼 현재 날짜를 값으로 갖고\u000b있는 변수를 만들어 볼까요?\nlet now = Date() 정말 간단하네요. 이제 now 를 print 해보면 현재 날짜가 출력되는 것을 확인할 수 있을거에요. Date 를 인스턴스화 하는 것만으로도 현재 날짜에 접근할 수 있게됩니다.\nTimeInterval 알아보기 특정 시간만큼 지난 시각을 Date 로 만들고 싶다면 Date(timeIntervalSinceReferenceDate:) method 를 사용해 이동하고 싶은 시간을 초로 설정할 수 있습니다. 하지만 이 method 를 사용하기 전에 반드시 알고 지나가야할 개념이 하나 있는데요. 바로 TimeInterval 입니다.\nTimeInterval 은 Swift 의 기본 타입 중 하나인 Double 이 Type Alias 된 형태로 단독적으로 사용하는 경우는 거의 없는 것 같고\u0026hellip; 주로 Date 와 연계하여 사용됩니다.\nlet oneSec = TimeInterval(1) // 1초 let oneMin = TimeInterval(60) // 1분 let oneHour = TimeInterval(oneMin * 60) // 1시간 let oneDay = TimeInterval(oneHour * 60) // 1일 TimeInterval 을 사용해 현재의 1분 후를 Date 로 생성해 볼게요.\nlet oneMinuteAfter = Date(timeIntervalSinceReferenceDate: 60) 쉽네요 ㅎㅎㅎ 1시간은 60분이니까 3600초를 값으로 넣어주면 됩니다.\nlet oneHourAfter = Date(timeIntervalSinceReferenceDate: 60 * 60) 여태까지는 시간을 미래로만 이동했으니 이제 과거로 돌아가 볼게요. 1시간 전으로 날짜를 세팅하려면 TimeInterval 값을 음수로 바꿔주면 됩니다.\nlet oneHourBefore = Date(timeIntervalSinceReferenceDate: -60 * 60) 지금 예시에서는 하드코딩 형태로 직접 값을 입력했지만 TimeInterval 형태로 변수를 생성하고 해당 변수를 값으로 넣어줄 수도 있습니다.\nDateComponents 사용하기 지금까지 현재 날짜를 기준으로 특정 시간만큼 이동하는 방법을 알아보았고, 이제 직접 원하는 날짜를 지정하여 값을 캘린더에 넣어주는 방법을 공부해보겠습니다. 캘린더에 값을 넣어주기 위해서는 DateComponents 를 이용해야 합니다.\nDateComponents 안에는 연월일 등 시간에 관련된 여러가지 속성이 들어있으며 그 값을 우리가 지정할 수가 있습니다. 그럼 DateComponents 를 인스턴스화 시켜 customDateComponents 라는 변수를 생성하고 1988년 8월 5일을 날짜로 세팅한 뒤 캘린더에 넣도록 하겠습니다.\nvar customDateComponents = DateComponents() customDateComponents.year = 1988 customDateComponents.month = 8 customDateComponents.day = 5 let customDateComponentsDate = autoUpdatingSystemCalendar.date(from: customDateComponents) customDateComponentsDate 를 print 해보면 1988년 8월 5일이 출력되는 것을 확인할 수 있습니다.\n이제 캘린더에서 필요한 값만 가져오는 방법을 알아볼게요. dateComponents method 를 사용해 여러가지 값들을 한번에 가져오거나, component method 를 사용해 값 하나만을 가져올 수도 있습니다.\nlet components = autoUpdatingSystemCalendar.dateComponents([.year, .month, .day, .hour], from: now) let year = autoUpdatingSystemCalendar.component(.year, from: now) let month = autoUpdatingSystemCalendar.component(.month, from: now) let day = autoUpdatingSystemCalendar.component(.day, from: now) 마지막으로 두 날짜 사이의 간격을 일 수로 가져오는 방법을 알아보겠습니다.\n조금 전 만들어두었던 customDateComponentsDate 와 현재 날짜 사이의 간격을 알아볼게요.\nlet days = autoUpdatingSystemCalendar.dateComponents([.day], from: customDateComponentsDate!, to: now).day .day 를 사용하지 않고 print 를 해보면 day 와 isLeapMonth 두가지가 출력되는 것을 볼 수가 있고, 우리는 그 중 day 값에 접근해 일 수 만 가져오게 할 수 있습니다.\nWrap Up 이렇게 Calendar 와 Date 에 관한 기본적인 내용을 공부해 보았는데요. 처음 접하는 내용이다보니 생소한 부분은 있었지만 그렇게 어려운 내용은 아니었던 것 같습니다. 이제 어느정도 기초를 쌓았으니 나중에 더 다양한 사용법을 배울 때도 좀 더 수월하게 이해할 수 있을 것 같네요 ㅎㅎ\n","permalink":"https://kasroid.github.io/posts/ios/20201026-uikit-handling-date/","summary":"Intro App 을 만들다보면 날짜를 다뤄야하는 상황을 종종 마주치게 되는데요. 그동안은 원하는 정보를 적당히 구글에서 찾아 문제를 해결하고 따로 공부하는 시간을 가져본 적이 없었습니다. 날짜는 여러가지 앱에서 사용되는 빈도가 높은만큼 제대로 공부하고 지나가면 앞으로 도움이 많이 될 것 같아 공부해 봅니다.\nPrerequisite Cocoa Touch Framework 에는 날짜를 구현할 수 있는 다양한 방법이 존재하는데요. Swift 언어 이전에는 class 타입으로 구성되어 있는 구현방식을 제공했습니다. 아마 개발을 시작한지 어느정도 되었다면 자주 보았을 만한 NS 접두어로 시작하는 것들이 바로 그것이에요 ㅎㅎ","title":"UIKit - Calendar 와 Date 기초 익히기"},{"content":" 본 포스팅은 Swift 5.3 기준으로 작성되었습니다.\nIntro 약 두달간 진행하던 Market Kurly 서비스를 클론하는 프로젝트가 끝나, 오늘부터는 기존에 어느정도 공부하고 사용도하고 있었지만 완벽하게 숙지를 한 것은 아닌 부분들을 다시 복습하고 이해도를 높이는 것을 목표로 한동안 공부해보려고 합니다. 그럼 오늘은 처음 배울 때 이해하기 까다로웠던 부분 중 하나인 Delegate Pattern 에 대해 복습하는 시간을 가져보도록 하겠습니다. iOS 개발 에서는 정말 자주 쓰이고 중요한 개념이므로 여러분들도 혹시 아직 완벽히 이해한게 아니라면 같이 공부해보도록 해요~\nDelegate 개념 이해하기 iOS 개발에 어느정도 익숙해졌다면 여러가지 상황에서 Delegate Protocol 을 채택하고 Protocol 내부에서 제공하는 method 를 사용해본 적이 있을텐데요. UITextField 나 UITableView 에서도 기능을 구현할 때 흔하게 사용되는 방식입니다. Apple 에서 우리가 유용하게 사용할 수 있을만한 기능들을 함수에 담아 미리 구현해놓고 그 코드 위에 우리가 추가적인 코드를 작성함으로서 우리가 원하는 방식대로 앱이 동작하게 할 수 있습니다.\nDelegate Pattern 을 사용하기 위해서는 아래의 내용을 순차적으로 구현하면 됩니다. 동작방식이 처음에는 이해가 어려울 수도 있지만 반복해서 사용하다보면 금방 익숙해질 수 있으니 이해가 잘 가지 않는다면 계속 반복해서 연습해보세요 ㅎㅎ 저도 처음에는 개념을 이해하는게 어려웠지만 어느 순간부터 그냥 자연스레 사용할 수 있게 되더라고요.\nDelegate Pattern 은 다음과 같은 조건을 충족함으로서 사용할 수 있습니다.\nDelegate 를 생성하는 뷰\nProtocol 을 생성하고, 구현하고 싶은 기능을 해당 Protocol 의 method 로 생성 Protocol 을 Type 으로 갖는 Delegate 인스턴스 생성 생성한 method 가 동작해야하는 상황에 코드 작성 Delegate 를 위임받는 뷰\nViewController 에 Delegate Protocol 채택 Protocol 필수 method 구현 Delegate 위임 이렇게 각 뷰에서 3 가지 조건, 총 6가지 조건을 만족하면 Delegate 가 정상적으로 작동합니다.\nPrerequisite 이제 새로운 프로젝트를 생성하고 직접 Delegate Pattern 을 구현하면서 실습해 볼게요.\n실습을 위해 총 2개의 ViewController 를 생성하고\n첫번째 Controller 에는 결과값을 표시할 Label 과 두번째 Controller 를 띄울 Button 두번째 Controller 에는 결과값을 입력받을 TextField 와 첫번째 Controller 로 돌아갈 수 있는 Button 을 배치했습니다.\nFirstViewController\nclass FirstViewController: UIViewController { let label = UILabel() let button = UIButton() override func viewDidLoad() { super.viewDidLoad() configureUI() } // MARK: - UI private func configureUI() { view.backgroundColor = .white setAttributes() setContraints() } private func setAttributes() { label.text = \u0026#34;Sample Text\u0026#34; button.setTitle(\u0026#34;Present\u0026#34;, for: .normal) button.setTitleColor(.systemBlue, for: .normal) button.addTarget(self, action: #selector(handleButton(_:)), for: .touchUpInside) } private func setContraints() { [label, button].forEach { view.addSubview($0) $0.translatesAutoresizingMaskIntoConstraints = false } NSLayoutConstraint.activate([ label.centerXAnchor.constraint(equalTo: view.centerXAnchor, constant: 0), label.centerYAnchor.constraint(equalTo: view.centerYAnchor, constant: 0), button.centerXAnchor.constraint(equalTo: view.centerXAnchor, constant: 0), button.bottomAnchor.constraint(equalTo: label.topAnchor, constant: -30) ]) } // MARK: - Selectors @objc private func handleButton(_ sender: UIButton) { let nextVC = SecondViewController() self.present(nextVC, animated: true, completion: nil) } } SecondViewController\nclass SecondViewController: UIViewController { let textField = UITextField() let button = UIButton() override func viewDidLoad() { super.viewDidLoad() configureUI() } // MARK: - UI private func configureUI() { view.backgroundColor = .white setAttributes() setContraints() } private func setAttributes() { textField.layer.borderColor = UIColor.lightGray.cgColor textField.layer.borderWidth = 0.5 button.setTitle(\u0026#34;Dismiss\u0026#34;, for: .normal) button.setTitleColor(.systemBlue, for: .normal) button.addTarget(self, action: #selector(handleButton(_:)), for: .touchUpInside) } private func setContraints() { [textField, button].forEach { view.addSubview($0) $0.translatesAutoresizingMaskIntoConstraints = false } NSLayoutConstraint.activate([ textField.heightAnchor.constraint(equalToConstant: 50), textField.widthAnchor.constraint(equalToConstant: 350), textField.centerXAnchor.constraint(equalTo: view.centerXAnchor, constant: 0), textField.centerYAnchor.constraint(equalTo: view.centerYAnchor, constant: 0), button.centerXAnchor.constraint(equalTo: view.centerXAnchor, constant: 0), button.bottomAnchor.constraint(equalTo: textField.topAnchor, constant: -30) ]) } // MARK: - Selectors @objc private func handleButton(_ sender: UIButton) { self.dismiss(animated: true, completion: nil) } } 저는 이렇게 기본 세팅을 해주었는데요. 함께 실습하고 싶은 분은 위 코드를 복사해서 사용하세요~\nDelegate Pattern 연습하기 이제 기본적인 세팅을 마쳤으니 Delegate Pattern 개념 이해하기에서 설명했었던 6가지 단계를 직접 구현해보도록 하겠습니다. Delegate Pattern 을 구현할 때는 지금 실습할 이 단계들만 잘 기억한다면 어려울 것이 없습니다.\nProtocol 구현하기 가장 먼저 우리가 구현하고자하는 method 를 Protocol 을 생성하고 그 내부에 만들어 주어야 하는데요. Protocol 은 class 를 Type 으로 가집니다. 이것은 ARC, 메모리 관리와 관련이 있는 부분이며 지금 설명하기에는 복잡한 내용이라 나중에 다른 포스팅에서 자세히 알아보도록 하겠습니다. 아무튼 class Type 을 가지게되면 이후 생성할 delegate 인스턴스를 weak 형태로 생성할 수 있게 됩니다.\n이 실습에서는 SecondViewController 의 UITextField 에 입력받은 내용을 FirstViewController 의 UILabel 에 전달해야하므로 우리가 구현할 method 는 String 을 Parameter 로 전달 받습니다.\nprotocol CustomTextFieldDelegate: class { func textDidInput(didInput text: String) } 간단하죠? method 에 구현될 코드는 나중에 우리가 Protocol 을 채택하고 입력하는 형식이므로 지금 당장은 어떤 내용도 입력할 필요가 없습니다.\nDelegate 인스턴스 생성하기 SecondViewController 에 delegate 인스턴스를 생성합니다. delegate 인스턴스는 CustomTextFieldDelegate 를 Type 을 가짐으로서 이 인스턴스에 접근해서 우리가 Protocol 내부에 작성해두었던 함수에 접근할 수 있게 됩니다.\nweak var delegate: CustomTextFieldDelegate? 위에서 한번 설명했듯이 weak 을 사용해 ARC 가 증가하지 않도록 만들어줌으로서 메모리 Leak 이 발생하지 않도록 방지해주는 것이 중요합니다.\nProtocol 채택 및 필수 method 구현하기 이제 FirstViewController 로 돌아와서 우리가 생성한 Protocol 을 채택하고 method 까지 함께 구현해보도록 할게요.\nProtocol 을 채택할 때는 반드시 Extension 을 통해 만들어 주어야하는 것은 아니지만 저는 Extension 으로 Delegate 를 채택하는 것을 선호하고, 실제로도 많은 개발자들이 이 형식을 따르므로, 이번 실습에서도 extension 을 사용해 CustomTextFieldDelegate 를 채택했습니다. Protocol 이 채택되고 나면 경고창이 뜨면서 필수 함수를 구현하라고 나오는데요. 이 때 Xcode 가 지원하는 자동에러처리를 사용하면 함수 하나가 생성됩니다.\n이 함수는 우리가 Protocol 생성 시에 만들어 둔 함수로, 실제로 UITableView 등에서 Delegate Protocol 을 채택했을 때 필수로 구현해야하는 함수도 이런 방식으로 자동완성이 되는 것입니다.\nextension FirstViewController: CustomTextFieldDelegate { func textDidInput(didInput text: String) { label.text = text } } 함수 내부의 코드를 간단하게 설명해보면, 함수가 실제로 호출되는 곳에서 어떤 String 값을 가지고 들어오게되고, 우리는 Parameter 를 전달받아 사용하기만 하면 됩니다. 이 실습에서는 전달받은 값을 UILabel 에 표현하는 것이 목적이므로 위와 같이 코드를 구현했습니다.\nDelegate 위임하기 우리가 이전에 delegate 인스턴스를 생성했을 때 optional 형태로 생성해주었잖아요? 이제 이 값에 CustomTextFieldDelegate 를 채택한 Controller 를 할당해주면 됩니다. 실제 Input 은 SecondViewController 에서 이루어지지만 그 값에 대한 처리는 FirstViewController 에서 대행하겠다하는 일종의 명시입니다. 위임방법은 FirstViewController 에서 화면을 present 할 때 구현해 놓은 nextVC 의 delegate 에 접근해서 설정할 수 있습니다.\n@objc private func handleButton(_ sender: UIButton) { let nextVC = SecondViewController() nextVC.delegate = self self.present(nextVC, animated: true, completion: nil) } Present 할 Controller 를 생성하고 present 되기 직전 delegate 에 값을 넣어주는 방식입니다. 넘어갈 View 에 데이터를 전송할 떄 많이 써봤던 방식일 거에요 ㅎㅎ\n함수가 동작해야하는 시점 설정하기 이제 우리가 원하는 타이밍에 함수가 작동할 수 있도록 코드를 구현해볼게요. 화면이 내려가면서 값을 전달하면 되니까 Dismiss 되는 타이밍에 작동할 수 있도록 만들어 주었습니다.\n@objc private func handleButton(_ sender: UIButton) { let text = textField.text ?? \u0026#34;\u0026#34; self.delegate?.textDidInput(didInput: text) self.dismiss(animated: true, completion: nil) } delegate 의 textDidInput() 함수를 호출하는 시점이 결정되었고, 이제 버튼이 눌리게 되면 View 가 Dismiss 되기 전 이 함수를 호출하며 FirstViewController 가 값을 전달받게 됩니다. 이게 가능한 이유는 SecondViewController 가 present 되기 전 우리가 FirstViewController 를 delegate 로 설정해주었기 때문입니다.\nWrap Up 이렇게 Delegate Pattern 실습을 마쳤습니다. 이 개념이 이해하고나면 의외로 간단하지만 초반에는 완전히 이해하는 것이 생각보다 까다롭더라고요. 처음배울 때는 왜 그렇게 어려웠었는지\u0026hellip;ㅎㅎ 아무튼 만약 지금 이 개념이 잘 이해가 가지 않더라도 지속적으로 반복 연습하다보면 어느순간 당연하게 생각되는 부분이니까 열심히 공부해보세요!\nEntire Code FirstViewController\nclass FirstViewController: UIViewController { let label = UILabel() let button = UIButton() override func viewDidLoad() { super.viewDidLoad() configureUI() } // MARK: - UI private func configureUI() { view.backgroundColor = .white setAttributes() setContraints() } private func setAttributes() { label.text = \u0026#34;Sample Text\u0026#34; button.setTitle(\u0026#34;Present\u0026#34;, for: .normal) button.setTitleColor(.systemBlue, for: .normal) button.addTarget(self, action: #selector(handleButton(_:)), for: .touchUpInside) } private func setContraints() { [label, button].forEach { view.addSubview($0) $0.translatesAutoresizingMaskIntoConstraints = false } NSLayoutConstraint.activate([ label.centerXAnchor.constraint(equalTo: view.centerXAnchor, constant: 0), label.centerYAnchor.constraint(equalTo: view.centerYAnchor, constant: 0), button.centerXAnchor.constraint(equalTo: view.centerXAnchor, constant: 0), button.bottomAnchor.constraint(equalTo: label.topAnchor, constant: -30) ]) } // MARK: - Selectors @objc private func handleButton(_ sender: UIButton) { let nextVC = SecondViewController() nextVC.delegate = self self.present(nextVC, animated: true, completion: nil) } } extension FirstViewController: CustomTextFieldDelegate { func textDidInput(didInput text: String) { label.text = text } } SecondViewController\nclass SecondViewController: UIViewController { weak var delegate: CustomTextFieldDelegate? let textField = UITextField() let button = UIButton() override func viewDidLoad() { super.viewDidLoad() configureUI() } // MARK: - UI private func configureUI() { view.backgroundColor = .white setAttributes() setContraints() } private func setAttributes() { textField.layer.borderColor = UIColor.lightGray.cgColor textField.layer.borderWidth = 0.5 button.setTitle(\u0026#34;Dismiss\u0026#34;, for: .normal) button.setTitleColor(.systemBlue, for: .normal) button.addTarget(self, action: #selector(handleButton(_:)), for: .touchUpInside) } private func setContraints() { [textField, button].forEach { view.addSubview($0) $0.translatesAutoresizingMaskIntoConstraints = false } NSLayoutConstraint.activate([ textField.heightAnchor.constraint(equalToConstant: 50), textField.widthAnchor.constraint(equalToConstant: 350), textField.centerXAnchor.constraint(equalTo: view.centerXAnchor, constant: 0), textField.centerYAnchor.constraint(equalTo: view.centerYAnchor, constant: 0), button.centerXAnchor.constraint(equalTo: view.centerXAnchor, constant: 0), button.bottomAnchor.constraint(equalTo: textField.topAnchor, constant: -30) ]) } // MARK: - Selectors @objc private func handleButton(_ sender: UIButton) { let text = textField.text ?? \u0026#34;\u0026#34; self.delegate?.textDidInput(didInput: text) self.dismiss(animated: true, completion: nil) } } ","permalink":"https://kasroid.github.io/posts/ios/20201010-uikit-delegate-pattern/","summary":"본 포스팅은 Swift 5.3 기준으로 작성되었습니다.\nIntro 약 두달간 진행하던 Market Kurly 서비스를 클론하는 프로젝트가 끝나, 오늘부터는 기존에 어느정도 공부하고 사용도하고 있었지만 완벽하게 숙지를 한 것은 아닌 부분들을 다시 복습하고 이해도를 높이는 것을 목표로 한동안 공부해보려고 합니다. 그럼 오늘은 처음 배울 때 이해하기 까다로웠던 부분 중 하나인 Delegate Pattern 에 대해 복습하는 시간을 가져보도록 하겠습니다. iOS 개발 에서는 정말 자주 쓰이고 중요한 개념이므로 여러분들도 혹시 아직 완벽히 이해한게 아니라면 같이 공부해보도록 해요~","title":"UIKit - Delegate Pattern 이해하기"},{"content":" 본 포스팅은 Swift 5.3 기준으로 작성되었습니다.\nIntro 저는 요새 Market Kurly 앱을 클론하는 프로젝트를 진행하고 있는데요. 회원가입 부분에서 Kakao 우편변호 찾기 기능을 지원하더라고요. 사용자로서는 분명히 사용해본 경험이 있는 것 같은데 막상 구현하는 방법은 배운적도 생각해본 적도 없었습니다 ㅎㅎ 어쨌든 중요한건 지금 어떻게든 구현을 해야한다는 것이고, 마켓컬리앱이 아니더라도 회원가입을 필요로하는 서비스라면 많이 지원하고 있는 기능이니까 잘 공부해서 정리해두면 나중에 쓸데가 많을 것 같아 포스팅을 남깁니다.\n서비스 확인하기 Kakao 우편번호 서비스 웹페이지 에 접속해보면 평소 우리가 회원가입을 할 때 자주 볼 수 있었던 화면이 하나 보일거에요.\n먼저 안내를 읽어보니 모든 조건에서 무료로 사용가능하고 별다른 요구사항도 없는 것 같네요. 그냥 가져다쓰고 WebView 형태로 앱 내에서 띄워주면 될 것 같습니다. 그럼 바로 구현을 시작해볼까요? ㅎㅎ\n구현하기 저도 완전히 처음 시도해보는 과정이다보니 어디서부터 접근해야할지 감이 오지않아 검색할 수 있는만큼 최대한 찾아봤지만 Swift 로는 카카오 우편번호 서비스 구현방법을 상세히 정리해둔 곳을 찾지 못해 공부하는데 애를 정말 많이 먹었습니다.\n아무튼 구현을 위한 순서를 정리해보면 우편번호 서비스가 구현된 웹페이지 주소가 있어야하고, 그 주소를 기반으로 Xcode 에서 WebView 를 이용해 웹페이지를 띄워주어야 합니다. 그래서 오늘 포스팅은 이런 순서로 진행될거에요.\nGithub Pages 를 사용해 카카오 우편번호 서비스 웹페이지 구현 Xcode 에서 WebView 를 사용해 웹페이지 띄우기 그럼 순서대로 차근차근 구현을 시작해볼게요.\nGithub Pages 를 사용해 카카오 우편번호 서비스 웹페이지 만들기 카카오 우편번호 서비스를 웹페이지에 구현할 수 있는 방법은 여러가지가 있겠지만 이번 포스팅에서는 Github Pages 를 사용해 웹페이지를 생성하겠습니다. Github 에 접속해서 Repo 를 하나 만들어주세요. 저는 Kakao-Postcode 라고 생성했습니다.\n생성된 Repo 의 Setting 카테고리로 들어가 스크롤을 내리다보면 Github Pages 라는 항목이 보일거에요. 이곳에서 Source 로 master branch 를 선택하고 save 버튼을 눌러줍니다.\nSave 버튼을 누르면 페이지가 리프레시 되는데 다시 Github Pages 항목이 있는 곳으로 돌아가보면 우리가 생성한 웹페이지의 주소를 얻을 수 있습니다.\n생성된 주소로 들어가보면 404 에러 페이지가 보일거에요. 지금은 우리가 아무 내용도 입력하지 않았으므로 이렇게 뜨는게 정상입니다.\n다시 Github 으로 돌아와 Create new file 을 클릭합니다.\n그리고 파일의 이름을 정확하게 index.html 이라고 입력해주세요. Github Pages 는 index.html 이라는 파일을 자동적으로 찾아서 웹페이지로 생성해줍니다.\n이제 웹페이지 구현에 필요한 html 코드를 입력하면 됩니다. 포스팅 초반에 보았던 공식 카카오 우편번호 서비스 웹페이지를 보면 통합로딩방식 항목을 찾을 수 있고 이걸 갖다 붙여넣으면 바로 구현이 되긴하지만 POP-UP 방식으로 구현된다는 문제점이 있습니다.\n그래서 주소를 입력했을 때 팝업 방식이 아닌 페이지가 바로 보일 수 있도록 구현된 코드가 필요합니다. index.html 본문에 아래 코드를 입력하고 저장해주세요.\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;ko\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;주소 찾기\u0026lt;/title\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width,height=device-height,initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body onload=\u0026#34;execDaumPostcode()\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;layer\u0026#34; style=\u0026#34;display:block; position:absolute; overflow:hidden; z-index:1; -webkit-overflow-scrolling:touch; \u0026#34; \u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://spi.maps.daum.net/imap/map_js_init/postcode.v2.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; window.addEventListener(\u0026#34;message\u0026#34;, onReceivedPostMessage, false); function onReceivedPostMessage(event) { //..ex deconstruct event into action \u0026amp; params var action = event.data.action; var params = event.data.params; console.log(\u0026#34;onReceivedPostMessage \u0026#34; + event); } function onReceivedActivityMessageViaJavascriptInterface(json) { //..ex deconstruct data into action \u0026amp; params var data = JSON.parse(json); var action = data.action; var params = data.params; console.log(\u0026#34;onReceivedActivityMessageViaJavascriptInterface \u0026#34; + event); } function postMessageToiOS(postData) { window.webkit.messageHandlers.callBackHandler.postMessage(postData); } var element_layer = document.getElementById(\u0026#34;layer\u0026#34;); function execDaumPostcode() { new daum.Postcode({ oncomplete: function (data) { var jibunAddress = \u0026#34;\u0026#34;; if (data.jibunAddress == \u0026#34;\u0026#34;) { jibunAddress = data.autoJibunAddress; } else if (data.autoJibunAddress == \u0026#34;\u0026#34;) { jibunAddress = data.jibunAddress; } var postData = { roadAddress: data.roadAddress, jibunAddress: jibunAddress, zonecode: data.zonecode, }; window.postMessageToiOS(postData); }, width: \u0026#34;100%\u0026#34;, height: \u0026#34;100%\u0026#34;, }).embed(element_layer); element_layer.style.display = \u0026#34;block\u0026#34;; initLayerPosition(); } function initLayerPosition() { var width = window.innerWidth || document.documentElement.clientWidth; var height = window.innerHeight || document.documentElement.clientHeight; element_layer.style.width = width + \u0026#34;px\u0026#34;; element_layer.style.height = height + \u0026#34;px\u0026#34;; element_layer.style.left = ((window.innerWidth || document.documentElement.clientWidth) - width) / 2 + \u0026#34;px\u0026#34;; element_layer.style.top = ((window.innerHeight || document.documentElement.clientHeight) - height) / 2 + \u0026#34;px\u0026#34;; } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 적용되는데 시간이 조금 필요하기 때문에 잠시 기다리고나서 Github Pages 주소로 들어가보면 우리가 구현하고자 했던 카카오 우편번호 서비스 화면이 보일거에요!\n혹시 계속 기다려봐도 안된다면 Repo 의 이름을 한번 변경해주세요. 분명히 잘못된 부분이 없는데 계속 페이지 오류가 뜨길래 Repo 이름을 바꿔보니까 이후부터 웹페이지가 정상적으로 뜨기 시작했습니다.\n잘 나오나요~? ㅎㅎ 이제 Xcode 에서 WebKit 을 이용해 이 페이지를 띄워주면 됩니다.\nWebView 로 카카오 우편번호 서비스 웹페이지 표시하기 Xcode Project 를 하나 만들어 실습을 시작해볼게요. 먼저 간단하게 뷰를 세팅하겠습니다.\nSetup View View 위에 Button 과 Label 을 하나씩 올려놓았어요. Button 을 누르면 카카오 우편번호 서비스 창이 뜨고, 이곳에서 주소를 입력받은 뒤 Label 에 표시될 수 있도록 데이터를 전달해 볼거에요.\nimport UIKit class ViewController: UIViewController { // MARK: - Properties let button = UIButton(type: .system) let label = UILabel() // MARK: - Lifecycle override func viewDidLoad() { super.viewDidLoad() configureUI() } // MARK: - UI private func configureUI() { setContraints() setAttributes() } private func setAttributes() { button.setTitle(\u0026#34;Button\u0026#34;, for: .normal) button.addTarget(self, action: #selector(handleButton(_:)), for: .touchUpInside) label.text = \u0026#34;Label\u0026#34; label.font = UIFont.systemFont(ofSize: 20) } private func setContraints() { [button, label].forEach { view.addSubview($0) $0.translatesAutoresizingMaskIntoConstraints = false } NSLayoutConstraint.activate([ button.centerXAnchor.constraint(equalTo: view.centerXAnchor), button.centerYAnchor.constraint(equalTo: view.centerYAnchor), label.centerXAnchor.constraint(equalTo: view.centerXAnchor), label.bottomAnchor.constraint(equalTo: button.topAnchor, constant: -40), ]) } // MARK: - Selectors @objc private func handleButton(_ sender: UIButton) { print(#function) } } 코드를 작성하고 Simulator 를 실행해보면 이렇게 보입니다.\n카카오 우편번호 서비스 구현하기 기본적인 뷰 세팅은 마쳤으니 본격적으로 우편번호 서비스 구현을 위한 코드를 작성해보도록 할게요. 서비스가 보여질 새로운 UIViewController 를 하나 생성해줍니다. 저는 KakaoZipCodeVC 라고 만들었어요~\n이제 이곳에 조금 전 Github Pages 를 사용해 미리 만들어둔 페이지를 WebView 를 사용해서 띄워줄거에요. 그러니까 WebView 를 사용하기 위해 WebKit 을 import 해주도록 할게요.\nimport WebKit 그리고 WKWebView 인스턴스를 optional 로 미리 하나 생성하고, webView 가 로딩될 동안 보여줄 UIActivityIndicatorView 도 인스턴스를 생성하겠습니다. 나중에 사용자가 선택한 주소를 저장할 변수도 하나 생성할게요.\nvar webView: WKWebView? let indicator = UIActivityIndicatorView(style: .medium) var address = \u0026#34;\u0026#34; 인스턴스 생성까지 마쳤고 Java Script 를 읽을 수 있게 도와주는 WKUserContentController 를 생성해야합니다. 처음보는 클래스니까 공식문서를 먼저 한번 볼까요.\n특별한 내용은 없고 Java Script 가 메세지를 Post 할 수 있게 도와준다고 나와있네요. 우리가 Github Pages 에 작성한 html 이 Java Script 를 불러오는 내용이니까 이걸 쓰는게 맞을 것 같아요.\nlet contentController = WKUserContentController() 인스턴스를 생성해줬으니 이제 Java Script 가 보내는 메세지를 읽을 수 있어야 합니다. 여기서 메세지란 사용자가 선택한 정보가 무엇인지 우리가 받는 것을 뜻하겠죠?\n아무튼 이 메세지를 받으려면 WKUserContentController 가 제공하는 add(_:name:) method 를 사용해야 하는데요.\n이 method 를 사용하기 위해서는 WKScriptMessageHandler 프로토콜을 채택해주어야 합니다. 그리고 이 프로토콜을 채택하면 필수적으로 구현해야하는 userContentController(_:didReceive:) method 도 구현하도록 할게요.\n프로토콜을 채택하기 전에 add(_:name:) method 의 공식문서를 잠시 살펴봤는데\u0026hellip;\nScript Message Handler 를 추가한다고 합니다. Hanlder 가 있어야 Java Script 가 보내는 Message 를 정상적으로 수신할 수 있는 것 같아요.\nWKScriptMessageHandler 프로토콜 채택 WKScriptMessageHandler 를 채택하고 필수함수를 구현했습니다.\nextension KakaoZipCodeVC: WKScriptMessageHandler { func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) { } } 직접 실험을 해보니 이 함수가 호출되는 타이밍은 유저가 주소를 검색하고 어떤 값을 최종적으로 선택했을 때 호출되게 됩니다.\n프로토콜을 채택했으니 add(_:name:) method 를 사용할 수 있게 되었어요. 다시 contentController 를 인스턴스화 한곳으로 돌아가 코드를 입력해주세요.\ncontentController.add(self, name: \u0026#34;callBackHandler\u0026#34;) 이제 초반에 optional 로 생성해두었던 WKWebView 를 인스턴스화 해주어야하는데요. 그 전에 먼저 방금 생성한 contentController 를 WKWebView 와 연결할 수 있도록 도와주는 WKWebViewConfiguration 이 필요합니다.\nlet configuration = WKWebViewConfiguration() configuration.userContentController = contentController webView 를 인스턴스화 해줍니다. 레이아웃은 아래에서 오토레이아웃으로 잡을거니까 .zero 로 세팅하고 방금 만들어둔 configuration 을 연결합니다.\nwebView = WKWebView(frame: .zero, configuration: configuration) webView 가 로드될 때 indicator 를 보여줄 수 있도록 WKNavigationDelegate 프로토콜을 채택하고 코드를 구현해보겠습니다.\nextension KakaoZipCodeVC: WKNavigationDelegate { func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!) { indicator.startAnimating() } func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) { indicator.stopAnimating() } } 함수의 Parameter 이름만 봐도 알 수 있듯이\nwebView(_:didStartProvisionalNavigation:) 는 webView 의 로드가 시작될 때 webView(_:didFinish:) 는 webView 의 로드가 끝날 때 각각 호출되게 됩니다. 그러니까 indicator 는 각각의 함수에 시작과 끝을 세팅하면 되겠죠?\nDelegate 위임도 잊지말고 해주세요.\nwebView?.navigationDelegate = self 이제 webView 가 우편번호 서비스 웹페이지를 띄울 수 있도록 URL 만 전달해주면 됩니다. guard 문을 사용해 optional 을 unwrapping 해주고 URLRequest 를 생성해 webView 가 해당 URL 을 load 할 수 있도록 넘겨줍니다.\nguard let url = URL(string: \u0026#34;https://kasroid.github.io/Kakao-Postcode/\u0026#34;), let webView = webView else { return } let request = URLRequest(url: url) webView.load(request) indicator.startAnimating() 마지막으로 오토레이아웃을 잡고 Simulator 를 실행시켜 보도록할게요.\nguard let webView = webView else { return } view.addSubview(webView) webView.translatesAutoresizingMaskIntoConstraints = false webView.addSubview(indicator) indicator.translatesAutoresizingMaskIntoConstraints = false NSLayoutConstraint.activate([ webView.topAnchor.constraint(equalTo: view.topAnchor), webView.leadingAnchor.constraint(equalTo: view.leadingAnchor), webView.trailingAnchor.constraint(equalTo: view.trailingAnchor), webView.bottomAnchor.constraint(equalTo: view.bottomAnchor), indicator.centerXAnchor.constraint(equalTo: webView.centerXAnchor), indicator.centerYAnchor.constraint(equalTo: webView.centerYAnchor), ]) 한가지 더!! ViewController 로 돌아가 handleButton 함수에 KakaoZipCodeVC 를 Present 할 수 있도록 구현합니다.\nlet nextVC = KakaoZipCodeVC() present(nextVC, animated: true) 이제 Simulator 를 실행시키고 Button 을 눌러보세요.\nSuccess!!\n데이터 전달하기 정상적으로 우편번호 서비스를 띄우는데 성공했으니 이제 사용자가 입력한 데이터를 받아올 일만 남았습니다.\nuserContentController(_:didReceive:) 함수 내부에 코드를 구현할게요.\nif let data = message.body as? [String: Any] { address = data[\u0026#34;roadAddress\u0026#34;] as? String ?? \u0026#34;\u0026#34; } guard let previousVC = presentingViewController as? ViewController else { return } previousVC.label.text = address self.dismiss(animated: true, completion: nil) 지금은 \u0026ldquo;roadAddress\u0026rdquo; 라는 항목만 추출했지만 message.body 를 print 해보면 다음과 같은 값들을 가져오는 것을 확인할 수가 있습니다.\n{ jibunAddress = \u0026#34;\\Uacbd\\Uae30 \\Uc131\\Ub0a8\\Uc2dc \\Ubd84\\Ub2f9\\Uad6c \\Uc6b4\\Uc911\\Ub3d9 1017-3\u0026#34;; roadAddress = \u0026#34;\\Uacbd\\Uae30 \\Uc131\\Ub0a8\\Uc2dc \\Ubd84\\Ub2f9\\Uad6c \\Ud310\\Uad50\\Ub85c 35\u0026#34;; zonecode = 13467; } 필요에 따라 지번 주소, 도로명 주소, 우편번호를 가져와서 사용할 수 있어요.\n이제 Simulator 를 실행하고 원하는 주소를 검색한 뒤에 클릭하면 내가 선택한 데이터가 ViewController 의 label 로 전달되는 것을 확인할 수 있습니다.\nWrap Up 처음 시도할 떄는 조금 복잡하게 느껴질 수 있지만 한번만 잘 따라해보면 그렇게까지 어려운 내용은 아니에요. 워낙 어려운게 많아야지\u0026hellip;\nGithub Pages 로 한번 구현해두면 계속해서 사용할 수 있으니 꼭 한번 만들어두고 앞으로 다양한 곳에서 활용해보세요. 그럼 오늘도 공부하느라 수고 많으셨습니다!\nimport UIKit import WebKit class KakaoZipCodeVC: UIViewController { // MARK: - Properties var webView: WKWebView? let indicator = UIActivityIndicatorView(style: .medium) var address = \u0026#34;\u0026#34; // MARK: - Lifecycle override func viewDidLoad() { super.viewDidLoad() configureUI() } // MARK: - UI private func configureUI() { view.backgroundColor = .white setAttributes() setContraints() } private func setAttributes() { let contentController = WKUserContentController() contentController.add(self, name: \u0026#34;callBackHandler\u0026#34;) let configuration = WKWebViewConfiguration() configuration.userContentController = contentController webView = WKWebView(frame: .zero, configuration: configuration) self.webView?.navigationDelegate = self guard let url = URL(string: \u0026#34;https://kasroid.github.io/Kakao-Postcode/\u0026#34;), let webView = webView else { return } let request = URLRequest(url: url) webView.load(request) indicator.startAnimating() } private func setContraints() { guard let webView = webView else { return } view.addSubview(webView) webView.translatesAutoresizingMaskIntoConstraints = false webView.addSubview(indicator) indicator.translatesAutoresizingMaskIntoConstraints = false NSLayoutConstraint.activate([ webView.topAnchor.constraint(equalTo: view.topAnchor), webView.leadingAnchor.constraint(equalTo: view.leadingAnchor), webView.trailingAnchor.constraint(equalTo: view.trailingAnchor), webView.bottomAnchor.constraint(equalTo: view.bottomAnchor), indicator.centerXAnchor.constraint(equalTo: webView.centerXAnchor), indicator.centerYAnchor.constraint(equalTo: webView.centerYAnchor), ]) } } extension KakaoZipCodeVC: WKScriptMessageHandler { func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) { if let data = message.body as? [String: Any] { address = data[\u0026#34;roadAddress\u0026#34;] as? String ?? \u0026#34;\u0026#34; } guard let previousVC = presentingViewController as? ViewController else { return } previousVC.label.text = address self.dismiss(animated: true, completion: nil) } } extension KakaoZipCodeVC: WKNavigationDelegate { func webView(_ webView: WKWebView, didStartProvisionalNavigation navigation: WKNavigation!) { indicator.startAnimating() } func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) { indicator.stopAnimating() } } ","permalink":"https://kasroid.github.io/posts/ios/20200916-webkit-search-address-with-kakao-with-uikit/","summary":"본 포스팅은 Swift 5.3 기준으로 작성되었습니다.\nIntro 저는 요새 Market Kurly 앱을 클론하는 프로젝트를 진행하고 있는데요. 회원가입 부분에서 Kakao 우편변호 찾기 기능을 지원하더라고요. 사용자로서는 분명히 사용해본 경험이 있는 것 같은데 막상 구현하는 방법은 배운적도 생각해본 적도 없었습니다 ㅎㅎ 어쨌든 중요한건 지금 어떻게든 구현을 해야한다는 것이고, 마켓컬리앱이 아니더라도 회원가입을 필요로하는 서비스라면 많이 지원하고 있는 기능이니까 잘 공부해서 정리해두면 나중에 쓸데가 많을 것 같아 포스팅을 남깁니다.\n서비스 확인하기 Kakao 우편번호 서비스 웹페이지 에 접속해보면 평소 우리가 회원가입을 할 때 자주 볼 수 있었던 화면이 하나 보일거에요.","title":"WebKit - 카카오 우편번호 서비스 구현하기 with UIKit"},{"content":"Intro UITextField 를 아이디나 비밀번호를 사용자로부터 입력받을 때 사용하게되면 글자수 제한을 두어야하는 경우가 있는데요. 이 때 글자수 입력을 제한할 수 있는 방법에 대해 알아보도록 하겠습니다.\nPrerequisite 테스트를 위해 새로운 프로젝트를 하나 생성하고 UITextField 하나를 View 의 중앙에 올려보았습니다.\nimport UIKit class ViewController: UIViewController { private var textField = UITextField() override func viewDidLoad() { super.viewDidLoad() configureUI() } // MARK: - UI private func configureUI() { setContraints() setAttributes() } private func setAttributes() { textField.layer.cornerRadius = 4 textField.layer.borderWidth = 1 textField.layer.borderColor = UIColor.lightGray.cgColor textField.placeholder = \u0026#34; Type your text here\u0026#34; } private func setContraints() { view.addSubview(textField) textField.translatesAutoresizingMaskIntoConstraints = false NSLayoutConstraint.activate([ textField.centerXAnchor.constraint(equalTo: view.centerXAnchor), textField.centerYAnchor.constraint(equalTo: view.centerYAnchor), textField.heightAnchor.constraint(equalToConstant: 50), textField.widthAnchor.constraint(equalToConstant: 300), ]) } } 이제 Simulator 를 실행해보면 텍스트 필드가 중앙에 보일거에요!\nUITextFieldDelegate 채택하기 프로그래밍이 언제나 그렇듯이 이 기능을 구현하는 방법도 여러가지가 있습니다만, 오늘은 UITextFieldDelegate 를 채택하고 textField(_:shouldChangeCharactersIn:replacementString:) method 를 호출해 해결을 해보도록 할게요.\ntextField(_:shouldChangeCharactersIn:replacementString:) method 는 TextField 의 값이 변할 때마다 호출되는 함수이며, 리턴값으로 Bool 타입을 가집니다. 리턴값이 true 일 경우 사용자가 입력한 텍스트가 TextField 에 입력되고 false 일 경우 입력을 무시하게 됩니다. 그럼 여기에 지속적으로 텍스트를 감시할 수 있는 코드를 구현하고 텍스트가 몇 자 이상일 때 값이 입력되지 않도록 구현해주면 되겠죠?\n먼저 UITextFieldDelegate 을 구현해볼게요.\nextension ViewController: UITextFieldDelegate { func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -\u0026gt; Bool { return true } } Delegate 위임도 잊지말고요!\ntextField.delegate = self 이제 textField(_:shouldChangeCharactersIn:replacementString:) 내부 코드를 구현해보겠습니다. 텍스트가 최대 5 자 까지만 입력될 수 있도록 해볼게요. 코드 단 한줄이면 됩니다.\nguard textField.text!.count \u0026lt; 5 else { return false } 이제 텍스트필드에 입력을 해보면 5 자 이상은 입력이 되지않을거에요 ㅎㅎ\nBackspace Event 감지하기 단 이렇게만 세팅을 해두면 문제점이 하나 생기는데요. 바로 5 글자를 입력한 이후부터는 그 사용자는 그 어떤 행동도 할 수가 없게됩니다. 최소한 글을 다시 수정할 수는 있어야 하잖아요? ㅎㅎ\n그래서 이번에는 Backspace 가 입력되었을 때는 글자를 삭제할 수 있도록 textField(_:shouldChangeCharactersIn:replacementString:) 내부에 코드를 추가해볼게요. 조금 전 작성했던 guard 문 위에 입력하면 됩니다.\nif let char = string.cString(using: String.Encoding.utf8) { let isBackSpace = strcmp(char, \u0026#34;\\\\b\u0026#34;) if isBackSpace == -92 { return true } } 으음\u0026hellip; 글쎄요. 이 코드는 저도 완전하게 이해하고 있는 부분이 아니라서 간단하게만 설명드리자면 string 은 호출되는 함수의 Parameter 로 들어오는 값이고, 사용자가 입력 시도한 값이 실제 입력여부와 관계없이 계속 들어오게 됩니다. 그리고 이렇게 들어오는 값을 Backspace 인지 판단하고 인코딩하여 UInt32 의 형태로 변환하는 과정입니다.\n코드의 2 번째 줄을 통해 사용자가 키보드에 입력하는 값을 문자 형태로 받을 수 있게되고, Backspace 의 경우에는 \\\\b 의 문자를 가집니다. Backspace 가 입력될 경우 UInt32 의 형태로 변환하게 되며, 이 값은 -92 라는 값을 가지므로 이 조건들을 모두 만족했을 경우에는 사용자의 입력이 실행되도록 리턴값을 수정해 주었습니다.\n여기까지 코드를 입력하고 다시 Simulator 를 실행해보면 조금 전까지는 5 자 이상 입력 시부터 지울 수 없던 글자들이 잘 지워지는 것을 확인할 수 있습니다.\nWrap Up 간단하면서도 자주 사용하지 않으면 잊어버리기 쉬운 내용입니다 ㅎㅎ 그래서 저는 이렇게 기록으로 남겨두고 필요할 때마다 빠르게 찾아쓰는 방향으로 하려고요. 아무튼 도움이 되셨길 바랍니다!\nimport UIKit class ViewController: UIViewController { private var textField = UITextField() override func viewDidLoad() { super.viewDidLoad() configureUI() } // MARK: - UI private func configureUI() { setContraints() setAttributes() } private func setAttributes() { textField.layer.cornerRadius = 4 textField.layer.borderWidth = 1 textField.layer.borderColor = UIColor.lightGray.cgColor textField.placeholder = \u0026#34; Type your text here\u0026#34; textField.delegate = self } private func setContraints() { view.addSubview(textField) textField.translatesAutoresizingMaskIntoConstraints = false NSLayoutConstraint.activate([ textField.centerXAnchor.constraint(equalTo: view.centerXAnchor), textField.centerYAnchor.constraint(equalTo: view.centerYAnchor), textField.heightAnchor.constraint(equalToConstant: 50), textField.widthAnchor.constraint(equalToConstant: 300), ]) } } extension ViewController: UITextFieldDelegate { func textField(_ textField: UITextField, shouldChangeCharactersIn range: NSRange, replacementString string: String) -\u0026gt; Bool { print(string) if let char = string.cString(using: String.Encoding.utf8) { let isBackSpace = strcmp(char, \u0026#34;\\\\b\u0026#34;) if isBackSpace == -92 { return true } } guard textField.text!.count \u0026lt; 5 else { return false } return true } } ","permalink":"https://kasroid.github.io/posts/ios/20200914-uitextfield-limits-number-of-text-detecting-backspace-event/","summary":"Intro UITextField 를 아이디나 비밀번호를 사용자로부터 입력받을 때 사용하게되면 글자수 제한을 두어야하는 경우가 있는데요. 이 때 글자수 입력을 제한할 수 있는 방법에 대해 알아보도록 하겠습니다.\nPrerequisite 테스트를 위해 새로운 프로젝트를 하나 생성하고 UITextField 하나를 View 의 중앙에 올려보았습니다.\nimport UIKit class ViewController: UIViewController { private var textField = UITextField() override func viewDidLoad() { super.viewDidLoad() configureUI() } // MARK: - UI private func configureUI() { setContraints() setAttributes() } private func setAttributes() { textField.","title":"UIKit - UITextField 입력글자수 제한 및 백스페이스 감지하기"},{"content":"Intro GUI 환경 대신 Terminal 을 사용하게되면 대부분의 작업이 더 편리해지지만 분명히 불편한 점도 생기기 마련입니다. 그 중 가장 대표적인 예가 File Browsing 이 아닐까해요. 요즘은 컴퓨터로 작업을 할 때 어떤 작업을 하든 꼭 필수적으로 사용해야하는 Tool 이 있는 경우가 아니라면 모든 작업을 Terminal 에서 해결하려고 하는데 File Browsing 만큼은 아직도 Finder 에 의존할 때가 많습니다. 파일명을 변경하거나 복사, 이동하는 작업이 Terminal 에서는 좀 불편하더라고요.\n그럼 잘 만들어놓은 Finder 를 놔두고 왜 굳이 Terminal 에서 작업을 하려고 하느냐. 바로 Workflow 때문입니다. 제가 애초에 Terminal 을 주력으로 쓰게된 이유도 이곳에서는 모든 작업을 창 전환 없이 키보드만으로도 진행할 수 있기 때문이죠.\n그래서 CLI 환경에서 쓸만한 File Browser 를 찾다보니 후보가 Ranger 와 Midnight Commander 로 추려지더라고요. 둘 다 꽤 유명한 프로그램이지만 그래도 사용자의 수가 인지도면에서는 Midnight Commander 가 우위였지만, 저는 좀 더 미려한 인터페이스와 최신 기능을 탑재한 Ranger 를 사용하기로 결정했습니다. 그럼 바로 설치를 진행해 볼게요.\nInstallation Ranger Github 의 README 에서 여러가지 정보를 확인할 수 있습니다만, 제가 원하는 설치방법은 기재되어 있지 않아 구글링으로 Homebrew 로 설치할 수 있는 방법을 검색 해보니 역시 가능했습니다.\nbrew install ranger 간단하게 설치를 마치고나면 바로 Terminal 에서 ranger 라는 커맨드를 사용할 수 있게됩니다.\nBasics 그럼 ranger 커맨드를 입력해 File Browser 를 실행시켜볼게요.\n그냥 보기만해도 어떻게 사용해야할지 감이 오네요 ㅎㅎ 정말 직관적이고 깔끔한 인터페이스인 것 같아요. 역시 Ranger 를 선택하길 잘한 것 같네요 ㅋㅋㅋ\n기본 조작법을 잠깐 살펴보자면 기본 Vim 키인 h, j, k, l 나 방향키 로 기본 조작을 할 수 있으며, 심지어 마우스 로도 조작이 가능합니다. 근데 마우스 조작할거면 그냥 Finder 를 썼지\u0026hellip;\nConfig 파일 생성 및 관리하기 Ranger 역시도 Vim 과 비슷하게 rc.config 라는 파일을 통해 여러가지 세팅을 저장하고 사용할 수 있습니다. Vim 에서 세팅을 한번 이상 해본 분이라면 익숙할거에요 ㅎㅎ 다만 Ranger 를 방금 설치했다면 원래 이 설정파일이 위치해야하는 ~/.config/ranger/ 경로에 저처럼 어떤 파일도 없을거에요.\n이곳에 설정과 관련된 파일들이 있어야하는데 이렇게 아무 것도 없습니다. 그럼 우리가 직접 커맨드를 실행해 설정파일들을 생성해보겠습니다.\n$ ranger --copy-config=all 이렇게 입력을 하면 여러가지 파일이 생성되고 이 중 우리가 설정에 사용하게 될 파일은 rc.config 파일입니다.\n이제 파일이 생성되었으니까 직접 한번 여러가지 기본 설정들을 진행해보도록 하겠습니다.\nImage Preview 기능 추가하기 Rnager 를 막 설치했다면 기본 세팅으로는 Finder 에서 처럼 이미지 미리 보기가 사용이 안되는데요.\n이렇게 Image 를 미리 확인할 수 있으면 매번 어떤 파일인지 확인하는 수고가 덜어지고 시간도 훨씬 절약되잖아요? 그래서 이 기능을 Ranger 에서도 사용할 수 있도록 세팅을 하려고 합니다.\n그럼 세팅을 위해 우리가 조금 전 생성한 rc.config 파일을 Vim 으로 열어볼게요. Vim 이 익숙하지 않다면 당연히 Vim 외 어떤 텍스트 에디터로 열어도 괜찮습니다.\n헐.. 텅 비어있을 줄 알았는데 초깃값들이 무언가 많네요. 대략적으로 설명하자면 여러가지 단축키 설정들이며 이 곳을 수정해 본인이 원하는 단축키를 사용할 수도 있습니다. 저희는 Image Preview 를 구현하는게 목표니까 이건 넘어가도록하고\u0026hellip;\n검색을 통해 set preview_images false 라고 입력되어 있는 부분을 찾아 set preview_images true 로 변경해 주세요. 일단 우리는 Ranger 에게 Preview 기능을 사용하고 싶다고 알려줬습니다. 하지만 이게 끝이 아니라 어떤 방식으로 사용할건지를 최종적으로 한번 더 확인시켜줘야하는데요. 이 방법에는 여러가지가 있지만 저는 iTerm2 라는 Application 에서 제공하는 기능을 이용해 Preview 기능을 활성화해보도록 할게요.\n이번에는 set preview_images_method 라고 입력되어 있는 부분을 찾아볼게요. 기본값은 w3m 으로 되어 있을텐데 저는 이 코드를 코멘트 처리하고 set preview_images_method iterm2 를 새롭게 입력했습니다.\nPreview 가 화면 우측에 잘 표시되는 것을 볼 수가 있네요!!\nShortcuts 추가적으로 앞으로 Ranger 를 사용하면서 자주 쓸만한 단축키들을 정리해봤어요. Vim 에 익숙하다면 대부분 금방 적응할 수 있을만한 단축키네요!\nTitle Shortcut 파일 이름 변경하기 cr 파일 이름 앞쪽에서부터 변경 I 파일 이름 뒷쪽에서부터 변경 A 파일 복사하기 yy 파일 잘라내기 dd 파일 붙여넣기 pp 파일 및 폴더 삭제하기 dD 파일 개별 선택 space 파일 전체 선택 v 파일 선택 전체 해제 uv 숨김파일 보이기 설정 토글 zh 경로를 Home 으로 이동 gh 선택된 폴더의 사이즈 확인 dc Parent 폴더에서 위,아래 이동 [ , ] 새로운 탭 생성하기 control + n or gn 현재 탭 닫기 control + w or gc 다음 탭으로 이동 tab or gt 이전 탭으로 이동 shift + tab or ** gT 파일 및 폴더의 경로 Bookmark m + { x } Bookmark 찾아가기 ` + { x } Shell 커맨드 사용하기 ! or s 무거운 작업 로드에서 탈출 J 종료하기 q 더 많은 단축키는 이곳을 참조하세요.\nWrap Up 오늘은 Terminal 에서 File Browsing 을 좀 더 편하게 할 수 있도록 공부를 해보았는데요. 이렇게 Terminal 과 점점 더 친해지는 것 같아 기분이 좋습니다. 여러분들도 Terminal 과 빨리 친해지길 바랍니다! 다른 이유도 많지만 일단 Terminal 이 간지나잖아요!!\n","permalink":"https://kasroid.github.io/posts/developertools/20200915-ranger-installation-and-basics/","summary":"Intro GUI 환경 대신 Terminal 을 사용하게되면 대부분의 작업이 더 편리해지지만 분명히 불편한 점도 생기기 마련입니다. 그 중 가장 대표적인 예가 File Browsing 이 아닐까해요. 요즘은 컴퓨터로 작업을 할 때 어떤 작업을 하든 꼭 필수적으로 사용해야하는 Tool 이 있는 경우가 아니라면 모든 작업을 Terminal 에서 해결하려고 하는데 File Browsing 만큼은 아직도 Finder 에 의존할 때가 많습니다. 파일명을 변경하거나 복사, 이동하는 작업이 Terminal 에서는 좀 불편하더라고요.\n그럼 잘 만들어놓은 Finder 를 놔두고 왜 굳이 Terminal 에서 작업을 하려고 하느냐.","title":"Ranger - CLI File Browser 설치 및 사용법"},{"content":"Intro UITableView 를 사용하면서 그동안은 항상 RowHeight 값을 설정하여 높이를 지정해주었었는데요. 이번 프로젝트 진행하면서 셀 크기가 상황에 따라 유동적으로 변하는 케이스가 있어 자동으로 세팅하는 방법에 대해 공부를 해봅니다 ㅎㅎ\nSetup 실습을 위해 UITableViewCell 을 상속받은 CustomTableViewCell 을 생성하고 ViewController 위에 TableView 를 올려놓았습니다.\n기본 세팅은 아래 코드를 참고하세요.\nViewController.swift\nimport UIKit class ViewController: UIViewController { // MARK: - Properties private let tableView = UITableView() override func viewDidLoad() { super.viewDidLoad() configureUI() } // MARK: - UI private func configureUI() { view.backgroundColor = .blue setContraints() setAttributes() } private func setAttributes() { tableView.register(CustomTableViewCell.self, forCellReuseIdentifier: CustomTableViewCell.identifier) tableView.dataSource = self tableView.delegate = self } private func setContraints() { view.addSubview(tableView) tableView.translatesAutoresizingMaskIntoConstraints = false NSLayoutConstraint.activate([ tableView.topAnchor.constraint(equalTo: view.topAnchor), tableView.leadingAnchor.constraint(equalTo: view.leadingAnchor), tableView.trailingAnchor.constraint(equalTo: view.trailingAnchor), tableView.bottomAnchor.constraint(equalTo: view.bottomAnchor), ]) } } extension ViewController: UITableViewDataSource { func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -\u0026gt; Int { return 30 } func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -\u0026gt; UITableViewCell { guard let cell = tableView.dequeueReusableCell(withIdentifier: CustomTableViewCell.identifier, for: indexPath) as? CustomTableViewCell else { fatalError() } return cell } } extension ViewController: UITableViewDelegate { } CustomTableViewCell.swift\nimport UIKit class CustomTableViewCell: UITableViewCell { // MARK: - Properties static let identifier = \u0026#34;CustomTableViewCell\u0026#34; // MARK: - Lifecycle override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) { super.init(style: style, reuseIdentifier: reuseIdentifier) configureUI() } required init?(coder: NSCoder) { fatalError(\u0026#34;init(coder:) has not been implemented\u0026#34;) } // MARK: - UI private func configureUI() { setContraints() } private func setContraints() { } } Cell AutoLayout 구현하기 TableView 는 ScrollView 를 상속받아서 만들어졌기 때문인지 ScrollView 와 비슷한 속성을 지니고 있는데요. Constraints 를 확실하게 잡아주면 스크롤이 가능하도록 스스로 크기를 조절하고, Cell 역시도 topAnchor 와 bottomAnchor 를 잡고 내부 컨텐츠의 heightAnchor 가 잡혀있다면 스스로 크기를 조절하게 됩니다.\n그럼 우리가 생성해놓은 CustomTableViewCell 에 색을 입힌 UIView 를 2 개 배치하고, 이 View 들의 크기에 따라 Cell 의 크기가 자동적으로 변할 수 있도록 구현해보겠습니다.\nCustomTableViewCell.swift\nimport UIKit class CustomTableViewCell: UITableViewCell { // MARK: - Properties static let identifier = \u0026#34;CustomTableViewCell\u0026#34; private let upperView = UIView() private let lowerView = UIView() // MARK: - Lifecycle override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) { super.init(style: style, reuseIdentifier: reuseIdentifier) configureUI() } required init?(coder: NSCoder) { fatalError(\u0026#34;init(coder:) has not been implemented\u0026#34;) } // MARK: - UI private func configureUI() { setContraints() setAttributes() } private func setAttributes() { upperView.backgroundColor = .red lowerView.backgroundColor = .blue } private func setContraints() { [upperView, lowerView].forEach { self.addSubview($0) $0.translatesAutoresizingMaskIntoConstraints = false } NSLayoutConstraint.activate([ upperView.topAnchor.constraint(equalTo: self.topAnchor, constant: 20), upperView.leadingAnchor.constraint(equalTo: self.leadingAnchor, constant: 20), upperView.trailingAnchor.constraint(equalTo: self.trailingAnchor, constant: -20), upperView.heightAnchor.constraint(equalToConstant: 100), lowerView.topAnchor.constraint(equalTo: upperView.bottomAnchor, constant: 10), lowerView.leadingAnchor.constraint(equalTo: self.leadingAnchor, constant: 20), lowerView.trailingAnchor.constraint(equalTo: self.trailingAnchor, constant: -20), lowerView.bottomAnchor.constraint(equalTo: self.bottomAnchor, constant: -20), lowerView.heightAnchor.constraint(equalToConstant: 150), ]) } } 이렇게 코드를 입력하고 Simulator 를 실행시켜보면 우리가 별도의 설정이나 작업을 하지 않았는데도, 스스로 내부에 위치한 View 들의 높이를 계산하여 Cell 의 높이를 조절한 것을 알 수 있습니다.\n잘 늘어난게 보이네요 ㅎㅎㅎ 생각보다 너무 쉽지 않았나요? 그동안은 RowHeight 를 직접 설정하는 방법으로 TableView 를 구현했었지만 이제부터는 Cell 이 스스로 높이를 조절하는 방향으로 View 를 짜게될 것 같습니다. 이 방법이 훨씬 편하고 유연성이 있는 것 같아요 ㅎㅎ\nWrap Up 이렇게 TableView 를 사용할 때 Cell 의 크기를 자동으로 설정할 수 있게하는 방법을 알아보았는데요.\n핵심 내용을 정리해보면\nTableView 에는 별도의 설정이 필요없다. Cell 내부에 위치한 View 의 topAnchor 와 bottomAnchor 를 확실하게 잡아준다. View 의 heightAnchor 또한 확실하게 잡는다. 이 정도로 요약해볼 수 있을 것 같네요. 무언가 정상적으로 작동하지 않을 때는 위 3 가지를 먼저 확인해보면 좋을 것 같습니다.\n","permalink":"https://kasroid.github.io/posts/ios/20200913-uitableview-self-sizing-cells/","summary":"Intro UITableView 를 사용하면서 그동안은 항상 RowHeight 값을 설정하여 높이를 지정해주었었는데요. 이번 프로젝트 진행하면서 셀 크기가 상황에 따라 유동적으로 변하는 케이스가 있어 자동으로 세팅하는 방법에 대해 공부를 해봅니다 ㅎㅎ\nSetup 실습을 위해 UITableViewCell 을 상속받은 CustomTableViewCell 을 생성하고 ViewController 위에 TableView 를 올려놓았습니다.\n기본 세팅은 아래 코드를 참고하세요.\nViewController.swift\nimport UIKit class ViewController: UIViewController { // MARK: - Properties private let tableView = UITableView() override func viewDidLoad() { super.viewDidLoad() configureUI() } // MARK: - UI private func configureUI() { view.","title":"UIKit - UITableView 셀 크기가 자동으로 세팅되도록 구현하기"},{"content":"Intro Mac 시스템 내부의 모든 파일은 User 라고하는 파일의 관리자가 명시되어 있으며, 관리자 외의 다른 User 는 파일의 읽기 및 쓰기 권한에 제한을 받을 수 있습니다. 사실 맥북같은 경우 혼자 사용하기 때문에 이런 권한들에 대해 거의 관심을 가져본 적이 없지만, 그래도 기본 개념정도로 알아두고 지나가면 좋을 것 같아 정리를 해볼려고요! ㅎㅎ\nFinder 에서 User 및 권한 확인하기 먼저 내 맥북에는 어떤 User 가 있는지 확인을 해보겠습니다. Finder 를 열고 최상위 루트로 가보면 아래 스크린샷처럼 유저 목록이 보일거에요. 제 맥북에는 kas 와 shared 두 개의 User 가 존재하네요. 그동안 한번도 신경쓰지 않았더라도 우리는 항상 어떤 User 로서 맥북에서 작업을 하고 있었답니다.\n이제 Finder 에서 아무 파일이나 폴더를 클릭하고 command + i 를 눌러 접근 권한을 확인해볼게요. 새로운 창이 하나 떳을텐데 이곳의 가장 아래쪽에서 User 별 접근권한 목록을 확인할 수 있습니다.\n제가 열은 폴더를 기준으로 kas 라는 User 는 모든 권한을 가지고 있고, everyone 이라는 User 는 어떤 권한도 갖고있지 않네요 ㅎㅎ 참고로 everyone 은 이곳에 따로 명시된 User 외에 다른 모든 User 를 뜻합니다.\nTerminal 에서 User 및 권한 확인하기 이제 Terminal 에서 같은 결과를 확인해보도록 할게요. 조금 전 Finder 에서 열었던 것과 경로에서 ls -l 커맨드를 입력해보세요. 출력된 내용의 좌측에 알 수 없는 영문들이 보일텐데 이것이 우리가 조금 전 Finder 에서 본 것과 똑같은 내용입니다.\n접근권한에 대해 조금 더 자세히 알아보기 전에 Terminal 에 출력된 내용을 우측부터 하나씩 정리해볼게요.\n일단 가장 오른쪽에 위치한 것은 이미 알고 계셨겠지만 파일이나 폴더의 이름입니다. 그리고 그 옆에 있는 날짜는 해당 폴더나 파일이 최종적으로 생성되거나 업데이트된 날짜를 의미합니다. 그리고 그 옆의 숫자는 용량인데요. 이 상태로는 우리가 알아보기 쉽지 않은 형태이기 때문에 그냥 용량을 의미하는구나 정도로만 알아두세요.\n그리고 다시 옆에 staff 라고 써진 부분이 보이는데요. 이것은 Group 을 의미합니다. 앞서 설명드리진 않았지만 모든 User 는 특정 Group 에 속해있거든요. 일단은 이 부분도 이 정도만 알고 넘어가면 될 것 같아요. 그리고 다시 옆을 보면 kas 라는 단어가 보이죠? 이것이 해당 폴더나 파일의 Owner 즉 관리자를 의미합니다.\nOwner 옆에 있는 숫자는 해당 파일이나 폴더에 연결되어 있는 link 의 갯수를 뜻하는데요. 우리에게 별 의미가 없는 부분이므로 스킵하겠습니다.\n마지막으로 가장 왼쪽에 위치한 부분이 바로 접근권한입니다. 하나씩 살펴볼게요. 일단 이것을 읽는 방법은 첫번째 글자를 먼저 해석하고, 나머지는 3 글자 단위로 묶어서 해석을 하면 되는데요. 그래서 첫 글자부터 살펴보면 현재 표시된 내용이 파일인지 폴더인지를 구분하는 역할입니다. 제가 찍은 스크린샷에서는 전부 폴더만 있는 경로라 모두 d 로 시작하네요. 파일은 - 로 시작합니다.\n이 다음부터는 3 글자씩 끊어서 읽으면 된다고 했죠?? 그러니까 첫번째 글자 다음으로 오는 3 글자 rwx 만 생각해볼게요. 얘네는 Owner 의 권한입니다.\n각 알파벳이 뜻하는 의미는 이렇습니다.\nr 은 readable w 는 writable x 는 executable 각각 순서대로 읽기, 쓰기, 실행이고, 만약 - 로 표시되어 있다면 해당 권한이 없다는 뜻입니다. 지금 우리가 보는 부분은 Owner 의 접근권한인만큼 웬만하면 거의 모든 권한이 다 있을거에요.\n다음 3 글자는 staff 라는 Group 이 접근할 수 있는 권한을 의미합니다. 위에서 Group 이라는게 있다고만 설명했었는데요. 어떤 User 는 여러 개의 Group 에 동시에 속할 수 있습니다. 그리고 만약 해당 User 가 Owner 가 아니라면 Group 의 권한을 갖게되는 거에요.\n마지막 3 글자는 Owner 가 아니고 Group 에 속하지 않은 User 의 권한을 의미합니다.\nWrap Up 이렇게 User 와 Group 의 존재, 그리고 파일의 접근권한에 대해 알아보았는데요. Terminal 을 사용하다보면 자주 볼 수밖에 없는 부분인만큼 정확히 알아두고 지나가면 좋을 것 같아서 공부해보았습니다. 사실 제 기준으로는 아직까지 이 개념들을 유용하게 써볼 일은 없었어요 ㅎㅎㅎ 그래도 알아두고 지나가자구요!!\n","permalink":"https://kasroid.github.io/posts/developertools/20200908-terminal-understanding-of-organization-of-files-in-mac/","summary":"Intro Mac 시스템 내부의 모든 파일은 User 라고하는 파일의 관리자가 명시되어 있으며, 관리자 외의 다른 User 는 파일의 읽기 및 쓰기 권한에 제한을 받을 수 있습니다. 사실 맥북같은 경우 혼자 사용하기 때문에 이런 권한들에 대해 거의 관심을 가져본 적이 없지만, 그래도 기본 개념정도로 알아두고 지나가면 좋을 것 같아 정리를 해볼려고요! ㅎㅎ\nFinder 에서 User 및 권한 확인하기 먼저 내 맥북에는 어떤 User 가 있는지 확인을 해보겠습니다. Finder 를 열고 최상위 루트로 가보면 아래 스크린샷처럼 유저 목록이 보일거에요.","title":"Terminal - Mac 의 파일권한 시스템 이해하기"},{"content":"Intro 제가 개발은 iOS 만 해봤지만 그래도 공부하다보니 느낀 것이 어떤 개발을 하더라도 한가지 꼭 사용할 줄 알아야하는 툴이 Terminal 이 아닐까 싶습니다. Git 만 사용하려고해도 Terminal 을 사용해야 하잖아요? 대체방법이 없는 것은 아니지만\u0026hellip;\n그래서 이왕 사용하는거 좀 더 체계적으로 제대로 사용할 수 있으면 좋겠다 싶어서 공부를 시작했습니다. 그리고 터미널 잘 쓰면 왠지 멋있어 보이기도 하잖아요 ㅋㅋㅋ 그러니까 오늘부터 같이 공부해서 터미널 고수가 되어보아요~\n그럼 Terminal 의 커맨드는 어떻게 구성되는지, 그리고 알아두면 좋을만한 매우 기초적인 커맨드를 공부해 볼게요.\nCommands 는 어떻게 구성될까요? 실제로 Terminal 에서 커맨드를 사용해보기 전에 간단하게 커맨드가 어떻게 구성되는지 공부해보겠습니다. 언제나 이렇게 기초적인 것들은 재미가 없지만 그래도 기본기가 중요하니까요 ㅎㅎ\nCommands 의 3가지 종류 커맨드에는 크게 3 가지 종류가 있습니다.\n커맨드 자체만으로 동작할 수 있는 경우 커맨드 외에 다른 무언가와 함께 동작할 수 있는 경우 커맨드가 추가 옵션과 함께 다른 동작을 수행할 수 있는 경우 그동안 복잡해만 보였던 커맨드들도 결국 다 이 3 가지 종류 중에 하나일 뿐입니다. 그러니까 너무 어렵게 생각할 필요가 없어요~\nSyntax of Commands 그리고 이런 커맨드들은 다음과 같은 규칙을 따릅니다.\nCommand (-option) (something) 조금 전 읽었던 3 가지 종류의 커맨드를 모두 이런 형태로 사용할 수가 있습니다. 단 option 과 something 모두 입력해야 할 경우에는 순서가 중요하고, 그렇지 않은 경우 커맨드에 따라 -option 이나 something 을 생략할 수 있습니다.\n기본적인 커맨드 알아보기 whoami Terminal 을 실행하고 제일 먼저 우리가 사용하는 컴퓨터의 사용자가 누군지 알아볼게요. whoami 를 입력하면 현재 컴퓨터의 사용자를 확인할 수 있습니다.\n$ whoami 사용자명이 잘 뜨네요 ㅎㅎ whoami 커맨드는 다른 옵션이나 추가정보가 없어도 혼자서 작동할 수 있는 커맨드라는 것을 알 수 있어요.\npwd 다음으로는 우리의 현재 위치한 폴더의 경로를 알아보겠습니다. pwd 를 입력해보세요.\n$ pwd 현재 저는 /Users/kas 라는 위치에 있어요. 그래도 나름 Terminal 을 몇 개월간 사용해왔는데 이 명령어는 잘 쓰지 않게 되더라고요. 굳이 이 명령어가 없어도 iTerm2 에서 status bar 설정을 통해 내 위치가 계속 표시되게 할 수 있어서 그런가봐요.\nls 그리고 마지막으로 ls 커맨드 사용해 현재 내가 위치한 곳에 있는 파일 및 폴더 등을 확인할 수 있습니다.\n$ ls 하지만 이 방식으로는 숨겨진 폴더 및 파일을 확인할 수 없는데요. 이 때 사용할 수 있는 명령어로는 ls -a 가 있습니다. -a 처럼 - 가 붙는 경우는 커맨드에 일종의 옵션을 부여했다라고 생각하면 됩니다. 여기서는 All Files 를 의미하는 a 옵션을 주었기 때문에 숨김파일도 볼 수 있다라고 생각하면 좋을 것 같아요.\n$ ls -a 이전보다 훨씬 뭐가 많아졌죠?? 일반적인 사용자들이 함부로 건들면 시스템이 꼬일 수도 있는 파일들이라 이렇게 숨겨져있는거에요. 우리 눈에만 보이지 않았을 뿐 사실 보이는 것 보다 더 많은 파일들이 숨어있답니다.\ndate 이제 오늘 날짜를 확인해 볼게요. date 라고 입력해보세요.\n$ date 간단하면서도 유용한 명령어에요 ㅎㅎ\ncal 캘린더를 확인하는 방법도 있습니다. cal 커맨드를 입력해보세요. 현재 날짜가 속한 달의 캘린더를 확인할 수 있습니다.\n$ cal 이번 달이 아니라 원하는 특정 월의 캘린더를 확인하고 싶다면 cal 커맨드에 이어 월, 연도 순으로 입력하면 됩니다. 처음으로 옵션이 아닌 다른 값을 커맨드와 함께 입력했어요. 이게 우리가 위해서 보았었던 something 입니다.\n$ cal 09 2020 연도만 입력하면 해당 년에 속하는 12개월치 캘린더가 출력됩니다.\necho 우리가 프로그래밍을 배울 때 보통 \u0026ldquo;Hello World\u0026rdquo; 를 어떻게 출력하는지 부터 배우잖아요? Terminal 에서도 \u0026ldquo;hello\u0026rdquo; 를 한번 출력해볼게요.\n$ echo \u0026#34;hello\u0026#34; echo 는 일단 대부분의 프로그래밍 언어에서 사용하는 print 에 대응하는 커맨드라고 생각하면 좋을 것 같아요.\nsay 거의 사용할 일은 없지만 say 라는 커맨드도 있어요. 커맨드 뒤에 입력되는 글을 소리내서 읽어줍니다.\n$ say \u0026#34;hello there\u0026#34; 여러분 사용하는 컴퓨터의 목소리를 들어본 적이 있었나요? ㅋㅋㅋ Siri 말고 또 다른 친구가 있었어요. 이중인격?\n이렇게 Terminal 에서 커맨드를 사용하는데 있어 알아두면 유용하게 사용할 수 있을만한 내용들을 공부해보았습니다. 마지막으로 배운 내용들을 한눈에 살펴볼 수 있도록 정리하고 포스팅 마칠게요. 오늘도 읽느라 수고 많으셨습니다!\nWrap Up Role Shortcut 현재 사용자명 확인하기 whoami 현재 디렉토리 확인하기 pwd 현재 디렉토리 내의 파일 및 폴더 확인하기 ls 현재 디렉토리 내의 숨김파일 및 폴더까지 확인하기 ls -a 현재 날짜 및 시간 확인하기 date 현재 날짜 기준으로 캘린더 확인하기 cal 터미널에서 문자 출력하기 echo 문자를 소리내서 읽게하기 say ","permalink":"https://kasroid.github.io/posts/developertools/20200907-terminal-first-fundamental-commands/","summary":"Intro 제가 개발은 iOS 만 해봤지만 그래도 공부하다보니 느낀 것이 어떤 개발을 하더라도 한가지 꼭 사용할 줄 알아야하는 툴이 Terminal 이 아닐까 싶습니다. Git 만 사용하려고해도 Terminal 을 사용해야 하잖아요? 대체방법이 없는 것은 아니지만\u0026hellip;\n그래서 이왕 사용하는거 좀 더 체계적으로 제대로 사용할 수 있으면 좋겠다 싶어서 공부를 시작했습니다. 그리고 터미널 잘 쓰면 왠지 멋있어 보이기도 하잖아요 ㅋㅋㅋ 그러니까 오늘부터 같이 공부해서 터미널 고수가 되어보아요~\n그럼 Terminal 의 커맨드는 어떻게 구성되는지, 그리고 알아두면 좋을만한 매우 기초적인 커맨드를 공부해 볼게요.","title":"Terminal - 기본적인 사용법 알아보기"},{"content":"Intro 그래도 명색이 iOS 개발자인데 여태 Vim 을 사용할 때 Swift Syntax Highlighting 없이 글을 쓰고 있었어요 ㅎㅎ 그래서 오늘은 Vim 에 Swift Syntax 를 적용할 수 있는 방법을 공부해볼까 합니다. Plugin 하나만 설치해주면 끝나는거라 쉽게 해결할 수 있을 것 같아요.\nPrerequisite 이번 포스팅에서 Plugin 을 설치하는 과정은 Vundle 로 진행되므로 만약 Vundle 에 익숙하지 않다면 Vim - Vundle 및 Markdown Plugin 설치하기 포스팅을 먼저 참고해주세요.\nswift.vim 설치하기 Swift Syntax 를 적용하기 위해서는 swift.vim Plugin 을 설치해야 합니다. .vimrc 파일에 Plugin 'keith/swift.vim' 를 입력하고 설치를 진행하도록 하겠습니다.\nPlugin \u0026#39;keith/swift.vim\u0026#39; 설치를 끝내고 기존에 작성했던 포스팅 중 Swift Syntax 를 사용한 글에 다시 들어가보니 깔끔하게 적용되는 모습이네요. 오늘은 별다른 우여곡절없이 성공한 것 같아 기쁩니다 ㅎㅎㅎ\n확실히 Syntax 가 적용되었을 때랑 아닌 경우는 가독성의 차이가 많이나는 것 같아요. 그러니까 저처럼 Vim 으로 블로그를 작성한다거나 하는 상황이 아니더라도 iOS 를 공부하고 있다면 미리 설치해 놓는 것을 추천할게요~\n","permalink":"https://kasroid.github.io/posts/developertools/20200907-vim-applying-swfit-syntax-in-code-block/","summary":"Intro 그래도 명색이 iOS 개발자인데 여태 Vim 을 사용할 때 Swift Syntax Highlighting 없이 글을 쓰고 있었어요 ㅎㅎ 그래서 오늘은 Vim 에 Swift Syntax 를 적용할 수 있는 방법을 공부해볼까 합니다. Plugin 하나만 설치해주면 끝나는거라 쉽게 해결할 수 있을 것 같아요.\nPrerequisite 이번 포스팅에서 Plugin 을 설치하는 과정은 Vundle 로 진행되므로 만약 Vundle 에 익숙하지 않다면 Vim - Vundle 및 Markdown Plugin 설치하기 포스팅을 먼저 참고해주세요.\nswift.vim 설치하기 Swift Syntax 를 적용하기 위해서는 swift.","title":"Vim - 코드블럭에 Swift Syntax 적용하기"},{"content":"Intro 이번 포스팅은 블로그 검색 등록하기 시리즈 2회분 Naver Search Advisor 입니다. 전체적인 흐름은 Google 에 등록할 때와 비슷하니까 이전 포스팅에서 넘어온 분들은 진행이 조금 더 수월할 것 같아요. 그럼 바로 시작할게요.\nNaver Search Advisor Naver Search Advisor 에 접속합니다. 다음과 같은 화면이 보이네요.\n스크롤을 조금 아래로 내려 웹마스터 도구 사용하기 버튼을 눌러주세요.\n이용동의 화면은 언제나처럼 읽지 않고 동의버튼을 눌러주고요 ㅋㅋㅋ 이거 읽는 분 손?\n다음 화면에서는 내 블로그 주소를 입력하고 검색창 가장 우측에(x 표시 옆) 다음으로 넘어가기 같지 않은 버튼을 눌러주세요.\n조금 전 Google 에 등록했을 때처럼 Naver 도 사이트 소유확인을 해야합니다. HTML 확인 파일 을 눌러 파일을 다운로드하고 public 폴더에 넣어주세요. 그리고 블로그 재발행까지 해줄게요.\n이제 소유확인을 눌러주면 네이버 검색엔진 등록이 완료됩니다. 다만 아직 한가지 더 sitemap 을 제출해줘야 하는데요. 등록된 사이트 명을 눌러 사이트 관리 로 진입하고 좌측의 요청 카테고리에서 사이트맵 제출 을 눌러줍니다.\nHugo 블로그는 기본적으로 sitemap.xml 파일을 가지고 있으므로 그냥 주소를 입력하고 추가하면 제출이 완료됩니다.\n이렇게 Naver 검색엔진 등록을 마쳤습니다. 몇 가지 해결해야 할 문제가 남아있지만 일단 오늘은 이것으로 포스팅을 마치겠습니다.\n","permalink":"https://kasroid.github.io/posts/developertools/20200906-hugo-register-in-naver-search-advisor/","summary":"Intro 이번 포스팅은 블로그 검색 등록하기 시리즈 2회분 Naver Search Advisor 입니다. 전체적인 흐름은 Google 에 등록할 때와 비슷하니까 이전 포스팅에서 넘어온 분들은 진행이 조금 더 수월할 것 같아요. 그럼 바로 시작할게요.\nNaver Search Advisor Naver Search Advisor 에 접속합니다. 다음과 같은 화면이 보이네요.\n스크롤을 조금 아래로 내려 웹마스터 도구 사용하기 버튼을 눌러주세요.\n이용동의 화면은 언제나처럼 읽지 않고 동의버튼을 눌러주고요 ㅋㅋㅋ 이거 읽는 분 손?\n다음 화면에서는 내 블로그 주소를 입력하고 검색창 가장 우측에(x 표시 옆) 다음으로 넘어가기 같지 않은 버튼을 눌러주세요.","title":"Hugo - 블로그 Naver Search Advisor 에 등록하기"},{"content":"Intro UITableView 를 별 다른 설정없이 인스턴스화해서 사용해보면 Style 기본값이 .plain 으로 설정되어 있어 Header 를 사용하는 경우 스크롤을 하더라도 바로 사라지는 것이 아니라 계속 남아있게 되는데요. 이것을 해결하려면 tableView 의 Style 을 .grouped 로 지정해주면 Header 가 다른 셀들과 같은 방식으로 스크롤되게 됩니다.\n그런데 이렇게 사용하면 문제점이 하나 발생하는데 우리는 Footer 가 필요없고 Header 만 필요한 경우에도 자동적으로 Footer 까지 생성되는 상황이 발생하는거에요. 이것 때문에 골치를 여러번 썩으면서도 공부해서 해결하기보다 바쁘다는 핑계로 여태까지 우회하는 방법으로 해결을 했었거든요. 그런데 오늘 프로젝트를 진행하면서 같은 상황을 또 마주치게 되어 확실히 해결하는 방법을 공부해보았습니다.\nPreconfigure 간단하게 연습해보기 위해 ViewController 에 Grouped Style 로 UITableView 를 하나 올려놓았어요. 그리고 tableView(_:viewForHeaderInSection:) 를 구현하고 회색 BackgroundColor 를 가진 뷰를 리턴했습니다.\nfunc tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -\u0026gt; UIView? { let view = UIView() view.backgroundColor = .gray return view } func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -\u0026gt; CGFloat { return 10 } .plain Style 에서 이렇게 구현했다면 Header 만 생성되었을텐데요. Apple 이 기본세팅을 왜 이렇게 해놓았는지 모르겠지만 .grouped Style 에서는 자동적으로 Footer 뷰까지 생성이 됩니다.\n우리는 분명히 Header 를 회색으로 지정해 놓았는데 빨간색 화살표로 표시된 부분에 우리는 생성한적 없는 다른 뷰가 하나 있잖아요? 저게 바로 Footer 입니다. 자동으로 생성되었어요. 처음에는 저게 Footer 라는 사실을 몰라서 더 많이 헤맸던 것 같아요. 알고나니 해결법이 정말 간단했습니다.\nSolution 그럼 코드를 작성해볼게요.\ntableView.tableFooterView = UIView(frame: .zero) tableView.sectionFooterHeight = 0 직접 UIView 를 생성해 Footer 뷰로 지정해주고 높이를 0 으로 바꿔주었어요. 이유는 알 수 없지만 기본적으로 제공되는 Footer 의 높이를 0 으로 바꾸는 방법은 통하지 않더라고요. 이제 이렇게 세팅하고 Simulator 를 실행해 볼게요.\n오!! 사라졌어요. 처음부터 기본값이 이렇게 세팅되어 있었다면 더 편했겠지만 굳이 그렇게하지 않은 이유가 분명 Apple 에게는 있을거에요. 그럴거에요.\nEntire Code import UIKit class ViewController: UIViewController { // MARK: - Properties let tableView = UITableView(frame: .zero, style: .grouped) // MARK: - Lifecycle override func viewDidLoad() { super.viewDidLoad() configureUI() } // MARK: - UI private func configureUI() { setAttributes() setContraints() } private func setAttributes() { tableView.dataSource = self tableView.delegate = self tableView.tableFooterView = UIView(frame: .zero) tableView.sectionFooterHeight = 0 } private func setContraints() { view.addSubview(tableView) tableView.translatesAutoresizingMaskIntoConstraints = false NSLayoutConstraint.activate([ tableView.topAnchor.constraint(equalTo: view.topAnchor), tableView.leadingAnchor.constraint(equalTo: view.leadingAnchor), tableView.trailingAnchor.constraint(equalTo: view.trailingAnchor), tableView.bottomAnchor.constraint(equalTo: view.bottomAnchor) ]) } } extension ViewController: UITableViewDataSource { func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -\u0026gt; Int { return 1 } func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -\u0026gt; UITableViewCell { return UITableViewCell() } } extension ViewController: UITableViewDelegate { func numberOfSections(in tableView: UITableView) -\u0026gt; Int { return 10 } func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -\u0026gt; UIView? { let view = UIView() view.backgroundColor = .gray return view } func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -\u0026gt; CGFloat { return 10 } } ","permalink":"https://kasroid.github.io/posts/ios/20200905-uikit-deleting-unwanted-spaces-in-grouped-style-uitableview/","summary":"Intro UITableView 를 별 다른 설정없이 인스턴스화해서 사용해보면 Style 기본값이 .plain 으로 설정되어 있어 Header 를 사용하는 경우 스크롤을 하더라도 바로 사라지는 것이 아니라 계속 남아있게 되는데요. 이것을 해결하려면 tableView 의 Style 을 .grouped 로 지정해주면 Header 가 다른 셀들과 같은 방식으로 스크롤되게 됩니다.\n그런데 이렇게 사용하면 문제점이 하나 발생하는데 우리는 Footer 가 필요없고 Header 만 필요한 경우에도 자동적으로 Footer 까지 생성되는 상황이 발생하는거에요. 이것 때문에 골치를 여러번 썩으면서도 공부해서 해결하기보다 바쁘다는 핑계로 여태까지 우회하는 방법으로 해결을 했었거든요.","title":"UIKit - UITableView 를 Grouped Style 로 지정했을 때 생기는 Footer 없에기"},{"content":"Intro CocoaPods - 설치 및 라이브러리 적용하기 포스팅에서 간단하게 CocoaPods 를 설치하고 Library 를 적용하는 법가지 알아보았었는데요. 이번에는 CocoaPods 에서 사용할 수 있는 커맨드들을 같이 한번 공부해보도록 하겠습니다.\nPodfile 생성하기 우리가 CocoaPods 를 설치하는 이유는 외부 라이브러리를 적용해서 사용하기 위해서잖아요? 그렇다면 가장 먼저할 일은 당연히 어떤 라이브러리를 설치하고 싶은지 CocoaPods 에게 알려주는 것입니다. 그래서 CocoaPods 는 그 목록을 Podfile 을 통해서 받게되는데요. 다음은 이 Podfile 을 생성하는 명령어입니다.\npod init 설치를 희망하는 프로젝트 폴더 내에서 위 커맨드를 실행해보면 Podfile 이 생성된 것을 확인할 수 있을거에요.\nLibrary 설치하기 설치는 우리가 이미 한 번 사용해 본 명령어에요. 프로젝트에 설치하고 싶은 Library 목록을 Podfile 에 입력하고 macOS 터미널에서 pod install 을 실행해주면 나머지는 CocoaPods 가 알아서 처리해줍니다.\npod install 여기서 중요하게 알고넘어가야 할 부분이 하나 있습니다. 만약에 우리가 이미 pod intall 을 통해 라이브러리들을 설치했는데 나중에 알고보니 빠뜨린게 있다거나 프로젝트 상황이 바뀌어 추가적으로 라이브러리를 설치해야한다면 어떻게 해야할까요? 그때도 pod instala 하나만 알고 있으면 됩니다.\n프로젝트 폴더에서 Pods 폴더와 Podfile.lock 파일을 삭제하고 Podfile 에 추가적으로 설치하고 싶은 Library 를 작성하고(완전히 새롭게 설치하는 개념이니 기존에 설치했었던 라이브러리 목록도 당연히 있어야 합니다.) pod install 을 실해주면 끝입니다. 그리고 CocoaPods 관련 오류가 발생했을 때도 이 방법으로 재설치를 하면 해결되는 경우도 많으니 꼭 기억해두세요!\nLibrary 버전 업데이트 프로젝트의 진행이 오래되었거나하는 등의 이유로 적용된 Library 의 버전이 구버전이라면 pod update 를 통해 최신 버전으로 업데이트 할 수 있습니다. 그러나 버전이 바뀌게 되면 이전에는 잘 작동했던 코드들이 더 이상 정상적으로 동작하지 않아 손을 많이 봐줘야 할 수도 있다는 점은 꼭 염두해두세요.\npod update 그리고 추가적으로 새로운 Library 를 설치하고자할 때는 이 명령어로는 아무것도 할 수 없습니다. pod update 는 이미 설치되어있는 Library 즉 Podfile.lock 에 기재되어있는 것들에 대한 버전을 관리하는 명령어일 뿐입니다. 새로운 라이브러리 설치는 pod install 을 통해서만 진행할 수 있습니다.\nRepo 업데이트 CocoaPods 에는 모든 라이브러리의 리스트를 관리하는 Repo 라는 저장소가 있습니다. 그리고 Repo 안에는 Spec 이 존재하며 Spec 은 각 라이브러리에 대한 필수정보들을 보관합니다. 그리고 이렇게 Repo 내의 라이브러리 Spec 업데이트를 다음 명령어를 통해 실행할 수 있습니다.\npod repo update 이렇게만해서는 무엇을 업데이트 하는건지 아직 잘 감이 오지 않잖아요? 스펙은 각 라이브러리에 대해 아래와 같은 정보들을 보관하고 있습니다. 이 내용들을 최신 버전으로 만드는 것이 pod repo update 명령어라고 생각해주세요.\n그래서 이걸 언제사용하느냐? 저도 아직 정확히는 모릅니다 ㅎㅎㅎ;;;\n그러니까 일단 지금은 CocoaPods 관련 오류가 발생했을 때 실행해주면 해결되는 경우가 있다 이렇게 알려드릴게요.\n내 시스템에 설치된 CocoaPods 버전 확인하기 협업을 하면서 여러가지 오류를 마주치다보면 협업하는 사람과 내 CocoaPods 의 버전이 달라서 발생하는 오류인 경우도 있습니다. 이럴 때는 서로 같은 버전의 CocoaPods 를 사용하고 있는지 확인해 주세요.\npod --version Library 검색하기 CocoaPods 의 홈페이지에서만 라이브러리의 목록을 확인할 수 있는 것은 아닙니다. 터미널에서도 손쉽게 Library 확인이 가능합니다.\npod search QUERY QUERY 라고 써진 자리에 우리가 검색하고 싶은 Library 의 이름을 입력하면 Terminal 에서 결과를 확인할 수 있습니다.\n이렇게 결과가 표시됩니다. 각 검색결과의 3번째 줄에 우리가 Podfile 의 입력에 필요한 정보가 있고 이외에도 꼭 필요한 정보들만 보여주니 터미널에서 검색하는게 훨씬 더 직관적이고 편리한 느낌이네요.\nCache 확인하기 우리가 설치했던 라이브러리의 캐시를 확인할 수 있는 명령어 입니다. 저도 이 포스팅을 작성하려고 공부하면서 처음 알게된 명령어에요. 그냥 이런게 있다 정도만 알아두고 솔직히 별로 쓸 일은 없지 않을까 그런 생각을 합니다.\npod cache list Cache 청소하기 위에서 확인한 캐시 목록에 있는 데이터를 전부 지우는 명령어입니다. 그래서 이걸 굳이 왜지울까요?? 캐시의 특성상 특별히 오류가 발생하지 않거나 용량을 무지막지하게 잡아먹는 상황이 아니라면 그냥 놔두는게 더 좋을 것 같아요.\npod cache clean --all 이렇게 CocoaPods 에서 제공하는 CLI 커맨드를 공부해보았습니다. 필수로 사용하거나 자주 쓸만한 명령어들도 있었고 거의 사용하지 않을 것 같은 명령어들도 있었던 것 같아요. 이외에도 수많은 명령어들이 있지만 지금 당장 우리한테 필요하지 않기 때문에 나중에 차차 공부할 일이 있다면 이 곳에 업데이트 하도록 하겠습니다.\n","permalink":"https://kasroid.github.io/posts/ios/20200905-cocoapods-basic-commands/","summary":"Intro CocoaPods - 설치 및 라이브러리 적용하기 포스팅에서 간단하게 CocoaPods 를 설치하고 Library 를 적용하는 법가지 알아보았었는데요. 이번에는 CocoaPods 에서 사용할 수 있는 커맨드들을 같이 한번 공부해보도록 하겠습니다.\nPodfile 생성하기 우리가 CocoaPods 를 설치하는 이유는 외부 라이브러리를 적용해서 사용하기 위해서잖아요? 그렇다면 가장 먼저할 일은 당연히 어떤 라이브러리를 설치하고 싶은지 CocoaPods 에게 알려주는 것입니다. 그래서 CocoaPods 는 그 목록을 Podfile 을 통해서 받게되는데요. 다음은 이 Podfile 을 생성하는 명령어입니다.\npod init 설치를 희망하는 프로젝트 폴더 내에서 위 커맨드를 실행해보면 Podfile 이 생성된 것을 확인할 수 있을거에요.","title":"CocoaPods - 명령어 알아보기"},{"content":" 본 포스팅은 이하 버전을 기준으로 작성되었습니다. · Swift 5.2.4 · Firebase 6.29.0\nIntro 이번에는 Google 아이디로 로그인할 수 있도록 구현해볼거에요. Apple 로그인은 Xcode 에서 Native 로 지원이 되지만 Google 로그인은 그렇지 않기 때문에 Firebase 를 사용해야 해서 조금 더 복잡한 편입니다. 그래도 천천히 따라해보시면 문제없을 거에요!\nCocoaPods 설치 만약에 여러분이 CocoaPods 를 설치한 적이 없다면 Xcode 프로젝트에 Firebase 를 연동하기 위해 CocoaPods 가 우선적으로 설치되어 있어야합니다. 설치 방법은 CocoaPods - 설치 및 라이브러리 적용하기 포스팅을 참고해주세요.\nImporting Firebase 기초적인 Firebase 와 Xcode 의 연동방법은 Firebase - Xcode 프로젝트와 연동하기 포스팅을 통해 공부했었습니다. 그래서 이번 포스팅에서는 지난 글과 달라지는 부분에 대해서만 공부해보도록 할게요. Firebase 연동과정에서 Pod 를 설치하라는 메세지가 나오는 부분에까지 진행해주세요.\nPod Libraries 설치하기 Terminal 에서 Xcode 에 Firebase 파일 설치를 위해 터미널에서 내 프로젝트가 있는 폴더 내부로 이동해주세요. 이동을 완료했다면 pod init 을 진행해주세요. 그러면 새롭게 Podfile 이 생성되었을 거에요.\nPodfile 을 열고 아래처럼 입력해주세요. 우리가 입력한 부분은 총 3가지에요.\npod \u0026lsquo;Firebase/Analytics\u0026rsquo; pod \u0026lsquo;Firebase/Auth\u0026rsquo; pod \u0026lsquo;GoogleSignIn\u0026rsquo; 이 중 첫번째 Firebase/Analytics 는 우리가 처음에 프로젝트 설정할 때 Analytics 를 등록했으니까 설치 해주는 것이고 Google 로그인에 필수 항목은 아닙니다. 혹시 체크 해제하고 진행하신 분들은 첫번째 항목은 설치할 필요가 없어요~\n# Uncomment the next line to define a global platform for your project # platform :ios, \u0026#39;9.0\u0026#39; target \u0026#39;SignInWithGoogle_Example\u0026#39; do # Comment the next line if you don\u0026#39;t want to use dynamic frameworks use_frameworks! # Pods for SignInWithGoogle_Example pod \u0026#39;Firebase/Analytics\u0026#39; pod \u0026#39;Firebase/Auth\u0026#39; pod \u0026#39;GoogleSignIn\u0026#39; end Podfile 수정 후 꼭 저장하고 다시 터미널로 돌아가서 pod install 을 진행해 주세요. 인스톨을 마치고 폴더를 열어보면 기존 Xcode 프로젝트 파일과는 조금 다른 흰색 .workspace 파일이 생성되어 있습니다. 앞으로 우리는 기존 파일이 아닌 이 파일에서 코드 작업을 진행할 거에요. 그럼 기존 파일을 종료하고 새로운 파일을 열어볼게요.\n파일을 실행하고 Firebase 홈페이지로 돌아가 Next 를 누르면 다음과 같은 화면을 볼 수 있습니다.\n먼저 AppDelegate 파일에서 Firebase 와 GoogleSignIn 을 import 해주도록 합시다.\nimport Firebase import GoogleSignIn 그 다음에는 기본제공 함수 중 첫번째 내부에 FirebaseApp.configure() 함수를 입력해 주세요.\nfunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -\u0026gt; Bool { // Override point for customization after application launch. FirebaseApp.configure() return true } 마지막으로 ViewController 로 돌아가 다시 한번 Firebase 와 GoogleSignIn 을 import 해줍니다. 이제 몇 가지 설정만 더하면 됩니다 ㅎㅎ\n다시 Firebase 로 돌아가 Next 를 누르면 마지막으로 아래와 같은 화면이 뜰텐데 Xcode 에서 시뮬레이터를 실행하고 잠시 기다리시면 Continue to console 버튼이 활성화 될거에요. 만약에 계속 활성화되지 않으면 Skip this step 버튼으로 그냥 넘어가주세요.\n자 다들 이제 이렇게 생긴 Firebase 프로젝트 내의 메인화면으로 오셨죠?\n여기서 좌측의 Authentication 버튼을 누르고 Sign-in method 탭을 클릭합니다. 리스트에서 Google 을 선택하고 Enabled 로 바꿔주세요. 참고로 상태를 바꾸려면 이메일을 반드시 선택해야 합니다.\nGoogle 로그인 프로세스 구현하기 이제 Firebase 홈페이지에서 세팅은 모두 마쳤습니다. 다음으로는 Xcode 로 다시 돌아와 GoogleService-Info.plist 파일의 REVERSED_CLIENT_ID 의 항목을 복사합니다.\n복사가 되었으면 좌측의 Navigator 에서 프로젝트 파일을 클릭하고 Info 탭으로 들어가보면 하단에 URL Types 가 있습니다. 이 곳을 펼치고 + 버튼을 눌러 URL Schemes 칸에 복사한 REVERSED_CLIENT_ID 값을 붙여넣어 주세요.\n다음으로는 이제 GIDSignInDelegate 를 AppDelegate 로 돌아가 채택해주어야 합니다.\nclass AppDelegate: UIResponder, UIApplicationDelegate, GIDSignInDelegate 그리고 GIDSignInDelegate 의 필수구현 method 인 sign() 도 함께 구현해줍니다. 함수의 내부 코드는 다른 부분부터 먼저 끝내고 마지막에 입력해주도록 할게요.\nfunc sign(_ signIn: GIDSignIn!, didSignInFor user: GIDGoogleUser!, withError error: Error!) { } 이제부터 우리는 GIDSignIn 이라는 인스턴스를 사용할 수 있게되는데 이것은 사용자가 구글 아이디로 로그인할 수 있도록 도와주는 인스턴스입니다.\n다음으로 기본제공 함수인 application:didFinishLaunchingWithOptions: 안에 우리가 조금 전 작성해놓은 FirebaseApp.configure() 코드 아래 다음 내용을 작성합니다. 두번째 줄은 우리가 프로토콜을 채택했으니 당연히 delegate 설정을 해주어야 하는 부분이고, 첫번째 줄은 sign-in method 가 동작하기 위해 반드시 필요한 코드라고하네요. 그냥 외워버리거나 자주 안쓴다면 필요할 때마다 찾아서 쓰는걸로\u0026hellip;\nGIDSignIn.sharedInstance().clientID = FirebaseApp.app()?.options.clientID GIDSignIn.sharedInstance().delegate = self 추가적으로 application:openURL:options: 함수를 구현하고 내부에 handle() method 를 구현합니다. 이 method 는 GIDSignIn 인스턴스의 handleURL method 를 호출하여 인증 프로세스가 끝날 때 애플리케이션이 수신하는 URL을 적절히 처리해준다고 합니다. 인증 프로세스의 결과에 따라 다른 URL 을 받는건지 어쩐건지\u0026hellip; 알 수 없지만 아무튼 해야한다니까 그냥 구현해줍니다.\n@available(iOS 9.0, *) func application(_ app: UIApplication, open url: URL, options: [UIApplication.OpenURLOptionsKey : Any] = [:]) -\u0026gt; Bool { return GIDSignIn.sharedInstance().handle(url) } 위 함수는 대놓고 iOS 9.0 이상에서만 구현이 된다고 써있잖아요? 만약에 거의 쓸 일은 없겠지만 정말 만약에 iOS 8.0 이상부터 지원해야할 일이 있다면 다음 함수도 구현해주세요.\nfunc application(_ application: UIApplication, open url: URL, sourceApplication: String?, annotation: Any) -\u0026gt; Bool { return GIDSignIn.sharedInstance().handle(url) } 그리고 사용자가 앱에서 disconnect 되었을 때 호출되는 함수인 sign:didDisconnectWith 함수도 구현해 줍니다. 우리는 지금 Google 로그인을 구현하는 것이 목적이므로, 일단 함수를 구현만 하고 이곳에는 코드를 따로 작성하지 않겠습니다. 앱이 disconnect 되었을 때 추가적인 action 이 필요하다면 이곳에 작성해주세요.\nfunc sign(_ signIn: GIDSignIn!, didDisconnectWith user: GIDGoogleUser!, withError error: Error!) { // Perform any operations when the user disconnects from app here. } 마지막으로 우리가 초반에 작성해 놓았던 필수구현 함수 sign() 의 내부 코드를 작성해볼게요. 에러가 날 경우 print 와 함께 함수가 종료되도록했고, 성공적으로 로그인 했을 경우에는 credential 이 print 될 수 있도록 작성했습니다. 여러분은 이곳에서 로그인 결과에 따라 원하는 ViewController 로 이동하거나 하는 등의 액션을 추가한다거나 하는 코드를 입력해봐도 좋을 것 같아요 ㅎㅎ\nfunc sign(_ signIn: GIDSignIn!, didSignInFor user: GIDGoogleUser!, withError error: Error?) { if let error = error { print(error) return } guard let authentication = user.authentication else { return } let credential = GoogleAuthProvider.credential(withIDToken: authentication.idToken, accessToken: authentication.accessToken) print(credential.provider) } 이제 거의 다 끝났으니까 조금만 더 힘내서 마무리 해볼게요!!\nGoogle 로그인 버튼 생성하기 드디어 이것으로 AppDelegate 에서 작성할 코드는 모두 끝났고 이제 ViewController 로 넘어가서 나머지 작업과 버튼을 추가해서 실제로 Google 로그인이 동작하는지 확인해보도록 할게요. 거의 다 왔으니까 조금만 더 힘내봅시다!!\n먼저 viewDidLoad() 에 다음 코드를 작성해볼게요. 첫번째 줄의 코드는 GIDSignIn 객체의 프레젠테이션 뷰 컨트롤러를 설정하고(Google 로그인 안내창을 어떤 뷰 컨트롤러에 띄울지 설정), 두번째 줄의 코드는 가능한 경우 자동으로 로그인을 할 수 있도록 도와주는 코드입니다. 두번째 줄의 코드는 자동 로그인이 필요하지 않다면 구현해주지 않아도 무방합니다.\nGIDSignIn.sharedInstance()?.presentingViewController = self GIDSignIn.sharedInstance().signIn() 다음으로 Google 로그인 버튼을 생성하고 View 의 가운데에 위치하도록 배치해 보겠습니다. 당연히 일반 버튼을 사용하면 안되고 GIDSignInButton() 을 상속받아 사용해야 합니다.\nlet googleLoginButton = GIDSignInButton() ViewController 에 적힌 코드는 아래와 같습니다. 우리가 작업을 미리 다른 곳에서 많이 해둬서인지 Controller 에서 구현할 부분은 많지 않네요 ㅎㅎ\nimport UIKit import Firebase import GoogleSignIn class ViewController: UIViewController { let googleLoginButton = GIDSignInButton() override func viewDidLoad() { super.viewDidLoad() configureUI() GIDSignIn.sharedInstance()?.presentingViewController = self } private func configureUI() { view.addSubview(googleLoginButton) googleLoginButton.translatesAutoresizingMaskIntoConstraints = false NSLayoutConstraint.activate([ googleLoginButton.centerXAnchor.constraint(equalTo: view.centerXAnchor), googleLoginButton.centerYAnchor.constraint(equalTo: view.centerYAnchor) ]) } } 이제 실행시켜보면 버튼이 보이고 눌러보면 구글 로그인하는 화면이 보일거에요~ 해냈다!!\nFirebase 에 로그인 데이터 저장하기 하지만 아직 끝이 아니에요. 사용자가 정상적으로 로그인 했을 때 그 정보를 우리가 저장해야하니까요. AppDelegate 로 돌아가 sign:didSignInFor 함수에 Auth.auth().signIn(with: credential) method 를 작성해야 합니다.\nAuth 함수에서 else 쪽으로 빠지면 Firebase 에 로그인 데이터가 저장되게 됩니다. 가져올 수 있는 데이터는 사용자의 email 주소가 전부인 것 같네요.\nfunc sign(_ signIn: GIDSignIn!, didSignInFor user: GIDGoogleUser!, withError error: Error?) { // ... if let error = error { print(error) return } guard let authentication = user.authentication else { return } let credential = GoogleAuthProvider.credential(withIDToken: authentication.idToken, accessToken: authentication.accessToken) Auth.auth().signIn(with: credential) { (authResult, error) in if let error = error { print(error.localizedDescription) } else { print(\u0026#34;Login Successful\u0026#34;) } } } 마지막으로 로그아웃을 도와주는 method 입니다. 로그인을 했으니까 당연히 로그아웃이 있어야하잖아요? ㅎㅎ 근데 오늘은 구현하지 않을거에요. 그냥 버튼하나 만들어서 @objc method 로 넘겨주면 잘 작동될겁니다!\nlet firebaseAuth = Auth.auth() do { try firebaseAuth.signOut() } catch let signOutError as NSError { print (\u0026#34;Error signing out: %@\u0026#34;, signOutError) } 이번 포스팅은 내용이 정말 많이 길어졌네요. 여기까지 따라오신 분들 정말 수고많으셨습니다!! 그럼 이만~\n","permalink":"https://kasroid.github.io/posts/ios/20200904-sign-in-with-google-uikit/","summary":"본 포스팅은 이하 버전을 기준으로 작성되었습니다. · Swift 5.2.4 · Firebase 6.29.0\nIntro 이번에는 Google 아이디로 로그인할 수 있도록 구현해볼거에요. Apple 로그인은 Xcode 에서 Native 로 지원이 되지만 Google 로그인은 그렇지 않기 때문에 Firebase 를 사용해야 해서 조금 더 복잡한 편입니다. 그래도 천천히 따라해보시면 문제없을 거에요!\nCocoaPods 설치 만약에 여러분이 CocoaPods 를 설치한 적이 없다면 Xcode 프로젝트에 Firebase 를 연동하기 위해 CocoaPods 가 우선적으로 설치되어 있어야합니다. 설치 방법은 CocoaPods - 설치 및 라이브러리 적용하기 포스팅을 참고해주세요.","title":"Firebase - Sign in with Google 구현하기 with UIKit"},{"content":"Intro 주력 Text Editor 로 Vim 을 사용하면서 매일 마주치는 문제점 하나가 바로 Insert Mode 에서 한글을 작성하다 Normal Mode 로 돌아오면 다시 영문으로 전환해주지 않는 이상 어떤 커맨드도 먹히지 않는다는 것 이었습니다. 제 경우에는 블로그 글을 Vim 에서 작성하고 있고, 글을 쓸 때 한글의 비중이 압도적으로 높다보니 Insert Mode 에서 Normal Mode 로 돌아올 때마다 항상 언어상태를 확인해줘야하고 이것은 Work Flow 에 치명적인 영향을 줘서 생산성을 떨어뜨리는 결과를 낳게되더라고요.\n당연히 Vim 에서 한글을 작성하시는 많은 분들이 비슷한 고충을 겪고 있고, 이에 대한 해결법이 많이 나와있는 상황이기는 합니다. 그 중 대표적인 해결법이 Hammerspoon 이라는 Automation 프로그램을 이용하는 방법인데요. 이것에 관한 글은 다른 여러 블로그에 자세히 나와있기도 하고 저는 제가 이미 사용하고 있는 Keyboard Maestro 라는 Automation 프로그램이 있기 때문에 혹시 Hammerspoon 으로 해결하고 싶은 분들은 다른 블로그 글을 찾아보시기 바랍니다.\n이번 포스팅에서는 Keyboard Maestro 로 해결해보도록 하겠습니다. 다만 조금 가격이 나가는 유료 프로그램이므로 글을 읽기 전 구매의사를 반드시 결정하시기 바랍니다. 정말 좋은 프로그램이니까 저는 추천하겠습니다 ㅎ\nKeyboard Maestro 소개 Keyboard Maestro 는 일종의 Automation 프로그램 입니다. 상당히 잘 만들어진 프로그램으로 여러가지 귀찮은 일들을 자동화할 수 있지만 여느 Automation 프로그램들만큼 난이도가 조금 있어 저는 기본적인 매크로들만 사용하고 있습니다. 그래도 돈 값은 충분히 하고 있는 것 같아요 ㅎㅎ 오늘 Terminal 에서 작동하는 자동 영문전환 스크립트를 작성하고나면 조금 더 돈값을 하게되겠군요 ㅋㅋㅋ 그럼 바로 세팅해볼게요.\nESC to 영문전환 Keyboard Maestro 는 이렇게 생겼습니다. + 버튼을 눌러 폴더를 하나 추가하고 Terminal 에서는 ESC 키가 영문전환을 함께 수행하도록 세팅해볼게요. 이런 방식으로 세팅을 하면 특정 프로그램에서만 Automation 을 작동하게 할 수 있습니다.\n다음에는 + 버튼을 눌러 새로운 Macro 를 추가합니다. 저는 매크로 이름을 ESC to English 라고 지었어요.\nMacro 가 Trigger 될 조건을 Hot Key Trigger 로 설정하고 ESC 를 Trigger Key 로 지정합니다.\n이제 Action 을 만들어주면 되는데요. Set Keyboard Layout 을 찾아 추가합니다.\n다 그런 것인지는 모르겠지만 저는 기본 값이 한글로 변경되는 것으로 되어있어 영문으로 설정되도록 바꾸었고, 추가로 Type a Key Stroke 를 하나 더 추가했습니다. 추가 Key Stroke 를 설정해주지 않으면 ESC 키가 영문전환만 하게되고 본연의 역할을 잊게됩니다. 그러니까 꼭 추가해야해요.\n이렇게 설정이 모두 끝났습니다. Keyboard Maestro 를 사용하니 정말 간단하게 해결되었어요 ㅎㅎㅎ Keyboard Maestro 두번 쓰세요\n이제 당연히 잘되겠지하고 자신만만하게 Vim 에서 테스트를 해보았으나 전혀 작동을 하지 않았습니다. 작동을 하지않을 이유가 없는데 왜 이럴까하면서 10분 정도를 헤맸을까 프로그램 설정이 잘못되었다는 것을 알았는데 제가 사용하는 프로그램인 iTerm2 가 아닌 Terminal 로 설정해 놓았더라고요. iTerm2 로 변경하니 예상했던대로 잘 작동되었습니다. 여러분은 이런 실수하지 마세요~\n","permalink":"https://kasroid.github.io/posts/developertools/20200904-vim-switching-language-inputs/","summary":"Intro 주력 Text Editor 로 Vim 을 사용하면서 매일 마주치는 문제점 하나가 바로 Insert Mode 에서 한글을 작성하다 Normal Mode 로 돌아오면 다시 영문으로 전환해주지 않는 이상 어떤 커맨드도 먹히지 않는다는 것 이었습니다. 제 경우에는 블로그 글을 Vim 에서 작성하고 있고, 글을 쓸 때 한글의 비중이 압도적으로 높다보니 Insert Mode 에서 Normal Mode 로 돌아올 때마다 항상 언어상태를 확인해줘야하고 이것은 Work Flow 에 치명적인 영향을 줘서 생산성을 떨어뜨리는 결과를 낳게되더라고요.","title":"Vim - Normal Mode 에서 자동으로 영문전환하기"},{"content":"Intro 우리가 블로그를 작성하는 이유가 여러가지 있겠지만 그 중에 하나는 내가 아는 정보들을 다른 사람들과 공유하고자 하는 목적이 있잖아요. 그래서 오늘은 Hugo 로 블로그를 관리할 때 반드시 설정해주어야 할 부분 중 하나인 SEO(Search Engine Optimization) 라 불리는 검색 엔진 최적화에 대해 함께 공부해보도록 하겠습니다. Tistory 나 Naver 같은 블로그를 사용하면 이런 처리들을 우리가 직접할 필요가 없어서 생소할 수도 있는 부분이에요. 하지만 이 곳들도 우리가 직접하지 않을 뿐 뒤에서는 같은 처리를 해주고 있답니다.\n그런데 Hugo 블로그는 모든 서비스의 주체자가 우리잖아요? 이게 개인의 취향대로 모든 것을 커스터마이징 할 수 있다는 장점이 있기도 하지만 그만큼 기업에서 서비스하는 블로그를 사용할 때보다 신경써야할 것이 더 많다는 뜻이기도 합니다. 우리가 블로그 페이지들을 생성하고 그것을 웹페이지로 만든다고해도 따로 검색엔진 서비스에 블로그 주소를 등록하지 않으면 아무리 검색해도 우리 블로그를 찾을 수가 없습니다.\n이번 포스팅은 총 3회 분으로 연재될 예정이며\nGoogle Search Console Naver Search Advisor 다음검색 등록 순으로 포스팅 될 계획입니다.\nGoogle SEO 가장 먼저 Google 에 블로그 주소를 등록하는 절차를 진행해보도록 할게요. 구글에 주소를 등록하기 위해서는 Google Analytics 와 Google Search Console 두 곳에서 작업이 필요합니다.\nGoogle Analytics 등록하기 Google Analytics 에 접속해 볼게요. 일단 등록을 하기 전에 Analytics 가 어떤 역할을 하는지 간단하게 알아봅시다. 우리가 Analytics 에 등록하는 이유는 단순히 검색에 노출되기 위해서 그런 것이 아니에요. Analytics 에 등록함으로써 다음과 같은 유용한 정보들을 확인할 수 있고, 이에 따라 더 전략적으로 블로그를 운영할 수 있게 됩니다.\n블로그 방문자 수 블로그 방문자들의 연령대와 성별 블로그 방문 시 사용한 디바이스 블로그를 찾아 들어오게된 경로 내 블로그에서 인기있는 페이지 기본적으로 파악할 수 있는 정보들은 이정도가 있고 당연히 이외에도 훨씬 많은 정보를 확인할 수가 있습니다. 이제 등록을 하기 위해 admin 메뉴를 클릭합니다. 저는 이미 Tistory 블로그를 운영하고 있고 이 블로그가 Google Analytics 에 등록되어 있어 처음 시작하는 분들과는 보이는 화면이 조금 다를 수 있습니다. 그래도 전체적인 흐름은 동일하니까 잘 따라와주세요.\n다음으로 Create Property 버튼을 누르고 내 블로그 정보를 기입하여 Property 를 생성합니다. 생성이 되면 Tracking ID(UA-123456789-1 형식) 을 확인할 수 있고 이 ID 를 우리 블로그에 입력해야 합니다.\n이제 Hugo 구성 파일 중 config.toml 파일을 열어 googleAnalytics 변수를 생성하고 ID 를 입력합니다.\ngoogleAnalytics: UA-123456789-1 위 ID 는 예시이므로 작동하지 않고 여러분이 발급받은 Tracking ID 를 입력해주세요. 입력이 완료되면 당연히 블로그를 재발행 해주어야 합니다. 작동 확인 방법으로는 Google Analytics 는 실시간으로 접속자를 감지하므로 이후에 내가 블로그에 접속하더라도 접속자 숫자가 올라가는 모습을 확인할 수 있습니다. 쩌는데??\nGoogle Search Console 설정하기 이제 Google 검색에 실제로 노출될 수 있도록 등록하는 작업을 진행해 보겠습니다. Google Search Console 에 접속하고 시작하기 버튼을 눌러주세요.\n이제 아래와 같은 화면이 보일텐데요. 이곳에서 Add property 버튼을 눌러주세요.\n다음으로 나타나는 화면에서는 URL Prefix 를 선택하고 내 블로그 주소를 입력합니다. 이제 html 파일을 다운로드 받아 Hugo 구성파일 중 public 폴더에 넣어준 뒤 블로그를 재발행합니다. 수분 내로 소유권 확인이 가능합니다.\n마지막으로 sitemap.xml 파일을 제출해주면 끝입니다.\n좌측 메뉴에서 Sitemaps 를 선택하면 나타나는 주소창에 sitemap.xml 을 입력해주세요. 내 Hugo 디렉토리의 public 폴더 안에 기본적으로 들어있는 파일이므로 문제 없이 등록이 됩니다. 다만 이게 블로그 테마에 따라 없는 경우가 있을 수도 있다고 하는데 없을 경우에는 직접 작성을 해줘야 한다고 하네요. 저는 있었으므로 직접 작성하는 방법은 패스하도록 할게요.\n","permalink":"https://kasroid.github.io/posts/developertools/20200903-hugo-register-in-google-search-console/","summary":"Intro 우리가 블로그를 작성하는 이유가 여러가지 있겠지만 그 중에 하나는 내가 아는 정보들을 다른 사람들과 공유하고자 하는 목적이 있잖아요. 그래서 오늘은 Hugo 로 블로그를 관리할 때 반드시 설정해주어야 할 부분 중 하나인 SEO(Search Engine Optimization) 라 불리는 검색 엔진 최적화에 대해 함께 공부해보도록 하겠습니다. Tistory 나 Naver 같은 블로그를 사용하면 이런 처리들을 우리가 직접할 필요가 없어서 생소할 수도 있는 부분이에요. 하지만 이 곳들도 우리가 직접하지 않을 뿐 뒤에서는 같은 처리를 해주고 있답니다.","title":"Hugo - 블로그 Google Search Console 에 등록하기"},{"content":"또 새로운 Vim Plugin 을 소개해드리려고 왔어요 ㅎㅎㅎ 요즘 Vim 의 매력에 푹 빠져서 열심히 연습 중이고 기본적인 사용법들도 점점 손에 익어가니까 키보드를 무릎 위에 올려놓고 글을 쓰는 맛이 있습니다. 그래서 오늘 소개할 Plugin 은 Vim-Airline 이라는 플러그인이에요. Vim 아래쪽에 Status Bar 를 좀 더 보기 좋게 만들어주고 윗쪽에 Tab Bar 와 비슷한 Buffer 라는 것을 만들어서 우리가 이번 작업에서 열어본 파일을 기억하여 파일 간의 이동을 쉽게할 수 있도록 도와줍니다. 설치해서 손해볼게 없는 Plugin 인 것 같으니까 바로 설치해보도록 할게요.\n![Vim-Airline\nVim-Airline 설치하기 먼저 Vim-Airline Github 에 들어가 README 파일을 읽어보고 Vundle 로 Plugin 을 설치하도록 하겠습니다. Vundle 을 사용한 설치법은 Vim: Vundle 및 Markdown Plugin 설치하기 포스팅을 참고해주세요.\n첫번째 Plugin 은 Airline 그 자체를 설치하는 것이고, 두번째 Plugin 은 이것의 테마들을 설치하는거에요. 나중에 테마가 바꾸고 싶을 수 있으니 오늘 둘 다 설치를 해놓긴 하겠지만 테마를 바꾸는 방법은 다음에 알아보도록 하겠습니다.\nPlugin \u0026#39;vim-airline/vim-airline\u0026#39; Plugin \u0026#39;vim-airline/vim-airline-themes\u0026#39; 설치가 끝났다면 .vimrc 파일 아래쪽에 다음 코드도 읿력해주세요. 기본적으로 위쪽 Tab Bar 기능은 비활성화 상태이기 때문에 이것을 활성화 해주는 코드입니다. 혹시 나는 아래쪽 Status Bar 만 사용하는게 더 깔끔하고 좋다하면 이 코드는 그냥 스킵해주세요.\nlet g:airline#extensions#tabline#enabled = 1 이제 Vim 을 실행해서 어떻게 바뀌었을지 확인해보도록 하겠습니다.\n오!! 뭔가 확실히 화면이 더 풍성해졌어요. Vim 의 현재 모드와 Git, 파일명 등등 많은 정보를 아랫쪽 Status Bar 에서 확인할 수가 있네요. 그리고 윗쪽에도 Tab Bar 가 추가된 모습을 볼 수 있죠? 이제 이전에 우리가 함께 설치했던 NERDTree 를 사용해 새로운 파일을 하나 열어보겠습니다.\n이렇게 어떤 파일을 열고나면 Tab Bar 에 그 기록이 남게되고 : 를 눌러 커맨드 모드에 진입해서 bn 과 bp 커맨드를 사용해 파일간의 이동이 가능합니다. 이제 정말 외부적으로는 VSCode 에서 제가 자주 사용하던 기능들이 Vim 으로 들어왔습니다. 이렇게 가볍운 에디터가 Plugin 을 통해서 이 정도까지 강력한 기능들을 탑재할 수 있다는 것도 정말 놀랍네요.\n그럼 다음에 또 봴게요!!\n","permalink":"https://kasroid.github.io/posts/developertools/20200902-vim-plugin-vim-airline/","summary":"또 새로운 Vim Plugin 을 소개해드리려고 왔어요 ㅎㅎㅎ 요즘 Vim 의 매력에 푹 빠져서 열심히 연습 중이고 기본적인 사용법들도 점점 손에 익어가니까 키보드를 무릎 위에 올려놓고 글을 쓰는 맛이 있습니다. 그래서 오늘 소개할 Plugin 은 Vim-Airline 이라는 플러그인이에요. Vim 아래쪽에 Status Bar 를 좀 더 보기 좋게 만들어주고 윗쪽에 Tab Bar 와 비슷한 Buffer 라는 것을 만들어서 우리가 이번 작업에서 열어본 파일을 기억하여 파일 간의 이동을 쉽게할 수 있도록 도와줍니다. 설치해서 손해볼게 없는 Plugin 인 것 같으니까 바로 설치해보도록 할게요.","title":"Vim Plugin - Vim Airline"},{"content":"Vim 을 쓰다보니 또 VSCode 보다 불편한 점을 발견할 수 있었는데요. 바로 VSCode 에서 애용하던 File Navigattion System 이 없다는 것이었습니다. 바로 이미지 좌측에 보이는 저것이에요.\n자주 여러 파일을 이동해야하는 경우에 Navigation System 이 없다는 이유만으로 자꾸 다시 VSCode 로 손이 가게 되더라고요. 그래서 Vim 에서는 해결방법이 없을지 찾아보다가 알게된 것이 바로 NERDTree 입니다. 바로 Vim 만의 파일탐색기 같은 것이에요. 제가 메인 텍스트 에디터로 Vim 을 사용하려는 이유 중 한가지가 작업을 할 때 Terminal 에서 키보드만으로 거의 모든 작업을 진행할 수 있다는 것인데요. VSCode 를 사용하면 또 마우스를 사용해야 하다보면 여러가지 불편한 상황이 만들어졌습니다. 진정한 개발자는 마우스가 필요없는 것 아시죠?\n아무튼 그래서 바로 NERDTree 를 설치하기로 했어요.\nNERDTree 설치하기 NERDTree 도 결국 일종의 Vim Plugin 이니까 Vundle 을 사용해서 간단하게 설치를 진행해보도록 하겠습니다. Vundle 설치가 익숙하지 않다면 Vim: Vundle 및 Markdown Plugin 설치하기 포스팅을 참고해주세요.\n먼저 NERDTree 설치를 위해서 NERDTree Github 에 들어갑니다. 우리는 Vundle 로 설치를 하기로 했으니까 README 에서 Vundle 로 설치하는 방법을 찾아볼게요.\nPlugin \u0026#39;preservim/nerdtree\u0026#39; Vundle 도 계속 쓰다보니 Homebrew 만큼 편하고 좋은 툴인 것 같아요 ㅎㅎ 이렇게 설치도 끝났고 본격적으로 NERDTree 에 대해 함께 공부해보도록 할게요.\nNERDTree 사용법 익히기 NERDTree 를 사용하기 위해서는 기본적으로 Vim 을 실행해야 합니다. Vim Plugin 이니까 당연하지 Vim 을 실행했다면 : 을 눌러 커맨드 모드로 진입하고 NERDTree 를 입력해볼게요. 대소문자를 정확히 입력해야 합니다.\n오!! VSCode 에서 봤던 파일탐색기와 거의 비슷한게 생겼어요 ㅎㅎㅎ 파일 탐색은 화살표 키 또는 hjkl 로 가능합니다. 폴더나 파일을 열기 위해서는 o 키를 누르면 되고요. 파일을 열게되면 자동으로 커서가 파일로 옮겨지고 더 이상 NERDTree 에서 파일이동을 할 수가 없을텐데요. 이 때는 Control + w + w 를 눌러 창 간의 포커싱 이동이 가능합니다. 다시 돌아와서 q 를 눌러 창을 닫을 수도 있습니다. 이외에도 ? 를 눌러 Bookmark 등 더 다양한 사용법을 확인해 볼 수 있습니다.\n그리고 파일명을 바꾸거나 선택되어 있는 파일을 Finder 에서 확인하는 등의 다양한 옵션에 m 을 눌러서 접근할 수 있습니다. 이 중 원하는 옵션을 선택하거나 esc 키를 눌러서 종료해 주세요.\n이 정도면 VSCode 의 파일탐색기를 어느정도 대체할 수 있을 것 같아요. 그럼 마지막으로 NERDTree 사용 시 쓸만한 단축키들을 정리하고 프스팅 마치도록 하겠습니다.\n유용한 단축키 모음 NERDTree Shortcuts Title Shortcuts 파일 및 폴더 열기 o 하위 폴더까지 전부 열기 O 미리보기 형식으로 열기 p 새로운 탭에서 파일 열기 t 가로 Split 으로 파일 열기 i 세로 Split 으로 파일 열기 s 메뉴 열기 m NERDTree 줌, 줌아웃 하기 A NERDTree 종료하기 q Control Windows Title Shortcuts 창 순환하기 ctrl + w + w 왼쪽 창으로 이동하기 ctrl + w + h 오른쪽 창으로 이동하기 ctrl + w + l 윗쪽 창으로 이동하기 ctrl + w + k 아랫쪽 창으로 이동하기 ctrl + w + j 이전 창으로 이동하기 ctrl + w + p 창 종료하기 ctrl + w + q ","permalink":"https://kasroid.github.io/posts/developertools/20200902-vim-plugin-nerdtree/","summary":"Vim 을 쓰다보니 또 VSCode 보다 불편한 점을 발견할 수 있었는데요. 바로 VSCode 에서 애용하던 File Navigattion System 이 없다는 것이었습니다. 바로 이미지 좌측에 보이는 저것이에요.\n자주 여러 파일을 이동해야하는 경우에 Navigation System 이 없다는 이유만으로 자꾸 다시 VSCode 로 손이 가게 되더라고요. 그래서 Vim 에서는 해결방법이 없을지 찾아보다가 알게된 것이 바로 NERDTree 입니다. 바로 Vim 만의 파일탐색기 같은 것이에요. 제가 메인 텍스트 에디터로 Vim 을 사용하려는 이유 중 한가지가 작업을 할 때 Terminal 에서 키보드만으로 거의 모든 작업을 진행할 수 있다는 것인데요.","title":"Vim Plugin - NERDTree"},{"content":"오늘은 Vim 을 사용할 때 기본적으로 설정해두고 사용하면 좋을만한 간단면서도 유용한 설정들에 대해 공부해보도록 하겠습니다.\nVim 의 기본 설정은 macOS 기준 Home Directory 에 위치한 .vimrc 에서 설정할 수가 있습니다. 먼저 이 파일을 확인해보도록 할게요. cd 커맨드로 Home 으로 이동한 뒤에 이 파일이 존재하는지 확인해주세요. 혹시라도 이 파일이 존재하지 않는다면 그냥 만들어 주면 됩니다 ㅎㅎ 저는 처음에 이 파일이 없어서 직접 만들었어요.\n이제 기본적으로 추가해 놓으면 좋을만한 설정들을 추가해보록 할게요.\nSyntax 설정하기 저만 그런지 모르겠지만 제 경우에는 Vim 에서 새로운 파일을 열 때마다 Syntax 의 기본설정이 off 로 되어있습니다. 저는 보통 Syntax 를 활성화 시켜놓고 사용하는 것을 선호해서 매번 :syntax on 커맨드를 통해 활성화 시켜줘야 했는데요. .vimrc 파일에서 설정을 바꿔주면 기본세팅을 Syntax On 으로 변경할 수 있습니다. 바로 입력해볼게요.\nsyntax on 네 이게 전부입니다. 쉽죠? ㅎㅎ 이제 파일을 저장하고 나서부터 새롭게 여는 파일들은 Syntax 설정이 활성화된채로 열리게 됩니다.\nNumbering 설정하기 보통 우리가 사용하는 IDE 프로그램들은 화면 좌측에 넘버링을 제공해서 우리가 총 몇 줄을 작성했는지 혹은 몇 번째 줄에서 작업하고 있는지 직관적으로 알 수 있게 되어있잖아요? Vim 에서도 당연히 지원하는 기능이며 간단하게 설정가능합니다. 그리고 참고로 현재 작성하는 코드들은 Vim 내의 Command mode 에서도 1회성으로 동일하게 사용할 수 있습니다.\nset number 코드를 입력하고 저장하면 이제 화면 좌측에서 넘버링을 확인할 수 있는데요. 이렇게 사용하는 것도 이전에는 확인할 수 없었던 넘버링을 확인할 수 있다는 점에서 충분히 좋긴하지만 Vim 을 사용하다보면 현재 줄을 기준으로 위 아래 특정 줄 수만큼 이동해야할 필요가 있는 경우가 많은데요. 내 커서가 있는 곳을 기준으로 위 아래로 각각 넘버링을 보여주는 기능도 지원합니다. 이렇게 글로는 이해가 조금 어렵지만 아래 스크린샷을 보면 한번에 무슨 뜻인지 알 수 있을거에요.\n어떤가요? Vim 을 쓸 때는 정말 유용할 것 같죠? 그럼 바로 설정해주도록 할게요.\nset number relativenumber 이제 저장하고 새로운 파일을 열어 커서를 움직여보면 좌측에 표시되는 숫자가 이전과는 다르게 유동적으로 변하게 되는 것을 확인할 수 있습니다.\n오늘 포스팅은 평소보다 조금 짧은 느낌이지만 앞으로 꾸준히 Vim 을 사용하면서 발견하는 유용한 설정을 이곳에 지속적으로 기록하고 업데이트할 계획입니다.\n","permalink":"https://kasroid.github.io/posts/developertools/20200831-vim-bacis-configurations/","summary":"오늘은 Vim 을 사용할 때 기본적으로 설정해두고 사용하면 좋을만한 간단면서도 유용한 설정들에 대해 공부해보도록 하겠습니다.\nVim 의 기본 설정은 macOS 기준 Home Directory 에 위치한 .vimrc 에서 설정할 수가 있습니다. 먼저 이 파일을 확인해보도록 할게요. cd 커맨드로 Home 으로 이동한 뒤에 이 파일이 존재하는지 확인해주세요. 혹시라도 이 파일이 존재하지 않는다면 그냥 만들어 주면 됩니다 ㅎㅎ 저는 처음에 이 파일이 없어서 직접 만들었어요.\n이제 기본적으로 추가해 놓으면 좋을만한 설정들을 추가해보록 할게요.","title":"Vim - 여러가지 유용한 설정 적용하기"},{"content":"이번에는 Vim 에서 외부 테마를 다운로드 받아 적용하고 Syntax Highlighting 색상을 좀 더 이쁘게 변경해보도록 하겠습니다. 그래도 Terminal 을 통해 글을 쓰는데 최소한 어느정도는 이뻐야 글 쓸 맛이 더 나겠죠?? ㅋㅋㅋ 그런데 지금 제가 사용하는 Vim 의 상태는\u0026hellip;\n이 모양입니다. 한 숨이 나옵니다\u0026hellip; 원색을 너무 많이 사용해서 그런건지 오히려 눈에 방해가 되는 그런 느낌도 들고요. 난 이제 그만 여기서 탈출해야겠어\n그럼 본격적으로 설치해볼까요~\n테마 고르기 먼저 구글에서 Vim ColorScheme 을 검색해 여러분 스타일에 맞는 테마를 찾아보세요. 참고로 저는 One Half Dark 를 골랐어요. 오리지널 색상과 비교하면 훨씬 보기 편한 색인 것 같아요 ㅎㅎㅎ\nColorscheme 설치는 Vundle 을 통한 Plugin 형식으로 설치를 할거에요. 혹시 Vundle 설치부터 진행해야 한다면 이전에 자세히 설명해놓은 Vim: Vundle 및 Markdown Plugin 설치하기 포스트를 참고해주세요.\nPlugin \u0026#39;sonph/onehalf\u0026#39;, {\u0026#39;rtp\u0026#39;: \u0026#39;vim/\u0026#39;} Plugin 설치를 마쳤으면 .vimrc 파일에 추가적인 설정 코드를 입력합니다. 설치한 Plugin 을 colorscheme 으로 사용하겠다는 코드에요.\ncolorscheme onehalfdark let g:airline_theme = \u0026#39;onehalfdark\u0026#39; 혹시 저와 같은 Colorscheme 을 설치하고 있다면 onehalfdark 대신 onehalflight 를 입력하는 것 만으로 밝은 테마를 사용할 수도 있습니다.\n오~ 적용하고 나니 훨씬 깔끔해지고 눈에도 더 잘들어오는 느낌이에요.\n이전보다는 훨씬 마음에 들긴하지만 회색으로 표현되는 글자가 배경화면이랑 비슷해서 눈에 잘 안들어오는 것 같아 추가로 배경색을 조금 더 어둡게하고 폰트는 밝게하고 싶어지네요. 당연히 어떻게해야하는지 몰라서 또 이것저것 찾아보며 공부했습니다 ㅎㅎ\n그리고 그냥 느낌적으로 코드를 작성할 때 Colorscheme 이 먼저 적용되고 이후에 다시 한번 색이 덮어씌워져야 할 것 같아 Colorscheme 보다 아래쪽에 코드를 작성했어요.\n그럼 아래 코드를 .vimrc 파일에 입력해볼게요. Normal 은 기본 배경을 LineNr 은 좌에 넘버링 된 곳의 배경을 바꾼다는 뜻입니다.\nhighlight Normal ctermfg = white ctermbg = NONE highligh LineNr ctermbg = NONE 오!! 만족스러워졌어요. 처음 상태와 비교해보면 정말 다른 프로그램이라고 생각이 들 정도로 드라마틱하게 달라진 느낌에요 ㅎㅎㅎ 이왕 Vim 을 자주 사용할거라면 이렇게 이쁘게 세팅해놓고 사용하는게 가독성 측면에서나 여러모로 더 좋잖아요??\n오늘도 이렇게 끝까지 읽어주셔서 감사합니다. 이쁜 Colorscheme 을 즐기면서 더 열심히 공부해보아요~\n","permalink":"https://kasroid.github.io/posts/developertools/20200830-vim-appying-colorscheme-changing-backgroudn-colors/","summary":"이번에는 Vim 에서 외부 테마를 다운로드 받아 적용하고 Syntax Highlighting 색상을 좀 더 이쁘게 변경해보도록 하겠습니다. 그래도 Terminal 을 통해 글을 쓰는데 최소한 어느정도는 이뻐야 글 쓸 맛이 더 나겠죠?? ㅋㅋㅋ 그런데 지금 제가 사용하는 Vim 의 상태는\u0026hellip;\n이 모양입니다. 한 숨이 나옵니다\u0026hellip; 원색을 너무 많이 사용해서 그런건지 오히려 눈에 방해가 되는 그런 느낌도 들고요. 난 이제 그만 여기서 탈출해야겠어\n그럼 본격적으로 설치해볼까요~\n테마 고르기 먼저 구글에서 Vim ColorScheme 을 검색해 여러분 스타일에 맞는 테마를 찾아보세요.","title":"Vim - ColorScheme 적용 및 직접 색 변경하기"},{"content":"제가 Tistory 로 블로그를 시작했지만 Hugo 로 넘어오게된 이유가 몇 가지 있는데 그 중 가장 큰 비중을 차지하는 두가지가 하나는 Tistory 가 Markdown 을 제대로 지원하지 않고, 코드블럭 처리를 고려하면 글을 Tistory 전용 에디터에서 쓰는 것이 반 강제되는 것이었는데요. Tistory 에디터로 글을 쓰다보면 텍스트에 기본적인 강조 처리하는 것들도 전부 마우스로 처리해야하는데 매번 키보드에서 손이 움직이는게 여간 성가신 것이 아니었거든요. 그래서 포스트를 작성하는 와중에 이 모든걸 Terminal 에서 처리할 수 있으면 어떨까 하는 생각을 종종하게 되었고 결국 Hugo 로 블로그를 관리하는 것으로 결정했습니다.\n그런데 막상 이전을 하고 포스트를 작성하다보니 또다른 문제를 직면하게 되었는데 Termnial 에서 글을 작성할 때 에디터로 사용했던 Vim 은 Markdown Highlighting 을 지원하지 않아 글이 조금만 길어져도 가독성이 많이 떨어졌습니다. 블로그를 운영하면서 동시에 Vim 사용까지 익숙해지고자하는 욕심이 있었는데 Markdown Highlighting 미지원과 실시간으로 결과물을 확인할 수 있는 Preview 기능이 없다는 단점을 극복하지 못하고 결국 최근 포스트들은 전부 VSCode 로 작성하는 상태가 되어버렸죠 ㅎㅎ\n물론 VSCode 정도면 정말 좋은 에디터라 불만은 없었지만 그래도 Terminal 에서 Vim 으로 글을 쓰는게 더 개발자스럽고 간지나잖아요? ㅋㅋㅋㅋ 그래서 오늘은 Vim 에 Plugin 을 설치해서 Markdown Highlighting 과 Preview 를 실시간으로 확인할 수 있도록 공부해보겠습니다.\nVundle 설치하기 Vim 에 Plugin 을 설치하기 위해서는 Plugin 을 쉽게 설치할 수 있도록 도와주는 Vundle 이라는 Tool 이 있습니다. Vundle Github Page 에 접속해 가이드대로 차근차근 설치를 진행해볼게요.\nInstallation 쪽을 확인해보면 아래 커맨드로 Repository 를 Clone 하라고 되어있네요. 시키는대로 합니다 ㅎㅎ\ngit clone https://github.com/VundleVim/Vundle.vim.git ~/.vim/bundle/Vundle.vim 이 다음으로는 .vimrc 파일에 설정 정보를 복사해서 넣어주어야 하는데요. 이 파일은 Vim 의 설정을 관리하는 파일이라고 생각하면 됩니다. 보통 이 파일이 macOS 기준으로 Home 디렉토리에 있어야한다고 하는데 왜인지 저는 없었습니다. 그래서 그냥 새롭게 만들어주기로 했어요. 설마 꼬이는건 아니겠지??\n이렇게 새로운 파일을 생성하고 다음 설정값을 복사해 입력합니다.\nset nocompatible \u0026#34; be iMproved, required filetype off \u0026#34; required \u0026#34; set the runtime path to include Vundle and initialize set rtp+=~/.vim/bundle/Vundle.vim call vundle#begin() \u0026#34; alternatively, pass a path where Vundle should install plugins \u0026#34;call vundle#begin(\u0026#39;~/some/path/here\u0026#39;) \u0026#34; let Vundle manage Vundle, required Plugin \u0026#39;VundleVim/Vundle.vim\u0026#39; \u0026#34; The following are examples of different formats supported. \u0026#34; Keep Plugin commands between vundle#begin/end. \u0026#34; plugin on GitHub repo Plugin \u0026#39;tpope/vim-fugitive\u0026#39; \u0026#34; plugin from http://vim-scripts.org/vim/scripts.html \u0026#34; Plugin \u0026#39;L9\u0026#39; \u0026#34; Git plugin not hosted on GitHub \u0026#34; git repos on your local machine (i.e. when working on your own plugin) Plugin \u0026#39;file:///home/gmarik/path/to/plugin\u0026#39; \u0026#34; The sparkup vim script is in a subdirectory of this repo called vim. \u0026#34; Pass the path to set the runtimepath properly. Plugin \u0026#39;rstacruz/sparkup\u0026#39;, {\u0026#39;rtp\u0026#39;: \u0026#39;vim/\u0026#39;} \u0026#34; Install L9 and avoid a Naming conflict if you\u0026#39;ve already installed a \u0026#34; different version somewhere else. \u0026#34; Plugin \u0026#39;ascenator/L9\u0026#39;, {\u0026#39;name\u0026#39;: \u0026#39;newL9\u0026#39;} \u0026#34; All of your Plugins must be added before the following line call vundle#end() \u0026#34; required filetype plugin indent on \u0026#34; required \u0026#34; To ignore plugin indent changes, instead use: \u0026#34;filetype plugin on \u0026#34; \u0026#34; Brief help \u0026#34; :PluginList - lists configured plugins \u0026#34; :PluginInstall - installs plugins; append `!` to update or just :PluginUpdate \u0026#34; :PluginSearch foo - searches for foo; append `!` to refresh local cache \u0026#34; :PluginClean - confirms removal of unused plugins; append `!` to auto-approve removal \u0026#34; \u0026#34; see :h vundle for more details or wiki for FAQ \u0026#34; Put your non-Plugin stuff after this line 꼭 저장하고 Vim 을 종료하세요. 그리고 터미널에서 Vim 을 실행합니다.\n그럼 이제 아래와 같은 화면이 뜰텐데 : 으로 명령모드에 진입하고 PluginInstall 을 입력합니다. Terminal 에서 바로 설치하는 방법으로는 vim +PluginInstall +qall 이렇게 커맨드를 입력하면 된다고 합니다.\n설치 진행 중에는 아래와 같은 화면을 볼 수 있을텐데 설치과정에 시간이 조금 필요하니 잠시 기다려야 하더라고요. 저는 뭔지 모르겠는데 에러가 하나 발생했어요 ㅠㅠ 별거 아니길 바라고 일단 계속 진행해 볼게요.\nUpdate: Error 메세지에 대해 확인해보니 이 Plugin 은 설치할 필요가 없는 것이라고 하네요. 위 코드블럭에서는 해당 내용을 삭제해두었습니다.\nPlugin 설치하기 Vundle 설치를 마쳤으니 이제 본격적으로 Plugin 설치를 시작해볼게요.\nVim Markdown 먼저 Plastic Boy 의 Vim Markdown 을 설치하겠습니다. Markdown Highlighting Plugin 중에서는 이게 가장 유명한 것 같아요.\n.vimrc 파일을 열어 아래 코드를 입력하세요.\nPlugin \u0026#39;godlygeek/tabular\u0026#39; Plugin \u0026#39;plasticboy/vim-markdown\u0026#39; 저는 이렇게 입력했습니다. \u0026quot; 를 앞에 붙이면 코멘트 처리되는 것 같아요.\n그리고 조금 전과 같이 Vim 을 실행하고 커맨드 모드에서 PluginInstall 을 실행했습니다.\n설치가 끝난 것 같으니 바로 Markdown 파일을 하나 열어볼게요. 두근두근!! 오호~ 진짜로 못보던 효과가 생겼어요. 제목을 기준으로 글을 접고 라인 수를 표시해주는 것 같네요.\n어떻게 펼치는지를 몰라 다시 README 를 읽어보았더니 Folding 을 하나씩 펼치려면 zr, 한번에 전부 펼치려면 zR 커맨드를 사용하라고 하네요. 바로 펼쳐보았습니다.\n엥.. 아무것도 변한게 없어요. 접어주기만하고 왜 색은 안변한건지\u0026hellip; 역시 쉽게 넘어가주지 않네요 ㅠ\nREADME 파일을 계속 읽어보니 Syntax Extension 은 기본적으로 비활성화되어 있다고 합니다. 아무래도 이게 HighLighting 을 도와주는 기능같은데 비활성화라니\u0026hellip; 그럼 이걸 설치한 의미가 없잖아\u0026hellip; 바로 활성화 시켜봐야겠어요.\n일단 .vimrc 에서 Plugin 에 대한 세부설정을 건드릴 수가 있다고 하네요. 다시 파일을 열어 Folding 비활성화, YAML, TOML, JSON Syntax 를 활성화 시켜보겠습니다. YAML 과 TOML 은 Hugo 에서 사용하는 Front Matter 에 관련된 설정이므로 Hugo 블로그를 사용하지 않는 분들은 빼고 설정해도 됩니다.\n\u0026#34; Vim SYNTAX EXTENSIONS \u0026#34; Disable Folding let g:vim_markdown_folding_disabled = 1 \u0026#34; YAML Front Matter let g:vim_markdown_frontmatter = 1 \u0026#34; TOML Front Matter let g:vim_markdown_toml_frontmatter = 1 \u0026#34; JSON Front Matter let g:vim_markdown_json_frontmatter = 1 파일의 맨 아래쪽에 코드를 입력하고 저장한 뒤에 다시 MD 파일을 열어볼게요. Folding 설정은 적용이 잘 되서 더 이상 글이 접힌채로 시작하는 것이 아니라 설치하기 전처럼 한번에 다 보이는 형태로 나왔는데 그 외에는 어떤 색상도 적용되지가 않았어요. 이번엔 또 뭐가 문제지\u0026hellip;\n일단 TOML 및 JSON 은 단순히 활성화만 시킨다고 Syntax 색상이 적용되는 것이 아니라 추가적인 Plugin 이 또 필요하다고 합니다. 그럼 얘네들을 또 설치해볼까요. 뭐가 이렇게 많이 필요한거야!!\nTOML PlugIn 설치 TOML Syntax 는 vim-toml 을 설치하면 된다고 합니다. README 에서 시키는대로 해봅니다. 먼저 폴더를 하나 만들어주고 Git Clone 을 할게요.\nmkdir -p ~/.vim/pack/plugins/start cd ~/.vim/pack/plugins/start git clone https://github.com/cespare/vim-toml.git 그리고 .vimrc 파일에 Plugin 'cespare/vim-toml' 을 입력하고 :PluginInstall 까지 해줍니다. 이제 익숙해져버렸어..\nPlugin \u0026#39;cespare/vim-toml\u0026#39; 근데 하고보니까 굳이 Clone 은 할 필요가 없었던 것 같아요. Vundle 이 알아서 설치해주는 것 같은데\u0026hellip;\nJSON PlugIn 설치 JSON Syntax 는 Better JSON for VIM의 README 를 참고해 아래 코드를 .vimrc 에 입력했어요.\nPlugin \u0026#39;elzr/vim-json\u0026#39; 이렇게하고 다시 MD 파일을 열어보았으나\u0026hellip; 아직도 아무 색상도 보이지 않네요 ㅠㅠ 이제 점점 지쳐갑니다\u0026hellip; Vim 에 Markdown Highligting 을 적용하는게 이렇게 힘들줄이야\u0026hellip; 그래도 여기까지 왔으니 포기할 수 없어요. 또 뭐가 빠졌길래 이러는건지 찾아볼게요.\n휴\u0026hellip; 무려 3시간의 삽질 끝에 해결법을 알아냈습니다. 너무 간단한 문제였는데 도대체 답을 찾기가 어려웠어요. 분명히 정상적으로 다 설치한 것 같고 접기 기능도 정상적으로 작동하는데 색상만 표시되지 않던 이유는 Vim 에서 Syntax 설정이 꺼져있어서 그런거였어요. 이 간단한 문제 찾는데 3시간을\u0026hellip;~\nVim 에서 : 를 눌러 커맨드 모드로 진입하고 syntax on 을 입력하면 끝입니다. 참고로 Default 값이 off 로 되어있어 매번 파일을 열 때마다 Syntax 를 적용해주기 번거로우니 .vimrc 파일에 syntax on 을 입력해두면 이후부터는 항상 Syntax Highliting 이 적용된 채로 파일이 열리게 됩니다.\n색이 이쁘지는 않지만 그래도 정상적으로 하이라이팅 되고 있어요. 해냈습니다!! YAY!!!\nMarkdown Preview 힘들었지만 성공적하고나니 그래도 보람이 있어요 ㅎㅎ 하지만 우리는 아직 한가지를 더 설치해야합니다. 이번엔 제발 쉽다고해줘 ㅠㅠ 바로 우리가 작성하는 MD 파일의 결과물을 실시간으로 확인할 수 있게 도와주는 Preview Plugin 입니다. 그럼 같이 한번 후딱 설치해볼게요.\n이번에 설치할 플러그인은 Markdown Preview 에서 확인할 수 있습니다. 이제 Vundle 사용에 익숙해졌으니 빠르게 진행할게요.\nPlugin \u0026#39;JamshedVesuna/vim-markdown-preview\u0026#39; .vimrc 에 입력하고 바로 설치까지 진행했습니다. Markdown 파일을 편집할 때 Control + P 를 누르면 Defualt 브라우저로 창이 열리면서 Markdown 이 적용된 결과물을 보여준다고하여 설치를 마치자마자 바로 MD 파일을 열어 실행해보았습니다. 그리고 결과는!!\n실패\u0026hellip; 이번에도 역시 저에게 시련을 안겨주는군요. 어디 한번 해결해봅시다. 이것 저것 알아보다가 Preview 를 정상적으로 표시하기 위해서는 Markdown 이나 Grip 을 추가로 깔아야한다는 것을 알게되었습니다. 아니 이 정도면 그냥 VSCode 쓰는 것도..ㅋㅋㅋ~\n근데 저희는 지금 Markdown 을 사용하는거니까 왠지 이름도 Markdown 인걸 설치하고 싶더라고요. 그래서 Hombrew 를 통해 Markdown 을 설치해보았습니다. 그리고 실행해보니!!\n아\u0026hellip; 또 문제가 발생했어요. 역시 한번에 쉽게가면 재미가 없죠. 인코딩 문제인 것 같아 설정을 조금 건드려보았으나 번번히 실패하고 결국 Grip 을 깔았습니다. 이것도 Homebrew 에서 설치를 지원하더라고요. 역시 Homebrew 는 짱이에요. 말이 나온 김에 혹시 Homebrew 가 무엇인지 아직 잘 모르는 분들은 Homebrew 설치 및 기본 사용법 익히기 포스팅을 참고해주세요.\nbrew install grip 하지만 Grip 의 경우에는 .vimrc 에 추가적으로 설정을 하나 더 추가 입력해야합니다.\nlet vim_markdown_preview_github = 1 여기까지하고 Control + P 를 눌러보니 markdown 이 설치되었을 때와는 다르게 Terminal 아래쪽에 call Vim_Markdown_Preview() 라는 커맨드가 보이며 브라우저가 열리네요.\n그리고 결국 성공입니다!!! 정말 오래걸리고 힘들었지만 성공해냈어요 ㅎㅎㅎ 이제 제 블로그 포스팅을 Vim 에서 작업하고 올릴 수 있게되었다구요!! 기나긴 삽질의 시간이었지만 앞으로 잘 활용해서 지금 삽질한 시간 그 이상의 결과물을 뽑아내겠습니다! 그럼 오늘도 끝까지 읽으신 모든 분들 수고 많으셨습니다!!\n","permalink":"https://kasroid.github.io/posts/developertools/20200829-vim-vundle-markdown-plugin-installation/","summary":"제가 Tistory 로 블로그를 시작했지만 Hugo 로 넘어오게된 이유가 몇 가지 있는데 그 중 가장 큰 비중을 차지하는 두가지가 하나는 Tistory 가 Markdown 을 제대로 지원하지 않고, 코드블럭 처리를 고려하면 글을 Tistory 전용 에디터에서 쓰는 것이 반 강제되는 것이었는데요. Tistory 에디터로 글을 쓰다보면 텍스트에 기본적인 강조 처리하는 것들도 전부 마우스로 처리해야하는데 매번 키보드에서 손이 움직이는게 여간 성가신 것이 아니었거든요. 그래서 포스트를 작성하는 와중에 이 모든걸 Terminal 에서 처리할 수 있으면 어떨까 하는 생각을 종종하게 되었고 결국 Hugo 로 블로그를 관리하는 것으로 결정했습니다.","title":"Vim - Vundle 및 Markdown Plugin 설치하기"},{"content":" 본 포스팅은 Swift 5.2.4 기준으로 작성되었습니다.\n이번 새로운 프로젝트 진행 중에 소셜 로그인 서비스를 제공하기로 결정되었는데요. 앱에서 소셜 로그인을 하나라도 제공하게 되면 Apple 로그인도 반드시 지원해야 합니다. 요즘 로그인이 필요한 앱들은 웬만하면 소셜 로그인도 지원하는 추세니까 Apple 로그인도 구현해야되고\u0026hellip; 그러니까 지금 구현하는 방법을 알아두면 쓸 일이 많을거에요. 그럼 같이 한번 공부해볼까요~~\nApple Developer Documentation 처음 접하는 내용은 무엇보다 공식문서를 먼저 살펴봐야겠죠!\n이런저런 내용이 있긴한데 우리에게 필요한 부분은 App 과 Services 에 유저가 쉽게 로그인 할 수 있도록 도와주는 Framework 라는 정도인 것 같아요. 코드 구현에 유용한 정보는 없어보이니 공식 문서는 이정도로 넘어가는걸로하고 그냥 직접 구현하면서 알아보도록 할게요!\nEntitlement 파일 생성하기 먼저 새로운 프로젝트를 만들고 Signing \u0026amp; Capabilities 카테고리로 넘어와 아래 이미지에서 빨간색 화살표로 표시된 + 버튼을 클릭해주세요.\n그러면 뭔가 익숙한 느낌의 새로운 창이 하나 뜹니다 ㅎㅎ 그러면 Sign 으로 검색하고 Sign In with Apple 을 찾아서 클릭해주세요.\n참고로 Apple 에 개발자로 등록되지 않은 분들은 Sign In with Apple 이 검색되지 않을 수도 있어요. 이럴때는 Team 을 None 으로 설정하고 검색하면 보일거에요.\n이제 .entitlements 확장자를 가진 새로운 파일이 하나 생겼을 거에요. 뭔가 생소한 파일이죠?? 다행히 이곳에서 추가로 작업할 내용은 없습니다 ㅎㅎㅎ\nImport AuthenticationServices 가장 먼저 우리가 해야할 일은 Apple 에서 로그인을 지원하기 위해 만든 인스턴스에 접근할 수 있도록 AuthenticationServices 를 import 해주어야 합니다.\nimport AuthenticationServices Sign In with Apple 버튼 생성하기 이제 ViewController 에 Sign In with Apple 버튼을 생성해보도록 할게요. 여기서는 일반 UIButton 을 사용하는게 아니라 ASAuthorizationAppleIDButton 으로 인스턴스를 생성해야 합니다.\nlet authorizationAppleIDButton = ASAuthorizationAppleIDButton() 처음보는 코드니까 당연히 공식문서를 보고 넘어가야겠죠?\n유저가 Sign In with Apple 을 시작할 수 있게 해주는 control 이라고 하네요. UIButton 처럼 UIControl 을 상속받고 있습니다. 그렇다면 어느정도 비슷한 성질을 가졌을 것 같네요. 이번엔 문서 아래쪽에 알아두면 좋을만한 내용이 있어 추가로 가져와봤어요.\n중간쯤에 Styling the Button 카테고리가 보이죠? 개발자가 cornerRadius 나 버튼의 style 을 일정 부분 수정할 수 있게 해놓은 것 같습니다. 이 부분은 나중에 시간날 때 직접 실험을 해보고 업데이트 하도록 할게요.\n그럼 이제 버튼을 화면의 중앙에 오도록 배치해봅시다. ASAuthorizationAppleIDButton 도 결국 버튼의 일종이므로 .addTarget method 를 사용해 원하는 Action 을 구현할 수 있도록 @objc method 와 연결해 주었습니다.\nimport UIKit import AuthenticationServices class ViewController: UIViewController { // MARK: - Properties let authorizationAppleIDButton = ASAuthorizationAppleIDButton() override func viewDidLoad() { super.viewDidLoad() configureUI() } // MARK: - UI private func configureUI() { setAdditionalPropertyAttributes() setConstraints() } private func setAdditionalPropertyAttributes() { authorizationAppleIDButton.addTarget(self, action: #selector(handleAuthorizationAppleIDButton(_:)), for: .touchUpInside) } private func setConstraints() { view.addSubview(authorizationAppleIDButton) authorizationAppleIDButton.translatesAutoresizingMaskIntoConstraints = false NSLayoutConstraint.activate([ authorizationAppleIDButton.centerXAnchor.constraint(equalTo: view.centerXAnchor), authorizationAppleIDButton.centerYAnchor.constraint(equalTo: view.centerYAnchor) ]) } // MARK: - Selectors @objc private func handleAuthorizationAppleIDButton(_ sender: ASAuthorizationAppleIDButton) { print(#function) } } 여기까지 코드를 작성하고 시뮬레이터를 실행해보면 이렇게 중앙에 버튼이 배치되고 정상적으로 handleAuthorizationAppleIDButton 함수 내부에 구현해둔 print 가 실행되는 것을 볼 수 있을거에요.\nLogin Process 구현하기 이제 UI작업은 마쳤으니 실제로 로그인이 데이터 처리에 필요한 코드를 작성해 보겠습니다. 당연한 얘기지만 로그인 과정은 버튼이 눌렸을 때 실행되도록 하면 되니까 handleAuthorizationAppleIDButton() 함수에 코드를 작성할거에요.\n로그인 과정을 처리하기 위해서 우리가 필수로 생성하고 접근해야하는 인스턴스는 ASAuthorizationAppleIDProvider 입니다.\nApple ID 를 사용해서 로그인 인증 요청을 생성해주는 메커니즘이라고하네요. 이번에는 Overview 부분도 주의깊게 봐야합니다. 우리가 생성해야할 provider, request, controller 에 대한 정보들이 있거든요. 그럼 이 정보들을 바탕으로 코드를 한번 작성해봅시다.\n@objc private func handleAuthorizationAppleIDButton(_ sender: ASAuthorizationAppleIDButton) { let provider = ASAuthorizationAppleIDProvider() let request = provider.createRequest() request.requestedScopes = [.fullName, .email] let controller = ASAuthorizationController(authorizationRequests: [request]) controller.performRequests() } 그냥 공식문서에 있는 것과 똑같이 작성했어요 ㅎㅎ Provider 를 통해 Request 를 생성하고 생성된 Request 를 Controller 에게 전달해줘서 Controller 가 요청을 실행하는 개념입니다.\n중간에 있는 .requestedScopes 는 우리가 유저로부터 전달받을 최소한의 정보를 요청할 수 있게 도와주는 method 입니다. 내부에 들어가보면 fullname 과 email 이렇게 최대 2가지만 요청할 수 있게 만들어져 있어요.\n물론 이 2가지마저도 사용자가 거부하면 우리가 받을 수 있는 것은 유저의 identifier 뿐으로 이것으로 최소한의 식별만 가능하게 됩니다. 역시 개인의 보안을 중시하는 애플이에요 ㅎㅎ\n하지만 이것으로 끝은 아닙니다. 아직 유저가 로그인에 성공하거나 실패했을 때 처리를 하지 않았고, 로그인 요청 창을 띄울 페이지도 설정해주지 않았거든요. 이 부분을 처리하기 위해서는 ASAuthorizationControllerDelegate 와 ASWebAuthenticationPresentationContextProviding 을 채택해야합니다.\nASAuthorizationControllerDelegate 를 채택하고 나면 로그인이 성공적으로 처리되었을 때 호출될 didCompleteWithAuthorization 함수와 실패했을 때 호출될 didCompleteWithError 함수를 불러올 수 있게 됩니다.\n그리고 ASWebAuthenticationPresentationContextProviding 에는 필수 구현 함수인 presentationAnchor() 에서 사용자에게 로그인 요청을 띄울 윈도우를 설정해줄 수 있습니다. 우리는 현재 View 의 Window 에서 바로 실행되도록 만들거에요. 자 그럼 지금까지 얘기한 내용들을 바로 코드로 구현해볼게요.\nextension ViewController: ASAuthorizationControllerDelegate { func authorizationController(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization) { } func authorizationController(controller: ASAuthorizationController, didCompleteWithError error: Error) { } } extension ViewController: ASAuthorizationControllerPresentationContextProviding { func presentationAnchor(for controller: ASAuthorizationController) -\u0026gt; ASPresentationAnchor { return view.window! } } 이전에 만들어 두었던 handleAuthorizationAppleIDButton() 함수 내부의 controller 에게 delegate 와 provider 위임도 빼먹지 말고 꼭 해주세요!\ncontroller.delegate = self controller.presentationContextProvider = self 이제 거의 끝이 보입니다!\n먼저 로그인 정보가 성공적으로 들어왔을 때에 대한 처리 코드를 작성해볼게요. 당연히 didCompleteWithAuthorization 함수에 작성해야겠죠? 이 함수는 호출되면 ASAuthorization 타입을 가진 parameter 와 함께 실행됩니다. 잠깐 ASAuthorization 에 대해 알아보자면\u0026hellip;\nController 가 성공적으로 인증을 진행했을 때 캡슐화해서 전달해주는 정보라고하네요. 내부에 credential 이라고하는 property 가 있고 이것은 성공적으로 인증된 사용자의 정보라고 합니다.. 지금은 캡슐화가 되어있는 상태이므로 credential 정보에 접근하기 위해 ASAuthorizationAppleIDCredential 타입으로 캐스팅이 필요합니다. 생소한 타입이죠?\n설명을 보면 encapsulation 이라는 단어가 사라지고 Apple ID 를 사용해 성공적으로 인증된 결과라고 써져있어요. 이것으로 타입 캐스팅을하면 캡슐이 해제되고 우리가 원하는 정보들에 접근할 수 있게됩니다. 문서의 Getting Contact Information 카테고리에 fullName 과 email 이 적혀있고 우리가 접근할 수 있을 것 같아요. 그리고 user 라는 property 가 매우 중요한데 일종의 identifier 로 우리가 무조건 받을 수 있는 소중한 정보입니다. 이 값으로 우리는 유저가 누구인지 판단을 해야하거든요.\nfunc authorizationController(controller: ASAuthorizationController, didCompleteWithAuthorization authorization: ASAuthorization) { if let appleIDCredential = authorization.credential as? ASAuthorizationAppleIDCredential { // Create an account in your system. let userIdentifier = appleIDCredential.user let userFirstName = appleIDCredential.fullName?.givenName let userLastName = appleIDCredential.fullName?.familyName let userEmail = appleIDCredential.email } 그리고 fullName 은 .givenName 과 .familyName 으로 나눠서 받을 수도 있어요. 이렇게 첫 가입절차에서 사용자의 정보를 가져오는 코드를 완성했습니다. 이제 사용자가 최초 가입 후 로그인을 마치고 다음 로그인 시부터 우리가 사용자를 식별하여 로그인을 수 있도록 도와주는 코드를 작성해보겠습니다.\nlet appleIDProvider = ASAuthorizationAppleIDProvider() appleIDProvider.getCredentialState(forUserID: userIdentifier) { (credentialState, error) in switch credentialState { case .authorized: // The Apple ID credential is valid. Show Home UI Here break case .revoked: // The Apple ID credential is revoked. Show SignIn UI Here. break case .notFound: // No credential was found. Show SignIn UI Here. break default: break } } authorized - 사용자의 identifier 가 정상적으로 인식되었을 경우\nrevoked- 사용자의 identifier 가 유효하지 않은 경우\nnotFoun - 사용자의 identifier 를 찾지 못한 경우\nCredentialState 에는 경우의 수가 총 3가지가 있고 상황에 맞는 코드를 각 case 에 작성해주면 됩니다. 우리는 추가 작업이 필요하지 않으므로 따로 작성하지 않겠습니다.\n에러처리는 따로 작성해주지 않아도 무방하지만 그래도 에러발생 시 우리가 알 수 있도록 print 를 하나 남겨두겠습니다.\nfunc authorizationController(controller: ASAuthorizationController, didCompleteWithError error: Error) { print(error) } 이제 앱을 한번 실행해볼게요.\n이렇게 가입이 정상적으로 진행됩니다. Print 로 내가 가입 시 제공한 정보(이메일 및 이름)들과 identifier 가 console 에 출력될거에요. 하지만 첫번째를 제외한 이후 로그인 부터는 identifier 만 print 되고 나머지는 nil 값이 들어옵니다. 그럼 이번 포스팅은 이것으로 마치겠습니다.\n함께 참고하면 좋은 포스트 ","permalink":"https://kasroid.github.io/posts/ios/20200829-sign-in-with-apple-uikit/","summary":"본 포스팅은 Swift 5.2.4 기준으로 작성되었습니다.\n이번 새로운 프로젝트 진행 중에 소셜 로그인 서비스를 제공하기로 결정되었는데요. 앱에서 소셜 로그인을 하나라도 제공하게 되면 Apple 로그인도 반드시 지원해야 합니다. 요즘 로그인이 필요한 앱들은 웬만하면 소셜 로그인도 지원하는 추세니까 Apple 로그인도 구현해야되고\u0026hellip; 그러니까 지금 구현하는 방법을 알아두면 쓸 일이 많을거에요. 그럼 같이 한번 공부해볼까요~~\nApple Developer Documentation 처음 접하는 내용은 무엇보다 공식문서를 먼저 살펴봐야겠죠!\n이런저런 내용이 있긴한데 우리에게 필요한 부분은 App 과 Services 에 유저가 쉽게 로그인 할 수 있도록 도와주는 Framework 라는 정도인 것 같아요.","title":"System - Sign in With Apple 구현하기 with UIKit"},{"content":"오늘은 CocoaPods 가 무엇인지 알아보도록 하겠습니다.\n개발을 할 때 모든 것을 스스로 만드는 것도 좋지만 필요에 따라 Library 를 써서 시간과 노력을 절약하고 다른 곳에 좀 더 신경을 쓰는 것이 좋을 때도 있을겁니다. 하지만 그렇게 Library 사용 빈도가 점점 늘게되면 나중에는 Library 를 찾거나 관리하는데 시간이 많이 소모되게 됩니다. 그럼 아무래도 Library 를 쓰는 의미가 많이 퇴색되겠죠? 그래서 Xcode 에서 이런 Library 관리를 쉽게 할 수 있도록 도와주는 것이 CocoaPods 입니다.\n즉 한마디로 CocoaPods 는 Library 관리 툴입니다. 각종 Libarary 를 설치, 삭제, 그리고 버전 관리를 할 수 있습니다. 개인 프로젝트에서도 충분히 그 역할을 다하지만, 여러 사람이 한 프로젝트를 공유하여 협업할 때 CocoaPods 내의 Library List (Podfile.lock) 파일만 전달해도 모두가 동일한 버전의 라이브러리를 손쉽게 설치할 수 있도록 도와주기도 합니다.\n최근에는 Apple 이 공식적으로 지원하고 설치 및 관리가 더 편한 Swift Package Manager 가 등장하긴 했지만 SPM 에는 없는 Library 들이 CocoaPods 로는 존재하는만큼 Library 사용에 있어 절대로 빼놓을 수 없는 것이 CocoaPods 입니다.\n그럼 이제 설치부터 사용방법까지 같이 한번 알아보도록 해요.\n공식 홈페이지에서 CocoaPods 설치하기 먼저 CocoaPods 공식 홈페이지에 들어가보세요. 접속해서 스크롤을 조금만 내려보면 다음과 같은 페이지를 볼 수 있습니다.\nsudo gem install cocoapods 그럴리 없겠지만 만약에 홈페이지에 접속이 안되거나 명령어를 찾지 못하는 분들은 위 코드를 복사해서 붙여넣으셔도 됩니다 ㅎㅎ\n자 이렇게 하고 Return 키를 누르면 자동으로 설치가 완료됩니다. 자물쇠 모양이 뜬다면 맥북에 설정해 놓은 비밀번호를 치고 다시 한번 Return 키를 눌러주세요. 참고로 비밀번호 칠 때 아무것도 안쳐지는 것처럼 보일 수 있는데 그냥 치면 됩니다 ㅎㅎ\n이렇게 CocoaPods 에 설치를 마쳤어요. 정말 간단했죠?\nHomebrew 로 CocoaPods 설치하기 macOS Catalina 부터 CocoaPods 가 정상적으로 설치되지 않는 경우가 있다고 하네요. 저도 방금 맥북이 꼬여서 포맷 후에 CocoaPods 를 설치하는 과정에서 문제가 생겨서 많이 헤매다가 결국 Homebrew 를 통해 설치하는 방법으로 해결했습니다.\n오히려 위에서 안내드렸던 방법보다 설치 및 삭제 관리까지 더 용이하기 때문에 저는 개인적으로 이제부터는 항상 Homebrew 를 통해서 설치하게 될 것 같아요.\nbrew install cocoapods 혹시 아직 Homebrew 를 설치하지 않은 분들은 다음 포스팅을 참고하여 먼저 설치를 진행해 주세요.\n프로젝트에 CocoaPods 적용하기 자 그럼 실습을 위해 새로운 Xcode 프로젝트를 시작해볼게요. 프로젝트 생성 후에 해당 폴더 내로 들어가보면 아래와 같은 화면을 볼 수 있을거에요. 폴더 하나와 .xcodeproj 파일이 하나 있네요.\n이제 이 곳에 CocoaPods 를 적용해보겠습니다. macOS 터미널에서 방금 전 만든 폴더가 있는 곳으로 들어간 뒤에 다음 명령어를 입력해주세요.\npod init 아래 스크린샷을 보면 처음에는 파인더에서 보았듯이 파일이 딱 2개만 있었는데 CocoaPods 를 프로젝트 폴더에 적용한 뒤에는 Podfile 이라는 새로운 파일이 하나 더 생긴 모습을 볼 수가 있습니다.\nLibrary 적용하기 이렇게 새로운 Library 를 설치할 준비가 되었습니다. 그렇다면 라이브러리는 어떻게 설치할 수 있을까요? 조금 전에 우리가 방문했었던 CocoaPods 홈페이지로 돌아가 검색창에 SnapKit 을 입력해보세요.\n이런식으로 결과가 보일거에요. 이중 제일 위의 SnapKit 을 클릭해서 들어가보도록 할게요. 우측에 옅은 회색으로 보이는 숫자는 현재 제가 설치하는 시점에서 가장 최신 버전이 5.0.1 이라는 뜻입니다.\n스크롤을 조금만 내려보면 Installation 이라는 문구가 보일거에요. 이곳에 CocoaPods 라고 써져있네요. 딱 봐도 이곳을 살펴보면 될 것 같은 느낌이 들죠? 첫번째로 보이는 명령어는 우리가 이미 진행한 CocoaPods 의 설치법이고 우리에게 지금 필요한 것은 두번째 코드 블럭입니다. 처음보면 뭔가 복잡해보일 수 있지만 우리가 필요한 코드는 밑에서 두번째 줄에 위치한 pod 로 시작하는 명령어 단 한줄이에요. SnapKit 라이브러리의 5.0.0 version 이상을 설치하겠다는 의미입니다.\npod \u0026#39;SnapKit\u0026#39;, \u0026#39;~\u0026gt; 5.0.0\u0026#39; 그럼 조금 전 우리가 생성한 Podfile 을 열어주세요. 기본 텍스트 편집기도 좋고 Vim 도 좋고 그냥 텍스트 에디터 중 어떤 것으로 열어도 괜찮습니다. 저는 VSCode 로 작성해보겠습니다.\n이제 SnapKit 을 설치할 준비가 모두 끝났습니다! 파일을 저장하고 닫은 뒤 터미널로 돌아가 설치 명령어를 입력해보도록 할게요 설치니까 당연히 install 이라고 치면되겠죠?\npod install 명령어를 실행하고 나면 다음과 같은 화면이 보이게 됩니다.\n그럼 초반에 열어둔 Xcode 프로젝트 파일이 있던 파인더를 다시 한번 봐볼게요.\n무언가 파일들이 엄청 많이 생겼어요 ㅎㅎㅎ 이게 전부 다 CocoaPods 관련 파일들이랍니다. Podfile 은 우리가 프로젝트에 설치하기 원하는 라이브러리를 찾아 이름과 버전을 적었던 파일이었던거 기억하시죠? 그럼 다른 파일들은 무엇인지 잠깐 알아보도록 할게요.\n먼저 Podfile.lock 파일은 Podfile 에 적혀있던 목록들을 설치하고나면 이 프로젝트에 설치되어 있는 라이브러리의 목록과 버전을 정확하게 보관하고 있는 파일입니다. 우리가 방금 SnapKit 을 설치했을 때는 최신 버전이 5.0.0 대 였지만 먼 훗날 언제가 우리가 이 파일을 누군가에게 전달하고 그 사람이 SnapKit 을 설치할 때는 최신 버전이 6.0.0 대 일 수 있잖아요? 그럼 라이브러리 호환성으로 인한 충돌이 발생할 수 있기 때문에 이런 상황을 방지하고자 CocoaPods 는 Podfile.lock 에 본인이 설치한 라이브러리들의 대한 정보를 정확히 기록해두는 거에요. 즉 이 파일만 공유하면 프로젝트에 설치된 라이브러리의 버전을 협업하는 사람들과 항상 동일하게 유지할 수 있게됩니다.\nPods 폴더는 실제 라이브러리에 관련된 데이터가 들어가있는 곳이에요. 무언가 문제가 생겨 처음부터 다시 설치하고자할 때는 이 폴더를 통째로 삭제하고 pod install 을 통해 라이브러리를 다시 설치할 수 있습니다.\n그리고 이전에는 볼 수 없었던 흰색 Xcode 파일이 생겼습니다. 확장자는 .xcworkspace 로 CocoaPods 가 설치된 이후부터는 프로젝트 실행 시 xcodeproj 대신 이 파일을 사용해야 합니다. 기존 xcodeproj 파일과 완전히 동일하고 한쪽을 수정하게되면 다른 한쪽도 수정되지만 xcodeproj 에서는 CocoaPods 로 설치한 라이브러리들을 정상적으로 인식할 수 없으므로 사실상 작업이 불가능합니다. 그러니까 CocoaPods 로 Xcode 프로젝트에 라이브러리를 설치했다? 그럼 .xcworkspace 파일만 사용한다 이렇게 생각해주세요.\n그럼 이제 workspace 파일을 실행시켜서 SnapKit 을 import 해보겠습니다.\n좌측 Navigator 에 기존에는 볼 수 없었던 새로운 파일들이 많이 생긴 것을 볼 수 있습니다. 우리가 특별히 건들 필요가 없는 파일들이니까 겁먹지 않아도 됩니다 ㅎㅎㅎ 그리고 정상적으로 SnapKit 이 import 된 것도 확인할 수 있습니다. 혹시라도 에러가 발생한다거나하는 문제가 있는 분들은 Xcode 를 완전히 껏다가 다시 한번 실행해주세요.\n이렇게 CocoaPods 를 설치하고 간단하게 Library 를 적용하는 방법까지 알아보았습니다. 터미널이랑 웹페이지 등을 왔다갔다 해야되서 조금 복잡해보일 수도 있지만 다른 라이브러리들도 모두 동일한 방식으로 사용가능하니까 조금만 반복해보면 금방 익숙해질 수 있을거에요.\n","permalink":"https://kasroid.github.io/posts/ios/20200823-install-cocoapods-libraries/","summary":"오늘은 CocoaPods 가 무엇인지 알아보도록 하겠습니다.\n개발을 할 때 모든 것을 스스로 만드는 것도 좋지만 필요에 따라 Library 를 써서 시간과 노력을 절약하고 다른 곳에 좀 더 신경을 쓰는 것이 좋을 때도 있을겁니다. 하지만 그렇게 Library 사용 빈도가 점점 늘게되면 나중에는 Library 를 찾거나 관리하는데 시간이 많이 소모되게 됩니다. 그럼 아무래도 Library 를 쓰는 의미가 많이 퇴색되겠죠? 그래서 Xcode 에서 이런 Library 관리를 쉽게 할 수 있도록 도와주는 것이 CocoaPods 입니다.","title":"CocoaPods - 설치 및 라이브러리 적용하기"},{"content":"오늘 소개할 Homebrew 는 여러가지 종류의 프로그램을 설치하고 삭제할 수 있게 도와주는 툴입니다. 제가 개발자로 커리어를 전환하고나서 알게된 가장 유용한 툴이고 가장 애용하는 툴이기도 합니다. 조금만 익숙해지면 정말 편리하고 강력한 툴이기 때문에 시간이 나면 언젠가 꼭 한번 소개하고 싶었는데요. 그게 오늘이네요! ㅎㅎ\nHomebrew 는 macOS 의 Package Manager 입니다. 쉽게 말해서 일종의 프로그램 관리자 같은 역할이라 생각하면 좋을 것 같아요. 왠만한 모든 상용 프로그램의 설치 및 삭제, 그리고 업데이트 관리까지 Terminal 을 통해 Homebrew 하나로 해결할 수 있습니다. Homebrew 를 통해 프로그램을 설치하는게 편해봤자 얼마나 더 편하다고 굳이 이렇게 새로운 것을 배우기까지 해야하는지 의문이 들 수 있어요. 그래서 Homebrew 를 사용할 때와 사용하지 않을 때 우리가 프로그램을 설치하고 사용하기까지 거치는 과정들을 나열하고 차이점을 비교해 보겠습니다.\n구글 접속 검색 프로그램을 다운받을 수 있는 홈페이지 접속 홈페이지에서 다운로드 링크를 찾기 프로그램 다운로드 다운로드 폴더에 들어가서 설치파일 실행 설치과정 진행 설치가 완료되고나면 다운로드 폴더에서 설치 파일 제거 대부분 이런 과정들을 거쳐 프로그램을 설치하죠? 프로그램을 한개만 설치할 때는 이렇게 설치하는 방법도 나쁘진 않아요. 하지만 만약 10개를 설치해야한다면 어떨까요? 20개라면? 프로그램 설치가 비록 어려운 부분은 없지만 정말 귀찮은 일이지요. Homebrew 를 사용하면 최대 단 2번의 과정으로 위 과정들을 모두 끝낼 수 있습니다.\n다운로드받을 프로그램명 검색(optional) 다운로드 명령 실행 정말 이보다 간단할 수가 있을까요? 지금은 프로그램을 검색하는 과정까지 포함을 했지만 사실 우리가 다운받을 프로그램의 이름을 정확히 알고 있는 경우에는 검색조차도 필요가 없습니다. Terminal 에 커맨드 단 한줄 입력만으로 새로운 프로그램을 사용할 준비가 끝납니다.\nHomebrew 로 단순히 프로그램을 하나씩 설치하고 제거하는 것은 물론이고 만약 내가 설치해놓은 프로그램들을 리스트 형태로 만들어 두었다면(리스트를 만드는 기능도 Homebrew 에서 제공합니다) 한 번에 프로그램 수십개를 설치할 수도 있습니다. 리스트에 적힌 모든 목륵을 설치하라는 커맨드를 입력하고 우리는 커피 한잔하고 오면 프로그램들이 모두 설치되어 있는 것이죠 ㅎㅎㅎ\n어떤가요? 듣기만해도 매력이 뿜뿜하고 배우고 싶어지지 않나요?? ㅋㅋㅋㅋ\nHomebrew 설치하기 이정도면 제 Homebrew 영업에 어느정도 넘어왔을테니 바로 설치를 한번 시작해볼게요. 안 넘어왔어도 그냥 보세요 ㅋㅋ\n먼저 Homebrew 공식 홈페이지 에 접속합니다.\n이렇게 생긴 홈페이지가 보이면 Install Homebrew 라고 적힌 부분의 아래 명령어를 Terminal 에서 실행합니다.\n/bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\u0026#34; 만약 Terminal 에 자물쇠 모양이 나타나며 비밀번호를 요구할 경우 비밀번호를 입력해주세요. 우리가 평소 웹사이트에서 비빌번호를 입력할 때처럼 실시간으로 비밀번호가 입력되는 상황이 Terminal 에서는 보이지 않지만 실제로는 비밀번호가 입력되고 있는 상황이니 전부 입력하고 리턴키를 누르면 됩니다.\nHomebrew 사용법 익히기 Homebrew 설치를 정상적으로 마쳤다면 이제 Terminal 에서 brew 명령어를 사용할 수 있게 됩니다. 그럼 Terminal 에 brew 라고 한번 입력해볼게요.\n여러가지 명령어들이 많이 뜨네요 ㅎㅎ 생소한 명령어다보니 처음에는 조금 어렵게 느껴지더라도 그때그때 필요할 때 한번씩 찾아 쓰다보면 명령어들이 전부 쉬운편이라 금방 외워서 사용하게 되니 일부러 외울 필요는 없습니다. 우리는 영어 한마디 제대로 못하던 시절에도 수 많은 스타크래프트 치트키를 외워서 사용했었습니다 ㅎㅎ\n프로그램 검색하기 Homebrew 로 프로그램을 설치하기 위해서는 먼저 우리가 원하는 프로그램의 명칭을 정확하게 알아야 합니다. 프로그램 이름이 단어 하나로 구성된 경우에는 대부분 그 자체로 프로그램명이 되지만 이름에 띄어쓰기가 있는 경우 표기 방법이 조금 다를 수 있으니 먼저 검색을 한번 해보는 것이 좋습니다. 그럼 이번에는 예제로 구글 크롬을 검색해보도록 할게요.\nbrew search google chrome 검색 결과가 총 4개가 있네요. 딱 봐도 첫번째 결과가 우리가 찾는 구글 크롬인 것 같아요. 꽤 정확한 결과값이므로 이 단어로 바로 설치를 진행해도 되지만 정말 혹시 모르는 경우를 대비해서 이게 정확한 곳에서 다운로드 받는 것인지 확인해 볼 수 있습니다.\nbrew cask home google-chrome cask 는 상용 프로그램이라는 뜻으로 일반 홈페이지에서 직접 다운로드 받는 프로그램을 의미합니다. 구글 크롬은 App Store 다운받거나 Terminal 에서 Tool 의 형태로 제공되는 것이 아닌 일반 브라우저에서 다운로드 받아 사용하는 상용 프로그램이니까 cask 에 속합니다. 그리고 home 은 다운받을 수 있는 홈페이지를 뜻합니다. 즉 구글 크롬을 다운받을 수 있는 홈페이지를 열라는 뜻이에요.\n우리가 딱 원하는 페이지가 떳어요!! 그럼 이제 google-chrome 을 사용해 설치해볼게요.\n프로그램 설치하기 설치방법은 매우 간단합니다.\nbrew cask install google-chrome 잠깐 기다려주고나면 짜잔!! 설치가 모두 끝났고 이제 정상적으로 프로그램을 사용할 수 있게되었습니다.\n설치된 프로그램 확인하기 우리가 설치한 프로그램의 목록도 brew 를 통해 간단히 나열하고 확인할 수가 있습니다. 다음 커맨드를 입력해 보세요.\nbrew cask list 내 컴퓨터에 설치되어 있는 일반 프로그램의 리스트를 달라는 뜻이에요.\n방금 설치한 구글 크롬이 목록에 표시된다면 정상적으로 설치가 되었다는 뜻입니다. 저는 모든 프로그램들을 Homebrew 로 관리하고 있어서 이렇게 많이 뜬답니다 ㅎㅎㅎ\n프로그램 삭제하기 설치하는 방법을 알았으니 삭제는 당연히 세트메뉴로 배워야겠죠?\nbrew uninstall google-chrome 네 끝입니다. 이렇게 Homebrew 가 프로그램 관리자 역할을 하며 우리 컴퓨터에 설치되어 있거나 설치할 모든 프로그램을 관리해주기 때문에 우리는 쓸데없는 시간낭비를 줄이고 다른 것들에 더 집중할 수 있습니다.\n다음 포스팅에서는 Homebrew 를 통해 내가 사용하는 프로그램들을 한번에 업데이트하는 방법과 내 컴퓨터에 깔려있는 모든 프로그램(Homebrew 를 통해 설치한)들의 리스트를 텍스트 파일형태로 저장하고 그 파일을 사용해 모든 프로그램을 한번에 설치할 수 있는 방법을 알아보겠습니다.\nTerminal 을 통해 프로그램을 설치하고 관리하는 것이 처음에는 익숙하지 않아 조금은 거부감이 들고 부담스러울 수 있지만 그냥 쓰다보면 정말 어려운거 없고 훨씬 편하다는 사실을 알게될거에요. 그럼 여러분들도 Homebrew 꼭 사용하길 바라겠습니다!\n","permalink":"https://kasroid.github.io/posts/developertools/20200823-homebrew-installation-basics/","summary":"오늘 소개할 Homebrew 는 여러가지 종류의 프로그램을 설치하고 삭제할 수 있게 도와주는 툴입니다. 제가 개발자로 커리어를 전환하고나서 알게된 가장 유용한 툴이고 가장 애용하는 툴이기도 합니다. 조금만 익숙해지면 정말 편리하고 강력한 툴이기 때문에 시간이 나면 언젠가 꼭 한번 소개하고 싶었는데요. 그게 오늘이네요! ㅎㅎ\nHomebrew 는 macOS 의 Package Manager 입니다. 쉽게 말해서 일종의 프로그램 관리자 같은 역할이라 생각하면 좋을 것 같아요. 왠만한 모든 상용 프로그램의 설치 및 삭제, 그리고 업데이트 관리까지 Terminal 을 통해 Homebrew 하나로 해결할 수 있습니다.","title":"Homebrew - 설치 및 기본 사용법 익히기"},{"content":" 본 포스팅은 이하 버전을 기준으로 작성되었습니다.\n· Firebase 6.29.0\n· Swift 5.2.4\nIntro Firebase 한 번쯤 들어보지 않으셨나요? 초보 개발자가 모바일 앱을 개발하고 개인 앱 서버를 운영하는데 있어 빠질 수 없는 것이 Firebase 가 아닐까 합니다. 속도에 조금 불만이 있긴 하지만 사실 백엔드를 모르는 개발자가 이렇게 쉽고 간편하게 회원가입부터 데이터 관리까지 할 수 있는 서버를 그것도 일정수준까지는 무료로 운영할 수 있게 해주는 서비스가 또 어디있을까요? 이 서비스가 없었으면 저는 지금 Python 도 같이 배우고 있었을 것 같네요. ~~ 물론 결국엔 배우는게 목표지만\u0026hellip;~~\n아무튼 Firebase 는 모바일 앱 개발자에게 백엔드 과정을 지원해주는 플랫폼 입니다. 그럼 오늘은 Xcode 프로젝트와 Firebase 를 연동하는 방법을 알아보도록 하겠습니다. 이 포스팅을 작성하는 시점에서는 Firebase 가 Swift Package Manager 를 지원하지 않아 CocoaPods 를 통해 설치하게되므로 CocoaPods 에 익숙하지 않은 분들은 CocoaPods - 설치 및 라이브러리 적용하기 포스팅을 먼저 읽어보세요.\nFirebase 와 친해지기 Firebase 는 Google 아이디만 있으면 특별히 가입할 필요도 없이 누구나 쉽게 사용할 수 있어요.\n홈페이지에 접속하고 나면 이런 화면을 볼 수 있을거에요. 구글 아이디로 로그인이 되어있다면 우측 상단에는 본인의 프로필 사진도 보이게 됩니다 ㅎㅎ 만약에 정말 혹시라도 만약에 구글 아이디가 없으신 분들은 계정을 하나 만드세요\u0026hellip;\n그리고 프로필 사진 옆을 잘 보시면 콘솔로 이동이라는 항목이 보이시죠? 이걸 클릭해서 Firebase 프로젝트가 보이는 화면으로 들어가 봅시다.\n저는 이미 Firebase 를 통해 여러 프로젝트를 진행했기 때문에 2개의 프로젝트가 보이지만 여러분은 아마 + 버튼 하나만 보일거에요. 이 버튼으로 Firebase 의 프로젝트를 생성하고 Xcode 프로젝트의 Bundle Identifier 를 이용해서 연결해주는 방식입니다. 연결이 되고나면 Xcode 프로젝트가 코드를 통해 Firebase 를 찾아가라는 명령을 받고 자신의 Bundle Identifier 로 등록된 Firebase 의 프로젝트를 찾아가는 것이라고나 할까나\u0026hellip;\n프로젝트를 만드는 순서는 지금 당장 + 버튼을 눌러 Firebase 프로젝트 생성을 시작하고 중간에 Xcode 프로젝트의 Bundle Identifier 가 필요한 시점에 Xcode 프로젝트를 생성해도 되지만 어자피 이렇게 하면 프로젝트를 왔다갔다해야되서 번거로우니 저는 그냥 Xcode 프로젝트부터 생성하고 Firebase 를 생성하는 것을 선호합니다.\nBundle Identifier 복하사기 그럼 Xcode 프로젝트를 생성하고 Bundle Identifier 를 복사해둘게요.\nFirebase 프로젝트 생성하기 그럼 이제 + 버튼을 눌러 프로젝트를 생성해볼게요. 첫 화면은 프로젝트 명을 생성하는 화면입니다.\nXcode 프로젝트명과 달라도 괜찮습니다. 단순히 Firebase 홈페이지 내부적으로 관리하기 위한 이름이에요. 그래도 두 프로젝트가 서로 어느정도는 이름이 비슷해야 나중에 알아보기 쉬우니까 저는 똑같이 만들도록 할게요.\n그 다음으로는 Google Analytics 를 설정하는 페이지가 뜰거에요. 이걸 사용하게되면 내 앱에 접속하는 사용자의 다양한 정보들을 그래프와 수치로 받아볼 수 있게됩니다. 서버 운영에 반드시 사용해야하는 기능은 아니니까 필요없는 상황에서는 그냥 끄고 사용하는 것도 괜찮습니다.\n지금은 튜토리얼이니까 켜고 진행하도록 할게요.\n다음 화면에서는 Google Analytics 에 어떤 계정을 사용할꺼냐 묻는데 어자피 하나밖에 없습니다. Defualt Account for Firebase 를 선택해주세요.\n그리고 프로젝트 생성을 누르면 잠시 로딩을 하고 프로젝트 내부화면으로 넘어가게 됩니다.\nXcode 프로젝트와 연동하기 최초로 Firebase 에서 프로젝트를 만든 경우에는 저하고 화면이 조금 다를 수 있지만 별로 어려운 부분은 없으니 잘 넘어오셔서 아래와 같은 화면에서 iOS 를 클릭해주세요. 우리는 iOS 앱을 개발하는 것이므로 iOS 를 선택하는 것입니다 ㅎㅎ\n이제 드디어 Xcode 프로젝트의 Bundle Identifier 가 필요한 시점이 왔어요. 가장 첫 텍스트필드에 값을 넣어주고 Register App 을 눌러줍니다.\n그리고 이제 다음 화면에서 GoogleService-Info.plist 을 다운받아주세요.\n그리고 다운받은 파일을 Xcode 프로젝트에 드래그해서 아래 이미지처럼 옮겨줍니다.\n이때 알림창이 하나 뜨게되는데 꼭 첫번째 칸을 체크해주세요. Xcode 프로젝트의 폴더 내부로 실제 plist 파일을 복사한다는 의미입니다.\n다시 Firebase 홈페이지로 돌아와서 Next 를 누르면 이제 CocoaPods 을 통해 Firebase 사용에 필요한 파일들을 다운로드 받으라고 안내합니다.\nXcode 프로젝트 폴더 내의 Podfile 에 pod \u0026lsquo;Firebase\u0026rsquo; 을 입력해주세요. 여기서 막히는 분들은 위의 CocoaPods 튜토리얼을 참고해주세요.\npod \u0026#39;Firebase\u0026#39; 이렇게 CocoaPods 설치를 마쳤다면 다시 Next 를 눌러줍니다. 이제 Xcode 프로젝트의 Appdelegate 에서 우리가 필수적으로 작업해야 할 내용들을 안내하고 있네요.\n더 이상 xcodeproj 파일은 사용할 수 없으므로 xcworkspace 파일을 열고 새롭게 생긴 파일들을 잘 인식할 수 있돌고 빌드를 한번 해줍니다.\n그리고 프로젝트 상단에 Firebase 를 import 해보면 오류없이 잘 인식하는 것을 확인할 수 있습니다.\nimport Firebase 그리고application(didFinishLaunchingWithOptions)함수 내부에 FirebaseApp.configure() 코드를 구현해줍니다.\nfunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -\u0026gt; Bool { FirebaseApp.configure() return true } 다시 Firebase 홈페이지에서 Next 를 누르면 이런 화면이 뜨게되는데 이제 Xcode 에서 앱을 한번 실행합니다.\n혹시라도 FirebaseApp.configure() 을 찾을 수 없다고 오류가 뜨는 분이 있다면 Xcode 를 먼저 껏다 켜주시고 그래도 안된다면 아래 코드를 추가로 import 해보세요.\nimport FirebaseCore 그리고 Firebase 가 정상적으로 연결되었다면 Xcode 콘솔에서 다음과 비슷한 메세지를 확인할 수 있습니다.\n시뮬레이터가 실행되고 조금 기다리다보면 이렇게 초록색 안내가 뜨며 아래 버튼들이 활성화되는데 만약 아무리 기다려봐도 로딩이 끝나지 않는다면 그냥 넘어가도 아무문제 없습니다.\n계속 이 화면에서 넘어가지지 않는다면 Skip this page 를 눌러 다음 화면으로 넘어가주세요. 전혀 문제없습니다.\n자 이것으로 Firebase 연동을 완전히 끝냈습니다.\n개인 앱을 만드는 분들은 앞으로 많은 곳에서 Firebase 를 사용하게 될 수 있으니까 지금 이 과정은 눈감고도 할 수 있을만큼 익숙하게 알아두시는 것을 추천합니다!\n","permalink":"https://kasroid.github.io/posts/ios/20200810-firebase-importing-to-xcode-project/","summary":"본 포스팅은 이하 버전을 기준으로 작성되었습니다.\n· Firebase 6.29.0\n· Swift 5.2.4\nIntro Firebase 한 번쯤 들어보지 않으셨나요? 초보 개발자가 모바일 앱을 개발하고 개인 앱 서버를 운영하는데 있어 빠질 수 없는 것이 Firebase 가 아닐까 합니다. 속도에 조금 불만이 있긴 하지만 사실 백엔드를 모르는 개발자가 이렇게 쉽고 간편하게 회원가입부터 데이터 관리까지 할 수 있는 서버를 그것도 일정수준까지는 무료로 운영할 수 있게 해주는 서비스가 또 어디있을까요? 이 서비스가 없었으면 저는 지금 Python 도 같이 배우고 있었을 것 같네요.","title":"Firebase - Xcode 프로젝트와 연동하기"},{"content":" 본 포스팅은 Swift 5.2.4 기준으로 작성되었습니다.\n이번 포스팅에서는 Button 과 List (UIKit 의 UITableView 와 동일) 를 생성하는 방법을 공부해보도록 할게요. SwiftUI 에서는 Button 과 List 를 구현하는 코드도 단 몇 줄이면 충분합니다. 이게 다 오토레이아웃이 자동 적용되서 그런것 같아요.\nButton 이전에 공부할 때 Text 가 View 라고했었으니까 Button 도 당연히 View 의 일종일거라 생각하고 따로 찾아보진 않으려고 했거든요? 근데 그래도 공식문서를 한번쯤 보는게 예의가 아닐까 싶어 찾아보니 View 가 아니였습니다. 안찾아봤으면 어쩔뻔!\nButton 자체는 View 가 아니라 Control 이더라고요. 다만 Button 내의 Label 이 Generic 타입으로 구현되어 있고 이 Label 이 View 로 인식이 되는 형태입니다. 뭐 그래서 결국 Button 이 View 의 일종이 되는거긴 하지만 공식문서의 구분에서 control 로 구분하고 있어요.\n버튼 생성은 Text 처럼 parenthesis(괄호) 안에 원하는 타이틀을 입력하고 brace(중괄호) 안에 버튼이 눌렸을 때 동작하기 원하는 코드를 작성하면 됩니다. 일단 우리는 버튼이 잘 동작하는지만 확인하면 되니까 버튼이 눌리면 \u0026ldquo;Button Pressed\u0026rdquo; 가 print 되는 코드를 구현해보록 하겠습니다.\nvar body: some View { Button(\u0026#34;Button\u0026#34;) { print(\u0026#34;Button Pressed\u0026#34;) } } 아래 결과를 보면 이번에도 코드 단 몇 줄만으로 Button 이 중앙에 잘 표시되고 있죠?\nPreview 에서는 단순히 Button 의 위치를 확인하는 것 뿐 아니라 어떤 입력을 받을 때 특정 코드가 실행되는 것을 확인할 수 있습니다.\n그렇다고 바로 누르면 되는건 아니고 Preview 를 기준으로 우측 하단에 위치한 두 개의 버튼 중 첫번째 버튼인 Live Preview 를 우클릭하면 좌측 이미지와 같은 창이 하나 뜨는데 이 중 두번째 메뉴인 Debug Preview 를 클릭해 봅시다.\n잠시 로딩을 기다린 뒤 정상적으로 Debug Preview 가 활성화 된 상태에서 버튼을 눌러보면!! Button 액션으로 구현된 print 까지 console 에 printing 되는 것을 확인할 수 있습니다.\n여기서 추가적으로 궁금증이 생겼는데 Preview 에서 Animation 까지 확인해 볼 수 있는 건지 궁금해졌어요. 이렇게 button action 까지 실행되는 것 보면 가능할 것 같기도 하고요 ㅎㅎㅎ 하지만 오늘은 기초적인 것들만 알아볼거니까 추가로 확인해보진 않을거에요 ㅎ\n대신 버튼에 텍스트말고 이미지와 SF Symbol 을 넣을 수 있는 방법을 알아보도록 할게요.\nHStack 을 사용해 Button 2개를 가로로 배치하고 첫번째 버튼에는 SwiftUI 이미지를, 두번째 버튼에는 SF Symbol \u0026ldquo;play.circle\u0026rdquo; 아이콘을 넣었어요.\n주의해야할 점 하나가 있는데 SwiftUI 에서는 Button 이미지의 renderingMode 기본 값이 .template 으로 되어 있어 다운로드 받은 이미지의 경우 .original 로 변경을 해주어야 이미지가 정상적으로 보이게됩니다. SFSymbol 을 삽입한 경우에는 오히려 기본값이 .template 이라 별 다른 추가작업 없이도 색상이 변경가능하지만요!\nvar body: some View { HStack(spacing: 20) { Button(action: { print(\u0026#34;Button 1\u0026#34;) }) { Image(\u0026#34;SwiftUI\u0026#34;) .renderingMode(.original) .resizable() .frame(width: 120, height: 120) } Button(action: { print(\u0026#34;Button 1\u0026#34;) }) { Image(systemName: \u0026#34;play.circle\u0026#34;) .imageScale(.large) .font(.largeTitle) } .accentColor(.green) } } 위 코드를 입력하면 다음과 같은 결과를 확인해 볼 수 있습니다. 참고로 .accentColor 는 UIKit 의 tintColor 의 역할을 대신하며 색상을 바꿔주는 코드에요. 지금은 .green 을 적용해서 오른쪽 play.circle 이미지가 초록색으로 변했습니다.\nList List 가 뭘까요? UIKit 에서는 없던 이름이에요. UITableView 가 SwiftUI 에서 List 라는 이름으로 완전히 바뀌었습니다. 왜 굳이 Table 이 아니라 List 라고 했는지는 조금 의아하지만 아무튼 List 도 직관적이고 좋은 것 같아요 ㅎㅎ 근데 이러면 아직 SwiftUI 로는 지원되지 않는 UICollectionView 이름은 어떻게 정해질지 궁금해지네요.\n위에서 Button 공식 문서를 봤더니 버튼 자체는 control 이지만 버튼 내부의 Label 이 View 타입이었던 것 기억하시죠? 이처럼 List 자체는 다른 타입이지만 내부의 어떤 것 때문에 View 로 인정되는 것 수 있을 것 같다는 의심이 들어 공식문서를 먼저 살펴보았습니다.\n역시나!! List 는 View 가 아니라 data 를 row 의 형태로 나타낼 수 있는 container라고 하네요. 그럼 body 가 어떻게 View 로 받을 수 있느냐\u0026hellip; 위 스크린샷에서 Generic 타입으로 SelectionValue 랑 Content 2가지가 있는걸 확인할 수 있는데요. 짤려서 보이지 않지만 이 중 content 가 View 타입입니다.\n그럼 List 를 생성해볼게요.\nvar body: some View { List{ Text(\u0026#34;1\u0026#34;) } } 네 이게 끝입니다. 정말로 List 가 생성이 되었다구요! UITableView 를 만들어보신 분들은 이게 얼마나 놀랍도록 간단한건지 느낄거에요!!\n이전에 없던 옅은 선들이 보이시죠? 이게 바로 List 입니다. List 역시 Button 과 같은 방법으로 Preview 에서 스크롤을 실험해 볼 수 있습니다.\n그런데 그냥 이렇게 빈 칸으로 두면 허전하니까 각 줄에 데이터를 몇가지 넣어보도록 할게요. List brace 안쪽으로 원하는 View 를 구현하면 각 instance 가 순서대로 List 의 row 에 추가되게 됩니다. 한번 확인해볼까요?\nvar body: some View { List { Text(\u0026#34;List\u0026#34;).font(.largeTitle) Image(\u0026#34;SwiftUI\u0026#34;) Circle().frame(width: 100, height: 100) Color(.red).frame(width: 100, height: 100) } } 위 코드를 입력해보세요.\n정말 그냥 적힌 순서대로 각 instance 가 List 의 row 에 추가됩니다. 다만 최대로 입력할 수 있는 instance 의 갯수는 10개라는거 기억하세요\n당연히 데이터가 10개를 넘더라도 정상적으로 표시할 수 있는 방법이 있습니다.\nvar body: some View { List(0..\u0026lt;100) { Text(\u0026#34;\\($0)\u0026#34;) } } 위 코드를 입력해보세요. 이런식으로 원하는 데이터를 마음껏 넣어줄 수 있습니다.\n마지막으로 UITableView 하면 빼놓을 수 없는 것 중 Header 와 Footer 가 있었죠? 얘네를 List 에서 추가할 수 있는 방법을 알아보겠습니다.\nList { Section ( header: Text(\u0026#34;Header1\u0026#34;), footer: Text(\u0026#34;Footer1\u0026#34;) ) { Text(\u0026#34;1\u0026#34;) Text(\u0026#34;2\u0026#34;) Text(\u0026#34;3\u0026#34;) Text(\u0026#34;SwiftUI\u0026#34;) } Section ( header: Text(\u0026#34;Header2\u0026#34;), footer: HStack { Spacer(); Text(\u0026#34;Footer2\u0026#34;) } ) { Text(\u0026#34;Section2\u0026#34;) Text(\u0026#34;SwiftUI\u0026#34;) } } .listStyle(GroupedListStyle()) } List 내부에 Section 항목을 먼저 추가하고 header 와 footer 를 입력합니다. 그 다음 brace 를 열어 해당 Section 에 속하는 데이터들을 입력해주면 끝입니다. header 와 footer 는 기본적으로 좌정렬 되어 있으니까 우측에 표시하고 싶을 때는 HStack 을 사용해 Spacer 를 추가한 뒤 Text 를 입력해주면 됩니다.\n추가적으로 .listStyle 이라는 코드가 보이죠? 얘는 GroupedListStyle 또는 DefualtListStyle 중에 선택할 수 있고, 결과에 따라 header 나 footer 가 List 가 스크롤 될 때 함께 스크롤 될지 아니면 남아있을지 설정할 수 있는 옵션입니다. 직접 한번 실험 해보시면 확실히 이해가 되실거에요.\n이렇게 기본적인 List 의 생성 방법을 알아보았어요. UIKit 과 많이 달라진 방식이 아직은 서툴지만 또 쓰다보면 금방 익숙해질거에요. 그러니까 SwiftUI 도 미리미리 같이 공부해보자구요~~\n","permalink":"https://kasroid.github.io/posts/ios/20200802-swiftui-basics-button-list/","summary":"본 포스팅은 Swift 5.2.4 기준으로 작성되었습니다.\n이번 포스팅에서는 Button 과 List (UIKit 의 UITableView 와 동일) 를 생성하는 방법을 공부해보도록 할게요. SwiftUI 에서는 Button 과 List 를 구현하는 코드도 단 몇 줄이면 충분합니다. 이게 다 오토레이아웃이 자동 적용되서 그런것 같아요.\nButton 이전에 공부할 때 Text 가 View 라고했었으니까 Button 도 당연히 View 의 일종일거라 생각하고 따로 찾아보진 않으려고 했거든요? 근데 그래도 공식문서를 한번쯤 보는게 예의가 아닐까 싶어 찾아보니 View 가 아니였습니다.","title":"SwiftUI Basics - Button 과 List 생성하기"},{"content":" 본 포스팅은 Swift 5.2.4 기준으로 작성되었습니다.\nSwiftUI 에서는 자동으로 뷰의 레이아웃을 잡아주는 기능이 매우 강화되면서 Stacks 의 사용이 더 중요해졌습니다. Stack 은 현재 총 3종류가 있으며 HStack, VStack, ZStack 으로 구성됩니다. 함께 공식 개발자 문서를 보려고 했는데 너무 간단하게 나와있어서 의미가 없을 것 같아요 ㅎ 그냥 하나씩 알아보죠 ㅎㅎㅎ\nHStack HStack 은 Horizontal Stack 으로 우리가 뷰를 가로로 배치할 수 있게 도와주는 View 입니다. 사용법도 이보다 쉬울 수가 없어요. 그냥 HStack 을 중괄호로 열고 그 안에 원하는 내용을 넣으면 됩니다. 그러면 각 Object 들이 좌측부터 순서대로 배치가 됩니다.\nHStack { Image(\u0026#34;SwiftUI\u0026#34;) Image(\u0026#34;SwiftUI\u0026#34;) } 따로 레이아웃을 잡은게 없는데도 중앙에 잘 표시가 되네요. 코드 3줄로 뷰를 완성했습니다.\nVStack HStack 이 Horizontal Stack 이라고 했으니까 VStack 은 뭔지 감이 딱 오죠?? 바로 Vertical Stack 이겠네요. 그리고 본인 내부에 위치한 Object 들을 세로로 배치해 줄 것 같습니다. 그럼 기존에 작성해놓은 코드에서 알파벳 하나만 바꿔서 어떻게 되는지 볼까요?\nVStack { Image(\u0026#34;SwiftUI\u0026#34;) Image(\u0026#34;SwiftUI\u0026#34;) } 짜잔!!! 딱 한글자만 바꿨는데 뷰의 구성은 완전히 바뀌었어요.\nZStack HStack 은 가로, VStack 이 세로면 다 끝난 것 같은데 아직 하나가 더 남았어요. ZStack 은 뭐의 줄임말인지 모르겠지만 View 를 위로 쌓는 개념입니다. 아마도 x, y, z 축에서 z 를 뜻하는 의미가 아닌가 싶어요. 이미지가 위로 쌓이게 되면 상태를 확인할 수 없으니까 이번에는 아래쪽에 오는 이미지를 크게 만들어 놓고 해볼게요.\nvar body: some View { ZStack { Image(\u0026#34;SwiftUI\u0026#34;) .resizable() .frame(width: 200, height: 200) Image(\u0026#34;SwiftUI\u0026#34;) } } 코드에서 먼저 구현된 Image 가 Preview 에서는 아래쪽에 위치하는 것을 확인할 수가 있네요. 그냥 순서대로 하나씩 올려놓는다고 생각하면 헷갈릴 것도 없고 당연한 개념이기는 합니다.\nSpacer 이렇게 SwiftUI 에 존재하는 3가지 Stack 을 모두 알아보았고 이제 마지막으로 Spacer 에 대해서 알아보도록 할게요.\nSpacer 는 이름에서부터 알 수 있듯 어떤 빈 공간을 만들어줍니다. 이 빈 공간은 다른 Object 의 크기에 Priority 를 두고 그 크기가 변하지 않는 선에서 본인의 크기를 최대한으로 늘리고자하는 성질을 갖고 있습니다. 코드를 조금 바꿔서 Spacer 를 구현해보겠습니다.\nVStack { Image(\u0026#34;SwiftUI\u0026#34;) .resizable() .frame(width: 200, height: 200) Spacer() Image(\u0026#34;SwiftUI\u0026#34;) } 각 이미지가 완전히 멀찌감치 떨어져서 배치되었네요. 이미지의 크기는 유지되었고 그 사이 공간에 Spacer 가 본인의 크기를 최대한으로 키우고 들어왔습니다.\n그렇다면 Spacer 를 두 이미지보다 위쪽에 배치하면 어떻게 될까요? Spacer 의 위치를 코드의 최상위에 배치해보겠습니다.\nVStack { Spacer() Image(\u0026#34;SwiftUI\u0026#34;) .resizable() .frame(width: 200, height: 200) Image(\u0026#34;SwiftUI\u0026#34;) } 이미지들이 아래로 몰려버렸네요. 하지만 역시 이미지의 크기는 유지시킨채 Spacer 가 늘어날 수 있는 최대한의 크기만큼 늘어난 것을 확인할 수 있습니다.\nSpacer 는 이렇게 본인을 빈 공간에 맞게 최대한 늘어나는 성질을 갖고 있습니다. 아직은 어떻게 활용할 수 있을지 감이 오지 않지만 그 활용도가 무궁무진할 것 같다는 생각이 따~악 드네요! Stacks 와 Spacer 를 완벽히 이해하고 사용한다면 거의 웬만한 모든 뷰들은 손쉽게 만들어 낼 수 있을 것 같습니다!\n","permalink":"https://kasroid.github.io/posts/ios/20200731-swiftui-basics-stacks-spacer/","summary":"본 포스팅은 Swift 5.2.4 기준으로 작성되었습니다.\nSwiftUI 에서는 자동으로 뷰의 레이아웃을 잡아주는 기능이 매우 강화되면서 Stacks 의 사용이 더 중요해졌습니다. Stack 은 현재 총 3종류가 있으며 HStack, VStack, ZStack 으로 구성됩니다. 함께 공식 개발자 문서를 보려고 했는데 너무 간단하게 나와있어서 의미가 없을 것 같아요 ㅎ 그냥 하나씩 알아보죠 ㅎㅎㅎ\nHStack HStack 은 Horizontal Stack 으로 우리가 뷰를 가로로 배치할 수 있게 도와주는 View 입니다. 사용법도 이보다 쉬울 수가 없어요. 그냥 HStack 을 중괄호로 열고 그 안에 원하는 내용을 넣으면 됩니다.","title":"SwiftUI Basics - Stacks 와 Spacer 사용하기"},{"content":" 본 포스팅은 Swift 5.2.4 기준으로 작성되었습니다.\n이번 포스팅에서는 Text, Image, Stack, Button, List 를 SwiftUI 환경에서 생성하는 법을 간단하게 알아보도록 하겠습니다. SwiftUI 의 코드가 얼마나 간결해졌냐면 저 instance 들을 생성하기 위해 우리가 알아야하는 단어는 정말 저게 끝이에요. 저 단어들과 괄호를 조합하여 간단하게 instance 를 생성할 수 있습니다. 레이아웃도 자동으로 잡아주고요!\nText 텍스트를 생성하는 법은 Xcode 를 실행하자마자 바로 알 수 있습니다. 기본적으로 \u0026ldquo;Hello World\u0026rdquo; 가 써져있으니까요.\n그럼 텍스트를 표시하기 위해 필요한 과정을 UIKit 과 한번 비교해볼까요? UIKit 에서는 UILabel 을 생성하고 생성된 instance 에 원하는 텍스트를 붙이고 View 에 올린 다음 레이아웃까지 따로 잡아줘야 하잖아요? 그런데 이 모든 과정이 SwiftUI 에서는 Text(\u0026ldquo;Hello World\u0026rdquo;) 한 문장으로 끝납니다. 🙀\n그럼 이제 조금 더 깊게 들어가볼게요. 다음 코드를 같이 살펴봅시다.\nimport SwiftUI struct ContentView: View { var body: some View { Text(\u0026#34;Netflix\u0026#34;) .font(.custom(\u0026#34;AppleGothic-bold\u0026#34;, size: 50)) .foregroundColor(.red) .kerning(5) } } struct ContentView_Previews: PreviewProvider { static var previews: some View { ContentView().preferredColorScheme(.dark) } } Text 로 화면에 Netflix 가 표시되도록 구현했고 추가로 폰트 종류와 색상, 자간 크기도 조절을 했습니다. UIKit 에서는 이런 세부 조절과정을 method 를 사용해 진행했다면, SwiftUI 에서는 modifier 를 사용해 조절한다고 표현합니다. 내부적으로 구현되는 방법이 달라지고 적용 순서가 더 중요해졌지만 결과적으로 코드 내에서 맡는 역할은 method 와 modifier 가 비슷합니다. 일단은 거의 같다고 생각하면 될 것 같아요\nPreview 에서 텍스트는 좌측 이미지와 같이 표시됩니다. 이쯤되면 웬만한 개발환경에서 처음에 Hello Wolrd Print 찍고 Console 에서 입력된 내용 확인하는 것과 비슷한 난이도가 아닐까 싶어요. 이보다 더 쉬워질 수가 있을까요?\n마지막으로 PreviewProvider 부분에서 .preferredColorScheme(.dark) 를 지정해놓고 실제 넷플릭스 화면처럼 배경을 어둡게 만들어줬어요. 다만 이건 실제 배경이 검은색으로 변한게 아니라 단순히 다크모드가 적용된 것이니까 light 모드에서도 검은 화면을 만드려면 다른 방법을 써야합니다. 이건 나중에.\nImage 이미지를 넣는 방법도 정말 간단합니다. 먼저 준비된 이미지를 Preview Assets.xcassets 에 드래그 해서 붙여 넣습니다. 저는 이미지의 크기가 큰 편이라 3x 에 넣었어요. 작은 이미지를 준비했다면 1x 에 넣어주세요.\n그러고보니 위 폴더도 UIKit 에 없던거에요. 이곳은 개발 중에만 사용하게되는 이미지를 넣어두는데 사용된다고 하네요. 기존부터 사용해 익숙한 Assets.xcassets 폴더에 넣어도 전혀 문제 없습니다.\n아래 코드를 입력하면 이미지가 Preview 에 이미지가 생성됩니다.\nvar body: some View { Image(\u0026#34;SwiftUI\u0026#34;) } 이미지를 넣는 것도 단 한줄로 끝났어요.\n다만 Image 의 Attributes 를 조절해야할 때 반드시 알아야하는 부분이 있어요. 이미지에 frame 을 늘리고 색상을 넣어볼게요.\nvar body: some View { Image(\u0026#34;SwiftUI\u0026#34;) .frame(width: 200, height: 200) .background(Color.green) } 결과를 봅시다. 이미지의 크기는 그대로고 정말로 frame 그 자체만 커졌어요. 보통 우리가 frame 을 늘린다는 것은 이렇게 사용하겠다는 의미가 아니잖아요? 그럼 이미지를 실제로 크게 만들려면 어떻게 해야할까요?\n간단합니다. .resizable() modifier 한줄만 추가해주면 돼요! 단 순서가 중요합니다. frame 을 먼저 설정해버리면 resizable 을 적용할 수가 없거든요. 왜 그런지 이유를 한번 알아볼까요?\nframe 의 Description 을 살펴보면 반환 타입으로 View 를 돌려준다는 것을 알 수 있습니다. 하지만 우리가 조절하려는 것은 이미지의 크기지 frame 이 아니잖아요? 애초에 View 은 resizable modifier 가 지원되지 않기 때문에 뒤에 넣으면 에러가 발생하기도 하고요~ 아무튼 이러한 이유로 .resizable 이 먼저 입력되어야 합니다. 이제 결과를 보면!!\n정상적으로 이미지 크기가 수정되었습니다!! 어렵지 않죠??\n","permalink":"https://kasroid.github.io/posts/ios/20200731-swiftui-basics-text-image/","summary":"본 포스팅은 Swift 5.2.4 기준으로 작성되었습니다.\n이번 포스팅에서는 Text, Image, Stack, Button, List 를 SwiftUI 환경에서 생성하는 법을 간단하게 알아보도록 하겠습니다. SwiftUI 의 코드가 얼마나 간결해졌냐면 저 instance 들을 생성하기 위해 우리가 알아야하는 단어는 정말 저게 끝이에요. 저 단어들과 괄호를 조합하여 간단하게 instance 를 생성할 수 있습니다. 레이아웃도 자동으로 잡아주고요!\nText 텍스트를 생성하는 법은 Xcode 를 실행하자마자 바로 알 수 있습니다. 기본적으로 \u0026ldquo;Hello World\u0026rdquo; 가 써져있으니까요.\n그럼 텍스트를 표시하기 위해 필요한 과정을 UIKit 과 한번 비교해볼까요?","title":"SwiftUI Basics - Text 와 Image 생성하기"},{"content":" 본 포스팅은 Swift 5.2.4 기준으로 작성되었습니다.\nSwiftUI 에서 사용자가 확인할 화면을 생성하는 것은 UIKit 과 다르게 확연히 간단해졌습니다.\n첫 눈에 바로 들어오는 특징으로는 인스턴스를 생성 시에 더 이상 UI 접두사를 붙이지 않아도 된다는 것이네요. 그리고 내부적으로 바뀐 큰 차이점은 UIKit 의 인스턴스들은 대부분 class 형태로 구성되어있던 것과 다르게 SwiftUI 의 인스턴스들은 대부분 struct 형태로 구현되어있습니다.\n그럼 프로젝트를 생성하고 달라진 점들을 직접 살펴보는 것이 좋겠어요. 프로젝트 생성 시 User Interface 를 SwiftUI 로 설정하고 시작하게 되면 다음과 같은 화면이 보입니다.\n우측 상단에 위치한 Resume 버튼을 누르거나 Command + Option + P 를 누르면 SwiftUI 의 핵심기능 중 하나인 Preview 를 활성화 시킬 수 있습니다. 활성화가 정상적으로 되었다면 아이폰 화면 위에 \u0026ldquo;Hello World\u0026rdquo; 가 출력된 것을 볼 수 있습니다. 놀랍지 않나요?\n기존 Storyboard 처럼 단순히 Layout 을 생성 및 확인하는 것뿐만 아니라 실시간으로 코드와 반응하며 UI 가 변화합니다. 다음 포스트에서 함께 보겠지만 심지어 버튼을 눌러 Print 까지 출력이 가능합니다. Wow\nView 그럼 이제 코드를 한번 살펴볼게요.\nimport SwiftUI struct ContentView: View { var body: some View { Text(\u0026#34;Hello, World!\u0026#34;) } } struct ContentView_Previews: PreviewProvider { static var previews: some View { ContentView() } } UIKit 과 달라도 너무 다르네요. 하지만 저는 위에서 본 Preview 의 성능에 감동을 받은 상태이니 새로운 것을 배울 마음의 준비가 되었습니다. 첫 줄을 보면 ContentView 는 View 를 상속받고 있습니다. 왠지 UIView 와 익숙할 것 같지만 혹시 모르니까 무엇인지 한번 알아보도록 하죠. 불과 3개월 전 처음 iOS 개발을 배우기 시작했을 때는 이 문서 보는게 정말 싫었습니다. 봐도 뭐가 뭔지 모르겠고 그냥 다른 블로그 찾아보는게 더 빠르고 쉬웠었거든요. 물론 지금도 이 문서 읽는 것만으로는 사용법을 완전히 익히기에는 부족하지만 그래도 모르는 것이 나타나면 일단 무조건 공식문서부터 찾아보는 습관을 들이고 있습니다. 계속 익숙해지려고 노력하니 조금씩 문서의 구성이나 읽는 방법을 알아가는 것 같아요. 좋은 iOS 개발자가 되려면 그 무엇보다 이 화면과 친해져야 할 것 같아요.\n아무튼!! 충격적인게 View 가 Class 도 아니고 Struct 도 아닌 Protocol 이었어요. 아니 어떻게 Protocol 을 저런식으로 사용하지? 근데 또 곰곰히 생각해보면 ContentView 가 Struct 잖아요? 그럼 상속을 받지 못하는게 당연하니 Protocol 일 수 밖에 없었네요. UIKit 의 사용법에만 익숙한 상태라 생소하지만 아무튼 View 는 Protocol 이에요.\nProtocol 을 채택했다는건 무언가 필수로 구현해야하는게 있을 수도 있다는 소리잖아요? 그게 바로 저 body 부분입니다. body 부분은 computed property 의 형태로 되어있고 some View 타입을 return 받아야 한다고 알려주고 있어요. 지금 당장 some View 가 무엇인지 전부 파헤치기는 어려우니 뭐가 되었든 View 의 종류들이면 다 괜찮아라고 이해하고 넘어갈게요.\nbody 의 return 값이 View 의 종류라면 괜찮다고 했는데 Text(\u0026ldquo;Hello World\u0026rdquo;) 부분이 오류가 나지않고 정상적으로 Preview 에 표시되었으니까 Text 도 View 의 일종이라는 것입니다. 확실하지 않으니까 이번에도 개발자 문서를 한번 보고 넘어가볼게요.\n좌측 상단을 잘 보시면 Views and Controls 라고 적혀있죠? 즉 Text 는 View 나 Control 중 하나라는 뜻입니다. 그리고 설명을 보면 \u0026ldquo;A view that displays one or more lines of read-only text\u0026rdquo; 라고 명시하고 있습니다. 읽기 전용으로 쓸 수 있는 텍스트를 표시하는 View 라고 하네요. 상속을 받지도 Protocol 을 채택한 것도 아닌 것이 어떻게 View 로 구분될 수 있는건지는 잘 모르겠지만 공식 문서에서 View 라고 하니 일단 그렇게 알고 넘어가도록 합시다.\nPreviewProvider 이제 두번째 문단을 살펴보도록 할게요.\nstruct ContentView_Previews: PreviewProvider { static var previews: some View { ContentView() } } 또 생소한 것들 투성입니다. 뭔지 모르겠으니까 제일 먼저 등장하는 PreviewProvider 를 찾아봅시다.\n이번에도 Protocol 입니다. 어느새 조금 당연해졌죠??\nXcode 에서 previews 를 생성하는 타입이라고 하네요. 정확히는 모르겠지만 우측의 Preview 에 관여하는 코드인 것은 확실합니다. 하지만 이것만으로는 조금 부족한 것 같으니까 PreviewProvider 가 어떤 방식으로 만들어진건지 내부 코드를 봐야할 것 같아요.\n@available(iOS 13.0, OSX 10.15, tvOS 13.0, watchOS 6.0, *) public protocol PreviewProvider : _PreviewProvider { /// The type of the previews variable. associatedtype Previews : View /// Generates a collection of previews. /// /// Example: /// /// struct MyPreviews : PreviewProvider { /// static var previews: some View { /// return Group { /// GreetingView(\u0026#34;Hello\u0026#34;), /// GreetingView(\u0026#34;Guten Tag\u0026#34;), /// /// ForEach(otherGreetings, id: \\.self) { /// GreetingView($0) /// } /// } /// .previewDevice(\u0026#34;iPhone X\u0026#34;) /// } /// } static var previews: Self.Previews { get } /// Returns which platform to run the provider on. /// /// When `nil`, Xcode infers the platform based on the file the /// `PreviewProvider` is defined in. This should only be provided when the /// file is in targets that support multiple platforms. static var platform: PreviewPlatform? { get } } Property 로 previews 와 platform 을 갖고 있어요. 오늘은 충분히 많은 새로운 내용을 배웠으니 platform 은 다음에 알아보는 것으로 하고 이번에는 previews 만 살펴보도록 할게요. 사용 예시가 나와있네요.\nGroup 으로 View 들을 묶어 여러개를 표시할 수도 있고 .previewDevice modifier 를 사용해 표시되는 기기를 바꿔줄 수 도 있나봅니다. 이곳에 나와있지는 않지만 여러개의 previews 를 만들어 놓고 하나는 light 다른 하나는 dark 모드로 UI 를 확인해가며 작업하는 것도 가능합니다.\n이렇게 SwiftUI 를 시작하는데 있어 가장 기초적인 부분들을 훌어보았는데요. 다음 포스트에서는 SwiftUI 에 여러가지 View 를 추가하는 방법을 알아보도록 하겠습니다.\n","permalink":"https://kasroid.github.io/posts/ios/20200730-swiftui-basics-create-project-analyze-code/","summary":"본 포스팅은 Swift 5.2.4 기준으로 작성되었습니다.\nSwiftUI 에서 사용자가 확인할 화면을 생성하는 것은 UIKit 과 다르게 확연히 간단해졌습니다.\n첫 눈에 바로 들어오는 특징으로는 인스턴스를 생성 시에 더 이상 UI 접두사를 붙이지 않아도 된다는 것이네요. 그리고 내부적으로 바뀐 큰 차이점은 UIKit 의 인스턴스들은 대부분 class 형태로 구성되어있던 것과 다르게 SwiftUI 의 인스턴스들은 대부분 struct 형태로 구현되어있습니다.\n그럼 프로젝트를 생성하고 달라진 점들을 직접 살펴보는 것이 좋겠어요. 프로젝트 생성 시 User Interface 를 SwiftUI 로 설정하고 시작하게 되면 다음과 같은 화면이 보입니다.","title":"SwiftUI Basics - 프로젝트 생성 및 기본제공 코드 분석"},{"content":"google-site-verification: google66ca37733946af8a.html","permalink":"https://kasroid.github.io/google66ca37733946af8a/","summary":"google-site-verification: google66ca37733946af8a.","title":""},{"content":"naver-site-verification: naver4322329b60b9ef8fa8632e9af72cd83b.html","permalink":"https://kasroid.github.io/naver4322329b60b9ef8fa8632e9af72cd83b/","summary":"naver-site-verification: naver4322329b60b9ef8fa8632e9af72cd83b.","title":""}]