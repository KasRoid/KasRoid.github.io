<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Concurrency - Async, Await, 그리고 Task 알아보기 | SDY - Developer Kas</title><meta name=keywords content="Concurrency,Async/Await"><meta name=description content="본 포스팅은 다음 버전을 기준으로 작성되었습니다.
iOS 15.6 Swift 5.6.1 Xcode 13.4.1 Intro 이번에 함께 공부하려고 들고 온 주제는 대망의 async / await 입니다. 이전 포스팅에서 얘기했었지만 원래는 GCD 와 관련된 내용을 먼저 작성하려고 했었어요. 근데 마음이 바뀌었습니다 ㅎㅎ
왜냐? 일단 최근에 Async, Await 을 공부할 필요성이 생겼어요. 그래서 공부를 하다보니 아직까지 우리나라에 마음에 드는 포스트가 없더라고요?
네 저도 Async, Await 참 좋아하는데요. 그렇다면 제가 한번 작성해 보겠습니다. 개드립 그만"><meta name=author content="Doyoung Song"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9464825723074024" crossorigin=anonymous></script>
<link rel=canonical href=https://kasroid.github.io/posts/ios/20220731-concurrency-async-await-task/><meta name=google-site-verification content="43_MOEW0diGtfoxWtXZ65iT24CFf_i63QMcMBiLkAUs"><link crossorigin=anonymous href=/assets/css/stylesheet.4dac38ca9863d46d0c6ccf5a89829d7b6d35bf0380185246fd6ba26a1140e6b7.css integrity="sha256-Taw4yphj1G0MbM9aiYKde201vwOAGFJG/WuiahFA5rc=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://kasroid.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://kasroid.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://kasroid.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://kasroid.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://kasroid.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-177150852-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Concurrency - Async, Await, 그리고 Task 알아보기"><meta property="og:description" content="본 포스팅은 다음 버전을 기준으로 작성되었습니다.
iOS 15.6 Swift 5.6.1 Xcode 13.4.1 Intro 이번에 함께 공부하려고 들고 온 주제는 대망의 async / await 입니다. 이전 포스팅에서 얘기했었지만 원래는 GCD 와 관련된 내용을 먼저 작성하려고 했었어요. 근데 마음이 바뀌었습니다 ㅎㅎ
왜냐? 일단 최근에 Async, Await 을 공부할 필요성이 생겼어요. 그래서 공부를 하다보니 아직까지 우리나라에 마음에 드는 포스트가 없더라고요?
네 저도 Async, Await 참 좋아하는데요. 그렇다면 제가 한번 작성해 보겠습니다. 개드립 그만"><meta property="og:type" content="article"><meta property="og:url" content="https://kasroid.github.io/posts/ios/20220731-concurrency-async-await-task/"><meta property="og:image" content="https://kasroid.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-31T10:35:00+09:00"><meta property="article:modified_time" content="2022-07-31T10:35:00+09:00"><meta property="og:site_name" content="SDY - Dev Log"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kasroid.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Concurrency - Async, Await, 그리고 Task 알아보기"><meta name=twitter:description content="본 포스팅은 다음 버전을 기준으로 작성되었습니다.
iOS 15.6 Swift 5.6.1 Xcode 13.4.1 Intro 이번에 함께 공부하려고 들고 온 주제는 대망의 async / await 입니다. 이전 포스팅에서 얘기했었지만 원래는 GCD 와 관련된 내용을 먼저 작성하려고 했었어요. 근데 마음이 바뀌었습니다 ㅎㅎ
왜냐? 일단 최근에 Async, Await 을 공부할 필요성이 생겼어요. 그래서 공부를 하다보니 아직까지 우리나라에 마음에 드는 포스트가 없더라고요?
네 저도 Async, Await 참 좋아하는데요. 그렇다면 제가 한번 작성해 보겠습니다. 개드립 그만"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://kasroid.github.io/posts/"},{"@type":"ListItem","position":3,"name":"iOS","item":"https://kasroid.github.io/posts/ios/"},{"@type":"ListItem","position":4,"name":"Concurrency - Async, Await, 그리고 Task 알아보기","item":"https://kasroid.github.io/posts/ios/20220731-concurrency-async-await-task/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Concurrency - Async, Await, 그리고 Task 알아보기","name":"Concurrency - Async, Await, 그리고 Task 알아보기","description":"본 포스팅은 다음 버전을 기준으로 작성되었습니다.\niOS 15.6 Swift 5.6.1 Xcode 13.4.1 Intro 이번에 함께 공부하려고 들고 온 주제는 대망의 async / await 입니다. 이전 포스팅에서 얘기했었지만 원래는 GCD 와 관련된 내용을 먼저 작성하려고 했었어요. 근데 마음이 바뀌었습니다 ㅎㅎ\n왜냐? 일단 최근에 Async, Await 을 공부할 필요성이 생겼어요. 그래서 공부를 하다보니 아직까지 우리나라에 마음에 드는 포스트가 없더라고요?\n네 저도 Async, Await 참 좋아하는데요. 그렇다면 제가 한번 작성해 보겠습니다. 개드립 그만","keywords":["Concurrency","Async/Await"],"articleBody":" 본 포스팅은 다음 버전을 기준으로 작성되었습니다.\niOS 15.6 Swift 5.6.1 Xcode 13.4.1 Intro 이번에 함께 공부하려고 들고 온 주제는 대망의 async / await 입니다. 이전 포스팅에서 얘기했었지만 원래는 GCD 와 관련된 내용을 먼저 작성하려고 했었어요. 근데 마음이 바뀌었습니다 ㅎㅎ\n왜냐? 일단 최근에 Async, Await 을 공부할 필요성이 생겼어요. 그래서 공부를 하다보니 아직까지 우리나라에 마음에 드는 포스트가 없더라고요?\n네 저도 Async, Await 참 좋아하는데요. 그렇다면 제가 한번 작성해 보겠습니다. 개드립 그만\nPrerequisite 제일 먼저 이 새로운 문법들을 사용하려면 어떤 제약사항이 있는지 알아야 합니다. 확인 없이 프로젝트에 적용했다가 회사의 요구사항과 맞지 않으면 그야말로 낭패니까요. 처음 Async, Await 이 공개되었을 당시 사용에 대한 제약조건은 다음과 같았습니다.\niOS 15, macOS 12, watchOS 8, tvOS 15 엄청 높죠? 최신 OS 가 아니라면 사용할 수 없는 거에요. 그리고 스위프트는 오픈 소스라 다른 플랫폼에서도 사용할 수가 있는데요. 이 때는 스위프트의 버전이 최소 Swift 5.5 이상이어야 합니다.\n하지만 좋은 소식이 있어요. Xcode 13.2 이상에서 프로젝트를 빌드할 경우 이전 OS 에 대한 호환성 지원을 시작했습니다. 즉 제약조건이 낮아졌어요.\niOS 13, macOS 10.15, watchOS 6, tvOS 13 정말 많이 낮아졌죠? 이제 웬만한 상용 프로젝트에도 적용해 볼만 해졌습니다. 그리고 이 제약조건만 넘긴다면 async / await 뿐만 아니라 actors, task API 등 스위프트에 추가된 새로운 모든 기능을 사용할 수 있어요. 하지만 이것은 언어에 대한 완전한 지원이고, 다른 API 들까지 모두 지원된다는 것은 아닙니다. 예를 들어 URLSession 에 추가된 async / await 사용을 도와주는 메서드 data(from:delegate:) 는 사용할 수 없으니까요.\nUsage Example Async, Await 은 사용법이 간단하면서도 의외로 또 파고들면 알아야 할 내용들이 많습니다. 한번에 다 다루기는 어려우니 이번에는 기본적인 사용법을 먼저 공부해 봅시다. 그럼 공식문서에는 뭐라고 나와있는지 한번 볼까요?\n왜 async / await 이 아닌 Task를 찾았냐고요?\n바로 async / await 이 결국 Task 를 처리하기 위함이기 때문입니다. 결국 핵심은 Task 라는 것이죠. 그리고 이 Task 는 문서에 나와있듯 비동기적인 작업에 대한 단위입니다. 이제 Task 하면 비동기적인 작업이겠구나를 연상시켜 보세요.\n그럼 이제 실제 코드로 구현을 하며 익숙해지도록 해보겠습니다. 먼저 기존에 우리가 사용하던 방식인 @escaping 을 통해 completionHandler 에 함수의 외부에서 클로저를 전달하는 CallBack 스타일로 비동기 작업을 처리하도록 구현하여 문제점을 파악해보고, 다음으로 새로운 방식인 async / await 을 사용해 구현함으로서 Callback 스타일에서 제기된 문제점들이 어떻게 해결되는지 알아보겠습니다.\n공통 부분 먼저 비동기 처리 방식에 관계없이 공통으로 사용되는 부분들을 구현하겠습니다.\nlet url = URL(string: \"https://api.quotable.io/random\") 랜덤한 글귀를 가져오는 API 에요. 제한없이 자유롭게 사용할 수 있으니, 여러분도 그냥 복사해서 사용하시면 됩니다 ㅎㅎ 다음으로 통신 중 에러 발생 시 사용할 NetworkError 를 구현하겠습니다.\nenum NetworkError: Error { case badUrl case badResponse case communicationError case decodeFailed case noData } 마지막으로 API 에서 JSON 형식으로 전달 받으므로 받은 데이터를 처리할 수 있는 Decodable struct 를 구현하였습니다.\nstruct Quote: Decodable { let content: String } 네 이렇게 공통적으로 사용될 부분을 모두 구현했어요. 여기까진 새로운 내용이 없었는데요. 이제부터 코드가 달라집니다. 먼저 우리에게 익숙한 CallBack 스타일로 비동기 작업을 처리해 볼게요.\nCallBack 익숙한 코드이므로 추가적인 설명은 하지 않겠습니다.\nfunc getQuote(from url: URL?, completion: @escaping (Result\u003cQuote, NetworkError\u003e) -\u003e Void) { guard let url = url else { completion(.failure(.badUrl)) return } URLSession.shared.dataTask(with: url, completionHandler: { data, response, error in if let error = error { completion(.failure(.communicationError)) print(error) return } if let response = response as? HTTPURLResponse, !(200..\u003c300).contains(response.statusCode) { completion(.failure(.badResponse)) return } guard let data = data else { completion(.failure(.noData)) return } do { let quote = try JSONDecoder().decode(Quote.self, from: data) completion(.success(quote)) } catch { completion(.failure(.decodeFailed)) } }).resume() } 이제 위 코드에 어떤 문제점들이 있는지 고민을 해볼 차례 입니다. 제가 생각하는 문제점은\n각 케이스 별로 적합한 Completion 에 대한 처리가 필요하지만, 실수로 처리를 하지 않더라도 에러가 발생하지 않는다. Completion 에 대한 처리를 모두 정상적으로 진행 했더라도, 이어서 return 을 명시하지 않으면 의도하지 않게 코드가 계속 진행되어 버그가 발생할 수 있고, 역시 어떤 에러도 발생하지 않으므로 디버깅이 까다롭다. 코드가 지저분하다. 이 정도가 있는 것 같습니다. 분명히 정상 작동하는 코드지만 개선할 부분이 많은 코드라는 생각이 드네요. 이제 실행부를 구현해볼까요?\ngetQuote(from: url, completion: { result in switch result { case .success(let quote): print(quote.content) case .failure(let error): print(error) } }) 역시 조금 지저분한 느낌이 듭니다. 콜백 스타일은 필연적으로 코드를 지저분하게 만들 수 밖에 없는 구조인 것 같아요. 그래도 실행해 보면 당연히 정상적으로 잘 작동합니다 :)\nAsync / Await 이번에는 같은 함수를 async / await 을 사용해 구현해 보고 조금 전 제기한 문제점들이 어떻게 해결되었는지 알아볼게요. 먼저 사용할 함수를 정의해 보겠습니다.\nfunc getQuote(from: URL?) async throws -\u003e Quote {} 기존 콜백 스타일에서 Completion 에 해당하는 부분이 없어지고 async 와 throws 가 추가 되었습니다. 그리고 일반적인 함수처럼 우리가 리턴하고자 하는 값에 대한 타입이 추가되었어요.\n생소하지만 어려울 것은 없는 코드입니다. 해석을 하면 async 를 통해 이 함수는 비동기적으로 작동할 것이라는 것을 명시하였고, throws 를 통해 에러가 발생할 수도 있다는 것을 명시한 것 입니다.\n그렇다면 함수의 내부를 구현하면서 어떻게 비동기 작업을 추가하고 에러를 던질 수 있는지 살펴볼게요. 미리 만들어 놓은 URL 을 사용하기 위해 URL 의 옵셔널을 바인딩하는 코드를 추가하겠습니다.\nguard let url = url else { throw NetworkError.badUrl } URL 에서 nil 이 나올 경우 사용할 수 없는 주소이므로 NetworkError.badUrl 을 에러로 던져줍니다. 다음은 API 에 데이터를 요청해 볼게요.\nlet (data, response) = try await URLSession.shared.data(from: url) 뭔가 익숙한 것 같으면서도 처음보는 코드일거에요. URLSession 에 async 한 방식으로 새롭게 추가된 data(from:delegate:) 메서드 입니다. 공식문서를 보면 이 메서드가 async 하게 처리된다는 것을 알 수 있어요.\n잘 생각해보면 우리가 조금 전 정의한 getQuote 함수와 비슷합니다. 우리는 아직 이 함수를 사용해 본 적이 없지만 이렇게 async 한 함수를 호출하려면 반드시 await 키워드를 함수 호출부 앞에 붙임으로서 비동기하게 처리될 것임을 명시해 주어야 하는 것 이에요. 이게 바로 새롭게 추가된 async / await 문법입니다.\n리턴값으로는 (Data, URLResponse) 형태의 튜플을 반환하므로 각각 변수를 생성하여 할당해 주었습니다. 이렇게 async / await 을 사용한 처리를 하면 콜백 함수를 사용하지 않아도 해당 변수에 데이터가 있다는 것이 보장됩니다. 즉 변수에 데이터가 들어올 때까지 기다렸다가 다음 코드를 실행한다고 생각하면 됩니다. 이제 HTTPURLResponse 에 대한 처리를 해 볼게요.\nif let response = response as? HTTPURLResponse, !(200..\u003c300).contains(response.statusCode) { throw NetworkError.badResponse } Response 에 문제가 있다면 NetworkError.badResponse 를 던지게 됩니다. 이제 JSON 을 디코드하고 나온 값을 리턴하는 코드를 작성할게요.\nguard let quote = try? JSONDecoder().decode(Quote.self, from: data) else { throw NetworkError.decodeFailed } return quote 중간에 await 처리가 된 부분을 제외하면 기존 코드와 크게 다르지 않습니다. 완성된 코드를 볼까요?\nfunc getQuote(from: URL?) async throws -\u003e Quote { guard let url = url else { throw NetworkError.badUrl } let (data, response) = try await URLSession.shared.data(from: url) if let response = response as? HTTPURLResponse, !(200..\u003c300).contains(response.statusCode) { throw NetworkError.badResponse } guard let quote = try? JSONDecoder().decode(Quote.self, from: data) else { throw NetworkError.decodeFailed } return quote } 훨씬 간결한 느낌이 듭니다. 그럼 async / await 을 사용하면 CallBack 스타일로 처리했을 때 발생하는 문제점들이 어떻게 해결되었는지 살펴볼게요.\n먼저 각 케이스에 따른 Completion 을 처리하는 작업이 없어졌습니다. 즉 실수할 가능성이 없어진 것이죠. 그리고 일반적인 함수처럼 특정 값을 리턴하게 만들었기 때문에 만약 우리가 함수 끝부분에 리턴 처리를 잊으면 컴파일러가 우리에게 경고를 발생시킵니다.\n두번째로 Completion 처리 후 return 을 할 필요도 없어졌습니다. 예시에서는 if 를 혼용하여 사용했지만, 전부 guard 로 처리한다면 예외상황에서 throw 처리를 하지 않을 경우 컴파일러가 경고를 하게 됩니다. 역시 실수 발생 가능성이 없어졌습니다. 그렇게 많이 바뀌지 않은 것 같으면서도 핵심적인 문제점들이 전부 해소되었어요.\n그럼 마지막으로 async 함수를 실행해 봅시다.\nTask { do { let quote = try await getQuote(from: url) print(quote.content) } catch { print(error) } } 정상적으로 잘 작동하네요. 실행부 역시 코드의 가독성이 훨씬 좋아지고 길이도 짧아진 것을 확인할 수 있어요.\n드디어 포스트 초반부에 잠깐 보았던 Task 가 등장했네요. 위에서 async 로 만들어진 함수를 호출하려면 문법상 반드시 await 을 명시해 주어야 한다고 했었잖아요? 사실 이 await 을 명시할 수 있는 조건이 크게 두가지가 있었습니다.\nasync 하게 구현된 함수의 내부 Task 의 클로저 내부 이전까지는 async 로 만들어진 함수의 내부에서 await 을 명시했기 때문에 에러가 발생하지 않았던 거에요. 일반적인 함수의 내부에서 async 하게 구현된 함수를 호출하면 에러가 발생하므로, 반드시 Task 클로저의 내부에서 실행해 주어야 합니다.\n또한 Task 는 생성 이후 바로 실행되는 특성을 가지고 있어요. 즉 어떤 함수안에서 Task 를 생성하면, 해당 함수를 호출 할 때 Task 도 같이 실행되며 비동기 작업이 처리되겠죠?\nWrap Up 이렇게 기존 CallBack 스타일에서 async / await 기능을 활용해 기존 함수를 개선하는 방법을 공부해 보았습니다. 이번 포스팅을 작성하면서 async / await 에 많이 익숙해져서 앞으로 completionHandler 는 잘 사용하지 않게 될 것 같아요 ㅎㅎ\n이렇게 보면 우리가 async / await 에 대해 많은 것을 알게 된 것 같지만 사실 오늘 공부한 내용은 정말 일부분 입니다. 앞으로 continuation, async let, Detached Task, Task Group 등 공부해야 할 것들이 많이 남았어요. 함께 하나씩 차근차근 정복해나가 봅시다! 정ㅋ벅ㅋ\nEntire Code Using CallBack import UIKit let url = URL(string: \"https://api.quotable.io/random\") enum NetworkError: Error { case badUrl case badResponse case communicationError case decodeFailed case noData } struct Quote: Decodable { let content: String } func getQuote(from url: URL?, completion: @escaping (Result\u003cQuote, NetworkError\u003e) -\u003e Void) { guard let url = url else { completion(.failure(.badUrl)) return } URLSession.shared.dataTask(with: url, completionHandler: { data, response, error in if let error = error { completion(.failure(.communicationError)) print(error) return } if let response = response as? HTTPURLResponse, !(200..\u003c300).contains(response.statusCode) { completion(.failure(.badResponse)) return } guard let data = data else { completion(.failure(.noData)) return } do { let quote = try JSONDecoder().decode(Quote.self, from: data) completion(.success(quote)) } catch { completion(.failure(.decodeFailed)) } }).resume() } getQuote(from: url, completion: { result in switch result { case .success(let quote): print(quote.content) case .failure(let error): print(error) } }) Using Async / Await import UIKit let url = URL(string: \"https://api.quotable.io/random\") enum NetworkError: Error { case badUrl case badResponse case communicationError case decodeFailed case noData } struct Quote: Decodable { let content: String } func getQuote(from: URL?) async throws -\u003e Quote { guard let url = url else { throw NetworkError.badUrl } let (data, response) = try await URLSession.shared.data(from: url) if let response = response as? HTTPURLResponse, !(200..\u003c300).contains(response.statusCode) { throw NetworkError.badResponse } guard let quote = try? JSONDecoder().decode(Quote.self, from: data) else { throw NetworkError.decodeFailed } return quote } Task { do { let quote = try await getQuote(from: url) print(quote.content) } catch { print(error) } } References Swift - Apple Developer\nWhere is Swift concurrency supported?\n","wordCount":"1594","inLanguage":"en","datePublished":"2022-07-31T10:35:00+09:00","dateModified":"2022-07-31T10:35:00+09:00","author":{"@type":"Person","name":"Doyoung Song"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://kasroid.github.io/posts/ios/20220731-concurrency-async-await-task/"},"publisher":{"@type":"Organization","name":"SDY - Developer Kas","logo":{"@type":"ImageObject","url":"https://kasroid.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kasroid.github.io accesskey=h title="SDY (Alt + H)">SDY</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://kasroid.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://kasroid.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://kasroid.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://kasroid.github.io>Home</a>&nbsp;»&nbsp;<a href=https://kasroid.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://kasroid.github.io/posts/ios/>iOS</a></div><h1 class=post-title>Concurrency - Async, Await, 그리고 Task 알아보기</h1><div class=post-meta><span title='2022-07-31 10:35:00 +0900 KST'>2022-07-31</span>&nbsp;·&nbsp;Doyoung Song</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#intro>Intro</a></li><li><a href=#prerequisite>Prerequisite</a></li><li><a href=#usage-example>Usage Example</a><ul><li><a href=#공통-부분>공통 부분</a></li><li><a href=#callback>CallBack</a></li><li><a href=#async--await>Async / Await</a></li></ul></li><li><a href=#wrap-up>Wrap Up</a></li><li><a href=#entire-code>Entire Code</a><ul><li><a href=#using-callback>Using CallBack</a></li><li><a href=#using-async--await>Using Async / Await</a></li></ul></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><blockquote><p>본 포스팅은 다음 버전을 기준으로 작성되었습니다.</p><ul><li>iOS 15.6</li><li>Swift 5.6.1</li><li>Xcode 13.4.1</li></ul></blockquote><h2 id=intro>Intro<a hidden class=anchor aria-hidden=true href=#intro>#</a></h2><p>이번에 함께 공부하려고 들고 온 주제는 대망의 <code>async / await</code> 입니다. 이전 포스팅에서 얘기했었지만 원래는 GCD 와 관련된 내용을 먼저 작성하려고 했었어요. 근데 마음이 바뀌었습니다 ㅎㅎ</p><p>왜냐? 일단 최근에 Async, Await 을 공부할 필요성이 생겼어요. 그래서 공부를 하다보니 아직까지 우리나라에 마음에 드는 포스트가 없더라고요?</p><p>네 저도 Async, Await 참 좋아하는데요. 그렇다면 제가 한번 작성해 보겠습니다. <del>개드립 그만</del></p><hr><h2 id=prerequisite>Prerequisite<a hidden class=anchor aria-hidden=true href=#prerequisite>#</a></h2><p>제일 먼저 이 새로운 문법들을 사용하려면 어떤 제약사항이 있는지 알아야 합니다. 확인 없이 프로젝트에 적용했다가 회사의 요구사항과 맞지 않으면 그야말로 낭패니까요. 처음 Async, Await 이 공개되었을 당시 사용에 대한 제약조건은 다음과 같았습니다.</p><ul><li><code>iOS 15</code>, <code>macOS 12</code>, <code>watchOS 8</code>, <code>tvOS 15</code></li></ul><p>엄청 높죠? 최신 OS 가 아니라면 사용할 수 없는 거에요. 그리고 스위프트는 오픈 소스라 다른 플랫폼에서도 사용할 수가 있는데요. 이 때는 스위프트의 버전이 최소 Swift 5.5 이상이어야 합니다.</p><p>하지만 좋은 소식이 있어요. <strong>Xcode 13.2</strong> 이상에서 프로젝트를 빌드할 경우 이전 OS 에 대한 호환성 지원을 시작했습니다. 즉 제약조건이 낮아졌어요.</p><ul><li><code>iOS 13</code>, <code>macOS 10.15</code>, <code>watchOS 6</code>, <code>tvOS 13</code></li></ul><p>정말 많이 낮아졌죠? 이제 웬만한 상용 프로젝트에도 적용해 볼만 해졌습니다. 그리고 이 제약조건만 넘긴다면 async / await 뿐만 아니라 <code>actors</code>, <code>task API</code> 등 스위프트에 추가된 새로운 모든 기능을 사용할 수 있어요. 하지만 이것은 언어에 대한 완전한 지원이고, 다른 API 들까지 모두 지원된다는 것은 아닙니다. 예를 들어 <code>URLSession</code> 에 추가된 async / await 사용을 도와주는 메서드 <code>data(from:delegate:)</code> 는 사용할 수 없으니까요.</p><hr><h2 id=usage-example>Usage Example<a hidden class=anchor aria-hidden=true href=#usage-example>#</a></h2><p>Async, Await 은 사용법이 간단하면서도 의외로 또 파고들면 알아야 할 내용들이 많습니다. 한번에 다 다루기는 어려우니 이번에는 기본적인 사용법을 먼저 공부해 봅시다. 그럼 <a href=https://developer.apple.com/documentation/swift/task>공식문서</a>에는 뭐라고 나와있는지 한번 볼까요?</p><p><img loading=lazy src=/ios/Async-Await/Document-Task.png alt="Document Task"></p><p>왜 async / await 이 아닌 <code>Task</code>를 찾았냐고요?</p><p>바로 async / await 이 결국 Task 를 처리하기 위함이기 때문입니다. 결국 핵심은 Task 라는 것이죠. 그리고 이 Task 는 문서에 나와있듯 비동기적인 작업에 대한 단위입니다. 이제 <strong>Task 하면 비동기적인 작업</strong>이겠구나를 연상시켜 보세요.</p><p>그럼 이제 실제 코드로 구현을 하며 익숙해지도록 해보겠습니다. 먼저 기존에 우리가 사용하던 방식인 <code>@escaping</code> 을 통해 completionHandler 에 함수의 외부에서 클로저를 전달하는 CallBack 스타일로 비동기 작업을 처리하도록 구현하여 문제점을 파악해보고, 다음으로 새로운 방식인 async / await 을 사용해 구현함으로서 Callback 스타일에서 제기된 문제점들이 어떻게 해결되는지 알아보겠습니다.</p><h3 id=공통-부분>공통 부분<a hidden class=anchor aria-hidden=true href=#공통-부분>#</a></h3><p>먼저 비동기 처리 방식에 관계없이 공통으로 사용되는 부분들을 구현하겠습니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>let</span> <span class=nv>url</span> <span class=p>=</span> <span class=n>URL</span><span class=p>(</span><span class=n>string</span><span class=p>:</span> <span class=s>&#34;https://api.quotable.io/random&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>랜덤한 글귀를 가져오는 API 에요. 제한없이 자유롭게 사용할 수 있으니, 여러분도 그냥 복사해서 사용하시면 됩니다 ㅎㅎ 다음으로 통신 중 에러 발생 시 사용할 <code>NetworkError</code> 를 구현하겠습니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>enum</span> <span class=nc>NetworkError</span><span class=p>:</span> <span class=n>Error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>badUrl</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>badResponse</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>communicationError</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>decodeFailed</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>noData</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>마지막으로 API 에서 JSON 형식으로 전달 받으므로 받은 데이터를 처리할 수 있는 Decodable <code>struct</code> 를 구현하였습니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>struct</span> <span class=nc>Quote</span><span class=p>:</span> <span class=n>Decodable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nv>content</span><span class=p>:</span> <span class=nb>String</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>네 이렇게 공통적으로 사용될 부분을 모두 구현했어요. 여기까진 새로운 내용이 없었는데요. 이제부터 코드가 달라집니다. 먼저 우리에게 익숙한 <strong>CallBack 스타일</strong>로 비동기 작업을 처리해 볼게요.</p><h3 id=callback>CallBack<a hidden class=anchor aria-hidden=true href=#callback>#</a></h3><p>익숙한 코드이므로 추가적인 설명은 하지 않겠습니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>func</span> <span class=nf>getQuote</span><span class=p>(</span><span class=n>from</span> <span class=n>url</span><span class=p>:</span> <span class=n>URL</span><span class=p>?,</span> <span class=n>completion</span><span class=p>:</span> <span class=p>@</span><span class=n>escaping</span> <span class=p>(</span><span class=n>Result</span><span class=p>&lt;</span><span class=n>Quote</span><span class=p>,</span> <span class=n>NetworkError</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=nb>Void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>guard</span> <span class=kd>let</span> <span class=nv>url</span> <span class=p>=</span> <span class=n>url</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>completion</span><span class=p>(.</span><span class=n>failure</span><span class=p>(.</span><span class=n>badUrl</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>URLSession</span><span class=p>.</span><span class=n>shared</span><span class=p>.</span><span class=n>dataTask</span><span class=p>(</span><span class=n>with</span><span class=p>:</span> <span class=n>url</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                               <span class=n>completionHandler</span><span class=p>:</span> <span class=p>{</span> <span class=n>data</span><span class=p>,</span> <span class=n>response</span><span class=p>,</span> <span class=n>error</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=kd>let</span> <span class=nv>error</span> <span class=p>=</span> <span class=n>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>completion</span><span class=p>(.</span><span class=n>failure</span><span class=p>(.</span><span class=n>communicationError</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=bp>print</span><span class=p>(</span><span class=n>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=kd>let</span> <span class=nv>response</span> <span class=p>=</span> <span class=n>response</span> <span class=k>as</span><span class=p>?</span> <span class=n>HTTPURLResponse</span><span class=p>,</span>
</span></span><span class=line><span class=cl>           <span class=o>!</span><span class=p>(</span><span class=mf>200.</span><span class=p>.&lt;</span><span class=mi>300</span><span class=p>).</span><span class=bp>contains</span><span class=p>(</span><span class=n>response</span><span class=p>.</span><span class=n>statusCode</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>completion</span><span class=p>(.</span><span class=n>failure</span><span class=p>(.</span><span class=n>badResponse</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>guard</span> <span class=kd>let</span> <span class=nv>data</span> <span class=p>=</span> <span class=n>data</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>completion</span><span class=p>(.</span><span class=n>failure</span><span class=p>(.</span><span class=n>noData</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kd>let</span> <span class=nv>quote</span> <span class=p>=</span> <span class=k>try</span> <span class=n>JSONDecoder</span><span class=p>().</span><span class=n>decode</span><span class=p>(</span><span class=n>Quote</span><span class=p>.</span><span class=kc>self</span><span class=p>,</span> <span class=n>from</span><span class=p>:</span> <span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>completion</span><span class=p>(.</span><span class=n>success</span><span class=p>(</span><span class=n>quote</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>catch</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>completion</span><span class=p>(.</span><span class=n>failure</span><span class=p>(.</span><span class=n>decodeFailed</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}).</span><span class=n>resume</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>이제 위 코드에 어떤 문제점들이 있는지 고민을 해볼 차례 입니다. 제가 생각하는 문제점은</p><ul><li>각 케이스 별로 적합한 Completion 에 대한 처리가 필요하지만, 실수로 처리를 하지 않더라도 에러가 발생하지 않는다.</li><li>Completion 에 대한 처리를 모두 정상적으로 진행 했더라도, 이어서 <code>return</code> 을 명시하지 않으면 의도하지 않게 코드가 계속 진행되어 버그가 발생할 수 있고, 역시 어떤 에러도 발생하지 않으므로 디버깅이 까다롭다.</li><li>코드가 지저분하다.</li></ul><p>이 정도가 있는 것 같습니다. 분명히 정상 작동하는 코드지만 개선할 부분이 많은 코드라는 생각이 드네요. 이제 실행부를 구현해볼까요?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=n>getQuote</span><span class=p>(</span><span class=n>from</span><span class=p>:</span> <span class=n>url</span><span class=p>,</span>
</span></span><span class=line><span class=cl>         <span class=n>completion</span><span class=p>:</span> <span class=p>{</span> <span class=n>result</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=n>result</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=p>.</span><span class=n>success</span><span class=p>(</span><span class=kd>let</span> <span class=nv>quote</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>print</span><span class=p>(</span><span class=n>quote</span><span class=p>.</span><span class=n>content</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=p>.</span><span class=n>failure</span><span class=p>(</span><span class=kd>let</span> <span class=nv>error</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>print</span><span class=p>(</span><span class=n>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></div><p>역시 조금 지저분한 느낌이 듭니다. 콜백 스타일은 필연적으로 코드를 지저분하게 만들 수 밖에 없는 구조인 것 같아요. 그래도 실행해 보면 당연히 정상적으로 잘 작동합니다 :)</p><h3 id=async--await>Async / Await<a hidden class=anchor aria-hidden=true href=#async--await>#</a></h3><p>이번에는 같은 함수를 async / await 을 사용해 구현해 보고 조금 전 제기한 문제점들이 어떻게 해결되었는지 알아볼게요. 먼저 사용할 함수를 정의해 보겠습니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>func</span> <span class=nf>getQuote</span><span class=p>(</span><span class=n>from</span><span class=p>:</span> <span class=n>URL</span><span class=p>?)</span> <span class=n>async</span> <span class=kr>throws</span> <span class=p>-&gt;</span> <span class=n>Quote</span> <span class=p>{}</span>
</span></span></code></pre></div><p>기존 콜백 스타일에서 Completion 에 해당하는 부분이 없어지고 <code>async</code> 와 <code>throws</code> 가 추가 되었습니다. 그리고 일반적인 함수처럼 우리가 리턴하고자 하는 값에 대한 타입이 추가되었어요.</p><p>생소하지만 어려울 것은 없는 코드입니다. 해석을 하면 <code>async</code> 를 통해 이 함수는 비동기적으로 작동할 것이라는 것을 명시하였고, <code>throws</code> 를 통해 에러가 발생할 수도 있다는 것을 명시한 것 입니다.</p><p>그렇다면 함수의 내부를 구현하면서 어떻게 비동기 작업을 추가하고 에러를 던질 수 있는지 살펴볼게요. 미리 만들어 놓은 URL 을 사용하기 위해 URL 의 옵셔널을 바인딩하는 코드를 추가하겠습니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=k>guard</span> <span class=kd>let</span> <span class=nv>url</span> <span class=p>=</span> <span class=n>url</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=n>NetworkError</span><span class=p>.</span><span class=n>badUrl</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>URL 에서 <code>nil</code> 이 나올 경우 사용할 수 없는 주소이므로 <code>NetworkError.badUrl</code> 을 에러로 던져줍니다. 다음은 API 에 데이터를 요청해 볼게요.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>let</span> <span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>response</span><span class=p>)</span> <span class=p>=</span> <span class=k>try</span> <span class=n>await</span> <span class=n>URLSession</span><span class=p>.</span><span class=n>shared</span><span class=p>.</span><span class=n>data</span><span class=p>(</span><span class=n>from</span><span class=p>:</span> <span class=n>url</span><span class=p>)</span>
</span></span></code></pre></div><p>뭔가 익숙한 것 같으면서도 처음보는 코드일거에요. <strong>URLSession</strong> 에 <strong>async</strong> 한 방식으로 새롭게 추가된 <code>data(from:delegate:)</code> 메서드 입니다. <a href=https://developer.apple.com/documentation/foundation/urlsession/3767353-data>공식문서</a>를 보면 이 메서드가 async 하게 처리된다는 것을 알 수 있어요.</p><p><img loading=lazy src=/ios/Async-Await/Document-URLSession-Data.png alt="Document URLSession Data Method"></p><p>잘 생각해보면 우리가 조금 전 정의한 <code>getQuote</code> 함수와 비슷합니다. 우리는 아직 이 함수를 사용해 본 적이 없지만 이렇게 <strong>async</strong> 한 함수를 호출하려면 반드시 <code>await</code> 키워드를 함수 호출부 앞에 붙임으로서 비동기하게 처리될 것임을 명시해 주어야 하는 것 이에요. 이게 바로 새롭게 추가된 async / await 문법입니다.</p><p>리턴값으로는 <code>(Data, URLResponse)</code> 형태의 튜플을 반환하므로 각각 변수를 생성하여 할당해 주었습니다. 이렇게 async / await 을 사용한 처리를 하면 콜백 함수를 사용하지 않아도 해당 변수에 데이터가 있다는 것이 보장됩니다. 즉 변수에 데이터가 들어올 때까지 기다렸다가 다음 코드를 실행한다고 생각하면 됩니다. 이제 HTTPURLResponse 에 대한 처리를 해 볼게요.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=k>if</span> <span class=kd>let</span> <span class=nv>response</span> <span class=p>=</span> <span class=n>response</span> <span class=k>as</span><span class=p>?</span> <span class=n>HTTPURLResponse</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=o>!</span><span class=p>(</span><span class=mf>200.</span><span class=p>.&lt;</span><span class=mi>300</span><span class=p>).</span><span class=bp>contains</span><span class=p>(</span><span class=n>response</span><span class=p>.</span><span class=n>statusCode</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=n>NetworkError</span><span class=p>.</span><span class=n>badResponse</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Response 에 문제가 있다면 <code>NetworkError.badResponse</code> 를 던지게 됩니다. 이제 JSON 을 디코드하고 나온 값을 리턴하는 코드를 작성할게요.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=k>guard</span> <span class=kd>let</span> <span class=nv>quote</span> <span class=p>=</span> <span class=k>try</span><span class=p>?</span> <span class=n>JSONDecoder</span><span class=p>().</span><span class=n>decode</span><span class=p>(</span><span class=n>Quote</span><span class=p>.</span><span class=kc>self</span><span class=p>,</span> <span class=n>from</span><span class=p>:</span> <span class=n>data</span><span class=p>)</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>throw</span> <span class=n>NetworkError</span><span class=p>.</span><span class=n>decodeFailed</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>return</span> <span class=n>quote</span>
</span></span></code></pre></div><p>중간에 <code>await</code> 처리가 된 부분을 제외하면 기존 코드와 크게 다르지 않습니다. 완성된 코드를 볼까요?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>func</span> <span class=nf>getQuote</span><span class=p>(</span><span class=n>from</span><span class=p>:</span> <span class=n>URL</span><span class=p>?)</span> <span class=n>async</span> <span class=kr>throws</span> <span class=p>-&gt;</span> <span class=n>Quote</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>guard</span> <span class=kd>let</span> <span class=nv>url</span> <span class=p>=</span> <span class=n>url</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=n>NetworkError</span><span class=p>.</span><span class=n>badUrl</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>response</span><span class=p>)</span> <span class=p>=</span> <span class=k>try</span> <span class=n>await</span> <span class=n>URLSession</span><span class=p>.</span><span class=n>shared</span><span class=p>.</span><span class=n>data</span><span class=p>(</span><span class=n>from</span><span class=p>:</span> <span class=n>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=kd>let</span> <span class=nv>response</span> <span class=p>=</span> <span class=n>response</span> <span class=k>as</span><span class=p>?</span> <span class=n>HTTPURLResponse</span><span class=p>,</span>
</span></span><span class=line><span class=cl>       <span class=o>!</span><span class=p>(</span><span class=mf>200.</span><span class=p>.&lt;</span><span class=mi>300</span><span class=p>).</span><span class=bp>contains</span><span class=p>(</span><span class=n>response</span><span class=p>.</span><span class=n>statusCode</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=n>NetworkError</span><span class=p>.</span><span class=n>badResponse</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>guard</span> <span class=kd>let</span> <span class=nv>quote</span> <span class=p>=</span> <span class=k>try</span><span class=p>?</span> <span class=n>JSONDecoder</span><span class=p>().</span><span class=n>decode</span><span class=p>(</span><span class=n>Quote</span><span class=p>.</span><span class=kc>self</span><span class=p>,</span> <span class=n>from</span><span class=p>:</span> <span class=n>data</span><span class=p>)</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=n>NetworkError</span><span class=p>.</span><span class=n>decodeFailed</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>quote</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>훨씬 간결한 느낌이 듭니다. 그럼 async / await 을 사용하면 CallBack 스타일로 처리했을 때 발생하는 문제점들이 어떻게 해결되었는지 살펴볼게요.</p><p>먼저 각 케이스에 따른 Completion 을 처리하는 작업이 없어졌습니다. 즉 실수할 가능성이 없어진 것이죠. 그리고 일반적인 함수처럼 특정 값을 리턴하게 만들었기 때문에 만약 우리가 함수 끝부분에 리턴 처리를 잊으면 컴파일러가 우리에게 경고를 발생시킵니다.</p><p>두번째로 Completion 처리 후 <code>return</code> 을 할 필요도 없어졌습니다. 예시에서는 <code>if</code> 를 혼용하여 사용했지만, 전부 <code>guard</code> 로 처리한다면 예외상황에서 <code>throw</code> 처리를 하지 않을 경우 컴파일러가 경고를 하게 됩니다. 역시 실수 발생 가능성이 없어졌습니다. 그렇게 많이 바뀌지 않은 것 같으면서도 핵심적인 문제점들이 전부 해소되었어요.</p><p>그럼 마지막으로 async 함수를 실행해 봅시다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=n>Task</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>let</span> <span class=nv>quote</span> <span class=p>=</span> <span class=k>try</span> <span class=n>await</span> <span class=n>getQuote</span><span class=p>(</span><span class=n>from</span><span class=p>:</span> <span class=n>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>print</span><span class=p>(</span><span class=n>quote</span><span class=p>.</span><span class=n>content</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>catch</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=bp>print</span><span class=p>(</span><span class=n>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>정상적으로 잘 작동하네요. 실행부 역시 코드의 가독성이 훨씬 좋아지고 길이도 짧아진 것을 확인할 수 있어요.</p><p>드디어 포스트 초반부에 잠깐 보았던 Task 가 등장했네요. 위에서 <strong>async</strong> 로 만들어진 함수를 호출하려면 문법상 반드시 <strong>await</strong> 을 명시해 주어야 한다고 했었잖아요? 사실 이 <code>await</code> 을 명시할 수 있는 조건이 크게 두가지가 있었습니다.</p><ul><li>async 하게 구현된 함수의 내부</li><li>Task 의 클로저 내부</li></ul><p>이전까지는 <strong>async</strong> 로 만들어진 함수의 내부에서 <strong>await</strong> 을 명시했기 때문에 에러가 발생하지 않았던 거에요. 일반적인 함수의 내부에서 async 하게 구현된 함수를 호출하면 에러가 발생하므로, 반드시 <code>Task</code> 클로저의 내부에서 실행해 주어야 합니다.</p><p>또한 <strong>Task</strong> 는 생성 이후 바로 실행되는 특성을 가지고 있어요. 즉 어떤 함수안에서 Task 를 생성하면, 해당 함수를 호출 할 때 Task 도 같이 실행되며 비동기 작업이 처리되겠죠?</p><hr><h2 id=wrap-up>Wrap Up<a hidden class=anchor aria-hidden=true href=#wrap-up>#</a></h2><p>이렇게 기존 CallBack 스타일에서 async / await 기능을 활용해 기존 함수를 개선하는 방법을 공부해 보았습니다. 이번 포스팅을 작성하면서 async / await 에 많이 익숙해져서 앞으로 completionHandler 는 잘 사용하지 않게 될 것 같아요 ㅎㅎ</p><p>이렇게 보면 우리가 async / await 에 대해 많은 것을 알게 된 것 같지만 사실 오늘 공부한 내용은 정말 일부분 입니다. 앞으로 <code>continuation</code>, <code>async let</code>, <code>Detached Task</code>, <code>Task Group</code> 등 공부해야 할 것들이 많이 남았어요. 함께 하나씩 차근차근 정복해나가 봅시다! <del>정ㅋ벅ㅋ</del></p><hr><h2 id=entire-code>Entire Code<a hidden class=anchor aria-hidden=true href=#entire-code>#</a></h2><h3 id=using-callback>Using CallBack<a hidden class=anchor aria-hidden=true href=#using-callback>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>import</span> <span class=nc>UIKit</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nv>url</span> <span class=p>=</span> <span class=n>URL</span><span class=p>(</span><span class=n>string</span><span class=p>:</span> <span class=s>&#34;https://api.quotable.io/random&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>enum</span> <span class=nc>NetworkError</span><span class=p>:</span> <span class=n>Error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>badUrl</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>badResponse</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>communicationError</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>decodeFailed</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>noData</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>struct</span> <span class=nc>Quote</span><span class=p>:</span> <span class=n>Decodable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nv>content</span><span class=p>:</span> <span class=nb>String</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>getQuote</span><span class=p>(</span><span class=n>from</span> <span class=n>url</span><span class=p>:</span> <span class=n>URL</span><span class=p>?,</span> <span class=n>completion</span><span class=p>:</span> <span class=p>@</span><span class=n>escaping</span> <span class=p>(</span><span class=n>Result</span><span class=p>&lt;</span><span class=n>Quote</span><span class=p>,</span> <span class=n>NetworkError</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=nb>Void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>guard</span> <span class=kd>let</span> <span class=nv>url</span> <span class=p>=</span> <span class=n>url</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>completion</span><span class=p>(.</span><span class=n>failure</span><span class=p>(.</span><span class=n>badUrl</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>URLSession</span><span class=p>.</span><span class=n>shared</span><span class=p>.</span><span class=n>dataTask</span><span class=p>(</span><span class=n>with</span><span class=p>:</span> <span class=n>url</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                               <span class=n>completionHandler</span><span class=p>:</span> <span class=p>{</span> <span class=n>data</span><span class=p>,</span> <span class=n>response</span><span class=p>,</span> <span class=n>error</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=kd>let</span> <span class=nv>error</span> <span class=p>=</span> <span class=n>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>completion</span><span class=p>(.</span><span class=n>failure</span><span class=p>(.</span><span class=n>communicationError</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=bp>print</span><span class=p>(</span><span class=n>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=kd>let</span> <span class=nv>response</span> <span class=p>=</span> <span class=n>response</span> <span class=k>as</span><span class=p>?</span> <span class=n>HTTPURLResponse</span><span class=p>,</span>
</span></span><span class=line><span class=cl>           <span class=o>!</span><span class=p>(</span><span class=mf>200.</span><span class=p>.&lt;</span><span class=mi>300</span><span class=p>).</span><span class=bp>contains</span><span class=p>(</span><span class=n>response</span><span class=p>.</span><span class=n>statusCode</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>completion</span><span class=p>(.</span><span class=n>failure</span><span class=p>(.</span><span class=n>badResponse</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>guard</span> <span class=kd>let</span> <span class=nv>data</span> <span class=p>=</span> <span class=n>data</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>completion</span><span class=p>(.</span><span class=n>failure</span><span class=p>(.</span><span class=n>noData</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kd>let</span> <span class=nv>quote</span> <span class=p>=</span> <span class=k>try</span> <span class=n>JSONDecoder</span><span class=p>().</span><span class=n>decode</span><span class=p>(</span><span class=n>Quote</span><span class=p>.</span><span class=kc>self</span><span class=p>,</span> <span class=n>from</span><span class=p>:</span> <span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>completion</span><span class=p>(.</span><span class=n>success</span><span class=p>(</span><span class=n>quote</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>catch</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>completion</span><span class=p>(.</span><span class=n>failure</span><span class=p>(.</span><span class=n>decodeFailed</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}).</span><span class=n>resume</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>getQuote</span><span class=p>(</span><span class=n>from</span><span class=p>:</span> <span class=n>url</span><span class=p>,</span>
</span></span><span class=line><span class=cl>         <span class=n>completion</span><span class=p>:</span> <span class=p>{</span> <span class=n>result</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=n>result</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=p>.</span><span class=n>success</span><span class=p>(</span><span class=kd>let</span> <span class=nv>quote</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>print</span><span class=p>(</span><span class=n>quote</span><span class=p>.</span><span class=n>content</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=p>.</span><span class=n>failure</span><span class=p>(</span><span class=kd>let</span> <span class=nv>error</span><span class=p>):</span>
</span></span><span class=line><span class=cl>        <span class=bp>print</span><span class=p>(</span><span class=n>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>})</span>
</span></span></code></pre></div><h3 id=using-async--await>Using Async / Await<a hidden class=anchor aria-hidden=true href=#using-async--await>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>import</span> <span class=nc>UIKit</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nv>url</span> <span class=p>=</span> <span class=n>URL</span><span class=p>(</span><span class=n>string</span><span class=p>:</span> <span class=s>&#34;https://api.quotable.io/random&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>enum</span> <span class=nc>NetworkError</span><span class=p>:</span> <span class=n>Error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>badUrl</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>badResponse</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>communicationError</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>decodeFailed</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>noData</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>struct</span> <span class=nc>Quote</span><span class=p>:</span> <span class=n>Decodable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nv>content</span><span class=p>:</span> <span class=nb>String</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>getQuote</span><span class=p>(</span><span class=n>from</span><span class=p>:</span> <span class=n>URL</span><span class=p>?)</span> <span class=n>async</span> <span class=kr>throws</span> <span class=p>-&gt;</span> <span class=n>Quote</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>guard</span> <span class=kd>let</span> <span class=nv>url</span> <span class=p>=</span> <span class=n>url</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=n>NetworkError</span><span class=p>.</span><span class=n>badUrl</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>response</span><span class=p>)</span> <span class=p>=</span> <span class=k>try</span> <span class=n>await</span> <span class=n>URLSession</span><span class=p>.</span><span class=n>shared</span><span class=p>.</span><span class=n>data</span><span class=p>(</span><span class=n>from</span><span class=p>:</span> <span class=n>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=kd>let</span> <span class=nv>response</span> <span class=p>=</span> <span class=n>response</span> <span class=k>as</span><span class=p>?</span> <span class=n>HTTPURLResponse</span><span class=p>,</span>
</span></span><span class=line><span class=cl>       <span class=o>!</span><span class=p>(</span><span class=mf>200.</span><span class=p>.&lt;</span><span class=mi>300</span><span class=p>).</span><span class=bp>contains</span><span class=p>(</span><span class=n>response</span><span class=p>.</span><span class=n>statusCode</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=n>NetworkError</span><span class=p>.</span><span class=n>badResponse</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>guard</span> <span class=kd>let</span> <span class=nv>quote</span> <span class=p>=</span> <span class=k>try</span><span class=p>?</span> <span class=n>JSONDecoder</span><span class=p>().</span><span class=n>decode</span><span class=p>(</span><span class=n>Quote</span><span class=p>.</span><span class=kc>self</span><span class=p>,</span> <span class=n>from</span><span class=p>:</span> <span class=n>data</span><span class=p>)</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=n>NetworkError</span><span class=p>.</span><span class=n>decodeFailed</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>quote</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Task</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>let</span> <span class=nv>quote</span> <span class=p>=</span> <span class=k>try</span> <span class=n>await</span> <span class=n>getQuote</span><span class=p>(</span><span class=n>from</span><span class=p>:</span> <span class=n>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=bp>print</span><span class=p>(</span><span class=n>quote</span><span class=p>.</span><span class=n>content</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> <span class=k>catch</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=bp>print</span><span class=p>(</span><span class=n>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><hr><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><p><a href=https://developer.apple.com/kr/swift/>Swift - Apple Developer</a><br><a href=https://www.hackingwithswift.com/quick-start/concurrency/where-is-swift-concurrency-supported>Where is Swift concurrency supported?</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://kasroid.github.io/tags/concurrency/>Concurrency</a></li><li><a href=https://kasroid.github.io/tags/async/await/>Async/Await</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://kasroid.github.io>SDY - Developer Kas</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>