<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Concurrency - async let 알아보기 | SDY - Developer Kas</title><meta name=keywords content="Concurrency,Async/Await"><meta name=description content="이 포스트는 다음 버전을 기준으로 작성되었습니다.
iOS 15.6 Swift 5.6.1 Xcode 13.4.1 Intro 이번 글에서는 async let 에 대해 공부해 보겠습니다. 이전 포스트 Concurrency - Async, Await, 그리고 Task 알아보기 와 Concurrency - Continuation 활용하기 에서 학습한 내용들을 어느정도 이해하셨다면, async let 은 상대적으로 간단하게 느껴질 거에요. 만약 아직 async/await 이 익숙하지 않다면 이전 포스트를 먼저 읽어주세요.
우선 async let 은 언제 사용하면 되는지를 알아봅시다. 그동안 우리가 사용한 비동기 함수에는 공통적인 부분이 있었어요."><meta name=author content="Doyoung Song"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9464825723074024" crossorigin=anonymous></script>
<link rel=canonical href=https://kasroid.github.io/posts/ios/20220809-concurrency-async-let/><meta name=google-site-verification content="43_MOEW0diGtfoxWtXZ65iT24CFf_i63QMcMBiLkAUs"><link crossorigin=anonymous href=/assets/css/stylesheet.e25c039fcca7cb994b37c6f8ebbbca4c2f45a76107a5c9cf00996f9649d57ca6.css integrity="sha256-4lwDn8yny5lLN8b467vKTC9Fp2EHpcnPAJlvlknVfKY=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://kasroid.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://kasroid.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://kasroid.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://kasroid.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://kasroid.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-177150852-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Concurrency - async let 알아보기"><meta property="og:description" content="이 포스트는 다음 버전을 기준으로 작성되었습니다.
iOS 15.6 Swift 5.6.1 Xcode 13.4.1 Intro 이번 글에서는 async let 에 대해 공부해 보겠습니다. 이전 포스트 Concurrency - Async, Await, 그리고 Task 알아보기 와 Concurrency - Continuation 활용하기 에서 학습한 내용들을 어느정도 이해하셨다면, async let 은 상대적으로 간단하게 느껴질 거에요. 만약 아직 async/await 이 익숙하지 않다면 이전 포스트를 먼저 읽어주세요.
우선 async let 은 언제 사용하면 되는지를 알아봅시다. 그동안 우리가 사용한 비동기 함수에는 공통적인 부분이 있었어요."><meta property="og:type" content="article"><meta property="og:url" content="https://kasroid.github.io/posts/ios/20220809-concurrency-async-let/"><meta property="og:image" content="https://kasroid.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-09T11:43:00+09:00"><meta property="article:modified_time" content="2022-08-09T11:43:00+09:00"><meta property="og:site_name" content="SDY - Dev Log"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kasroid.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Concurrency - async let 알아보기"><meta name=twitter:description content="이 포스트는 다음 버전을 기준으로 작성되었습니다.
iOS 15.6 Swift 5.6.1 Xcode 13.4.1 Intro 이번 글에서는 async let 에 대해 공부해 보겠습니다. 이전 포스트 Concurrency - Async, Await, 그리고 Task 알아보기 와 Concurrency - Continuation 활용하기 에서 학습한 내용들을 어느정도 이해하셨다면, async let 은 상대적으로 간단하게 느껴질 거에요. 만약 아직 async/await 이 익숙하지 않다면 이전 포스트를 먼저 읽어주세요.
우선 async let 은 언제 사용하면 되는지를 알아봅시다. 그동안 우리가 사용한 비동기 함수에는 공통적인 부분이 있었어요."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://kasroid.github.io/posts/"},{"@type":"ListItem","position":3,"name":"iOS","item":"https://kasroid.github.io/posts/ios/"},{"@type":"ListItem","position":4,"name":"Concurrency - async let 알아보기","item":"https://kasroid.github.io/posts/ios/20220809-concurrency-async-let/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Concurrency - async let 알아보기","name":"Concurrency - async let 알아보기","description":"이 포스트는 다음 버전을 기준으로 작성되었습니다.\niOS 15.6 Swift 5.6.1 Xcode 13.4.1 Intro 이번 글에서는 async let 에 대해 공부해 보겠습니다. 이전 포스트 Concurrency - Async, Await, 그리고 Task 알아보기 와 Concurrency - Continuation 활용하기 에서 학습한 내용들을 어느정도 이해하셨다면, async let 은 상대적으로 간단하게 느껴질 거에요. 만약 아직 async/await 이 익숙하지 않다면 이전 포스트를 먼저 읽어주세요.\n우선 async let 은 언제 사용하면 되는지를 알아봅시다. 그동안 우리가 사용한 비동기 함수에는 공통적인 부분이 있었어요.","keywords":["Concurrency","Async/Await"],"articleBody":" 이 포스트는 다음 버전을 기준으로 작성되었습니다.\niOS 15.6 Swift 5.6.1 Xcode 13.4.1 Intro 이번 글에서는 async let 에 대해 공부해 보겠습니다. 이전 포스트 Concurrency - Async, Await, 그리고 Task 알아보기 와 Concurrency - Continuation 활용하기 에서 학습한 내용들을 어느정도 이해하셨다면, async let 은 상대적으로 간단하게 느껴질 거에요. 만약 아직 async/await 이 익숙하지 않다면 이전 포스트를 먼저 읽어주세요.\n우선 async let 은 언제 사용하면 되는지를 알아봅시다. 그동안 우리가 사용한 비동기 함수에는 공통적인 부분이 있었어요. 바로 한번에 하나의 비동기 작업만 처리 했었다는 것이죠. 그렇다면 여러 개의 비동기 작업을 처리해야 하는 상황에서도 그냥 기존 방식대로 하면 되는걸까요?\n테스트를 해보면 기존 방식으로도 여러 개의 비동기 작업이 정상적으로 처리되는 것을 알 수 있습니다. 하지만 좀 더 테스트를 해본다면 비효율적인 부분이 있는 것도 발견할 수 있습니다. async let 은 이런 비효율적인 부분을 효율적으로 처리할 수 있게 도와줍니다. 그럼 기존 방식과 어떤 차이가 있는지 바로 알아볼까요~\nUsage Examples Concurrency - Async, Await, 그리고 Task 알아보기 에서 사용한 예시를 그대로 가져와서 실습을 진행해 보겠습니다.\nlet url = URL(string: \"https://api.quotable.io/random\") enum NetworkError: Error { case badUrl case badResponse case communicationError case decodeFailed case noData } struct Quote: Decodable { let content: String } func getQuote(from: URL?) async throws -\u003e Quote { guard let url = url else { throw NetworkError.badUrl } let (data, response) = try await URLSession.shared.data(from: url) if let response = response as? HTTPURLResponse, !(200..\u003c300).contains(response.statusCode) { throw NetworkError.badResponse } guard let quote = try? JSONDecoder().decode(Quote.self, from: data) else { throw NetworkError.decodeFailed } return quote } 여러 개의 비동기 작업 진행을 위해 Quote 를 여러 번 요청하여 받은 데이터를 배열에 담아 출력하는 함수를 작성해 볼게요. 우리가 그동안 학습한 내용을 바탕으로 작성하면 다음과 같은 코드가 됩니다.\nfunc getQuotes() { Task { let firstQuote = try await getQuote(from: url) let secondQuote = try await getQuote(from: url) let thirdQuote = try await getQuote(from: url) let quotes = [firstQuote.content, secondQuote.content, thirdQuote.content] print(quotes) } } 정상적으로 잘 작동하네요 ㅎㅎ 하지만 사실 이 코드에는 문제가 하나 있습니다. 각 다운로드는 먼저 시작된 다운로드가 완료되기 전까지 시작되지 않고 대기하는 방식이라는 점 이에요. 지금은 작업이 3개뿐이므로 금새 끝났지만 만약 작업이 3,000 개 였다면 얼마나 오랜 시간이 걸릴지 끔찍합니다.\nasync let 적용하기 여러 개의 비동기 작업을 이전 비동기 작업의 종료 여부와 관계없이 처리하고자 할 때 바로 async let 을 사용하면 됩니다. async let 의 사용법은 간단합니다. 변수 선언 시 async let 으로 선언하고 데이터를 활용하는 단계에서 await 키워드로 기다리게 하면 끝이에요. 코드를 직접 보면서 배워볼게요.\n아! 이번 코드는 꼭 Xcode Project 에서 실행해야 합니다. 현재 포스트 작성 시점에서는 Playground 에서 에러가 발생하며 동작하지 않습니다.\nfunc getQuotes() { Task { async let firstQuote = getQuote(from: url) async let secondQuote = getQuote(from: url) async let thirdQuote = getQuote(from: url) let quotes = try await [firstQuote.content, secondQuote.content, thirdQuote.content] print(quotes) } } 조금 전 얘기했던대로 비동기 함수의 리턴값을 async let 로 선언한 변수에 할당하고 해당 값을 배열에 할당할 때 await 키워드로 비동기 작업을 기다리게 해주었습니다.\n이전 코드와 결과물에는 차이가 없지만 작동방식은 완전히 달라졌습니다. 이렇게 async let 으로 선언을 하면 더 이상 먼저 시작된 비동기 작업이 끝날 때까지 기다리지 않고 다음 작업을 시작합니다. 사용법이 정말 간단하지 않나요?\n단 사용 시에 몇가지 반드시 알아두어야 할 것 들이 있습니다. asyncs let 은 이전 작업의 완료 시점과 관계없이 바로 다음 요청을 보내므로 끝나는 순서가 보장되지 않습니다. 그리고 함수 내부 즉 local variable 형태로만 사용할 수 있습니다. 즉 전역변수나 클래스 변수로는 사용할 수 없다는 것 기억해 두세요!\nWrap Up 이렇게 async let 에 대해 알아보았습니다. async let 은 비동기 작업 시 다른 작업이 끝나는 것을 기다리지 않고 시작할 수 있게 할 뿐만 아니라, 모든 비동기 작업이 끝난 후 다음 필요한 작업을 처리할 수 있게 보장해 주기도 한다는 것 알아두시면 필요할 때 유용하게 사용할 수 있을거에요.\nEntire Code import UIKit let url = URL(string: \"https://api.quotable.io/random\") enum NetworkError: Error { case badUrl case badResponse case communicationError case decodeFailed case noData } struct Quote: Decodable { let content: String } class ViewController: UIViewController { override func viewDidLoad() { super.viewDidLoad() getQuotes() } func getQuote(from: URL?) async throws -\u003e Quote { guard let url = url else { throw NetworkError.badUrl } let (data, response) = try await URLSession.shared.data(from: url) if let response = response as? HTTPURLResponse, !(200..\u003c300).contains(response.statusCode) { throw NetworkError.badResponse } guard let quote = try? JSONDecoder().decode(Quote.self, from: data) else { throw NetworkError.decodeFailed } return quote } func getQuotes() { Task { async let firstQuote = getQuote(from: url) async let secondQuote = getQuote(from: url) async let thirdQuote = getQuote(from: url) let quotes = try await [firstQuote.content, secondQuote.content, thirdQuote.content] print(quotes) } } } References Async let explained: call async functions in parallel\n","wordCount":"729","inLanguage":"en","datePublished":"2022-08-09T11:43:00+09:00","dateModified":"2022-08-09T11:43:00+09:00","author":{"@type":"Person","name":"Doyoung Song"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://kasroid.github.io/posts/ios/20220809-concurrency-async-let/"},"publisher":{"@type":"Organization","name":"SDY - Developer Kas","logo":{"@type":"ImageObject","url":"https://kasroid.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kasroid.github.io accesskey=h title="SDY (Alt + H)">SDY</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://kasroid.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://kasroid.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://kasroid.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://kasroid.github.io>Home</a>&nbsp;»&nbsp;<a href=https://kasroid.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://kasroid.github.io/posts/ios/>iOS</a></div><h1 class=post-title>Concurrency - async let 알아보기</h1><div class=post-meta><span title='2022-08-09 11:43:00 +0900 KST'>2022-08-09</span>&nbsp;·&nbsp;Doyoung Song</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#intro>Intro</a></li><li><a href=#usage-examples>Usage Examples</a><ul><li><a href=#async-let-적용하기>async let 적용하기</a></li></ul></li><li><a href=#wrap-up>Wrap Up</a></li><li><a href=#entire-code>Entire Code</a></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><blockquote><p>이 포스트는 다음 버전을 기준으로 작성되었습니다.</p><ul><li>iOS 15.6</li><li>Swift 5.6.1</li><li>Xcode 13.4.1</li></ul></blockquote><h2 id=intro>Intro<a hidden class=anchor aria-hidden=true href=#intro>#</a></h2><p>이번 글에서는 <code>async let</code> 에 대해 공부해 보겠습니다. 이전 포스트 <a href=https://kasroid.github.io/posts/ios/20220731-concurrency-async-await-task/>Concurrency - Async, Await, 그리고 Task 알아보기</a> 와 <a href=https://kasroid.github.io/posts/ios/20220804-concurrency-continuation/>Concurrency - Continuation 활용하기</a> 에서 학습한 내용들을 어느정도 이해하셨다면, <code>async let</code> 은 상대적으로 간단하게 느껴질 거에요. 만약 아직 <strong>async/await</strong> 이 익숙하지 않다면 이전 포스트를 먼저 읽어주세요.</p><p>우선 <code>async let</code> 은 언제 사용하면 되는지를 알아봅시다. 그동안 우리가 사용한 비동기 함수에는 공통적인 부분이 있었어요. 바로 한번에 하나의 비동기 작업만 처리 했었다는 것이죠. 그렇다면 여러 개의 비동기 작업을 처리해야 하는 상황에서도 그냥 기존 방식대로 하면 되는걸까요?</p><p>테스트를 해보면 기존 방식으로도 여러 개의 비동기 작업이 정상적으로 처리되는 것을 알 수 있습니다. 하지만 좀 더 테스트를 해본다면 비효율적인 부분이 있는 것도 발견할 수 있습니다. <code>async let</code> 은 이런 비효율적인 부분을 효율적으로 처리할 수 있게 도와줍니다. 그럼 기존 방식과 어떤 차이가 있는지 바로 알아볼까요~</p><hr><h2 id=usage-examples>Usage Examples<a hidden class=anchor aria-hidden=true href=#usage-examples>#</a></h2><p><a href=https://kasroid.github.io/posts/ios/20220731-concurrency-async-await-task/>Concurrency - Async, Await, 그리고 Task 알아보기</a> 에서 사용한 예시를 그대로 가져와서 실습을 진행해 보겠습니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>let</span> <span class=nv>url</span> <span class=p>=</span> <span class=n>URL</span><span class=p>(</span><span class=n>string</span><span class=p>:</span> <span class=s>&#34;https://api.quotable.io/random&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>enum</span> <span class=nc>NetworkError</span><span class=p>:</span> <span class=n>Error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>badUrl</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>badResponse</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>communicationError</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>decodeFailed</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>noData</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>struct</span> <span class=nc>Quote</span><span class=p>:</span> <span class=n>Decodable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nv>content</span><span class=p>:</span> <span class=nb>String</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>getQuote</span><span class=p>(</span><span class=n>from</span><span class=p>:</span> <span class=n>URL</span><span class=p>?)</span> <span class=n>async</span> <span class=kr>throws</span> <span class=p>-&gt;</span> <span class=n>Quote</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>guard</span> <span class=kd>let</span> <span class=nv>url</span> <span class=p>=</span> <span class=n>url</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=n>NetworkError</span><span class=p>.</span><span class=n>badUrl</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>response</span><span class=p>)</span> <span class=p>=</span> <span class=k>try</span> <span class=n>await</span> <span class=n>URLSession</span><span class=p>.</span><span class=n>shared</span><span class=p>.</span><span class=n>data</span><span class=p>(</span><span class=n>from</span><span class=p>:</span> <span class=n>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=kd>let</span> <span class=nv>response</span> <span class=p>=</span> <span class=n>response</span> <span class=k>as</span><span class=p>?</span> <span class=n>HTTPURLResponse</span><span class=p>,</span>
</span></span><span class=line><span class=cl>       <span class=o>!</span><span class=p>(</span><span class=mf>200.</span><span class=p>.&lt;</span><span class=mi>300</span><span class=p>).</span><span class=bp>contains</span><span class=p>(</span><span class=n>response</span><span class=p>.</span><span class=n>statusCode</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=n>NetworkError</span><span class=p>.</span><span class=n>badResponse</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>guard</span> <span class=kd>let</span> <span class=nv>quote</span> <span class=p>=</span> <span class=k>try</span><span class=p>?</span> <span class=n>JSONDecoder</span><span class=p>().</span><span class=n>decode</span><span class=p>(</span><span class=n>Quote</span><span class=p>.</span><span class=kc>self</span><span class=p>,</span> <span class=n>from</span><span class=p>:</span> <span class=n>data</span><span class=p>)</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=n>NetworkError</span><span class=p>.</span><span class=n>decodeFailed</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>quote</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>여러 개의 비동기 작업 진행을 위해 Quote 를 여러 번 요청하여 받은 데이터를 배열에 담아 출력하는 함수를 작성해 볼게요. 우리가 그동안 학습한 내용을 바탕으로 작성하면 다음과 같은 코드가 됩니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>func</span> <span class=nf>getQuotes</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Task</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>let</span> <span class=nv>firstQuote</span> <span class=p>=</span> <span class=k>try</span> <span class=n>await</span> <span class=n>getQuote</span><span class=p>(</span><span class=n>from</span><span class=p>:</span> <span class=n>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=kd>let</span> <span class=nv>secondQuote</span> <span class=p>=</span> <span class=k>try</span> <span class=n>await</span> <span class=n>getQuote</span><span class=p>(</span><span class=n>from</span><span class=p>:</span> <span class=n>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=kd>let</span> <span class=nv>thirdQuote</span> <span class=p>=</span> <span class=k>try</span> <span class=n>await</span> <span class=n>getQuote</span><span class=p>(</span><span class=n>from</span><span class=p>:</span> <span class=n>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=kd>let</span> <span class=nv>quotes</span> <span class=p>=</span> <span class=p>[</span><span class=n>firstQuote</span><span class=p>.</span><span class=n>content</span><span class=p>,</span> <span class=n>secondQuote</span><span class=p>.</span><span class=n>content</span><span class=p>,</span> <span class=n>thirdQuote</span><span class=p>.</span><span class=n>content</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=bp>print</span><span class=p>(</span><span class=n>quotes</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>정상적으로 잘 작동하네요 ㅎㅎ 하지만 사실 이 코드에는 문제가 하나 있습니다. 각 다운로드는 먼저 시작된 다운로드가 완료되기 전까지 시작되지 않고 대기하는 방식이라는 점 이에요. 지금은 작업이 3개뿐이므로 금새 끝났지만 만약 작업이 3,000 개 였다면 얼마나 오랜 시간이 걸릴지 끔찍합니다.</p><h3 id=async-let-적용하기>async let 적용하기<a hidden class=anchor aria-hidden=true href=#async-let-적용하기>#</a></h3><p>여러 개의 비동기 작업을 이전 비동기 작업의 종료 여부와 관계없이 처리하고자 할 때 바로 <code>async let</code> 을 사용하면 됩니다. <code>async let</code> 의 사용법은 간단합니다. 변수 선언 시 <code>async let</code> 으로 선언하고 데이터를 활용하는 단계에서 <code>await</code> 키워드로 기다리게 하면 끝이에요. 코드를 직접 보면서 배워볼게요.</p><p>아! 이번 코드는 꼭 <strong>Xcode Project</strong> 에서 실행해야 합니다. 현재 포스트 작성 시점에서는 Playground 에서 에러가 발생하며 동작하지 않습니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>func</span> <span class=nf>getQuotes</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Task</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>async</span> <span class=kd>let</span> <span class=nv>firstQuote</span> <span class=p>=</span> <span class=n>getQuote</span><span class=p>(</span><span class=n>from</span><span class=p>:</span> <span class=n>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>async</span> <span class=kd>let</span> <span class=nv>secondQuote</span> <span class=p>=</span> <span class=n>getQuote</span><span class=p>(</span><span class=n>from</span><span class=p>:</span> <span class=n>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>async</span> <span class=kd>let</span> <span class=nv>thirdQuote</span> <span class=p>=</span> <span class=n>getQuote</span><span class=p>(</span><span class=n>from</span><span class=p>:</span> <span class=n>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=kd>let</span> <span class=nv>quotes</span> <span class=p>=</span> <span class=k>try</span> <span class=n>await</span> <span class=p>[</span><span class=n>firstQuote</span><span class=p>.</span><span class=n>content</span><span class=p>,</span> <span class=n>secondQuote</span><span class=p>.</span><span class=n>content</span><span class=p>,</span> <span class=n>thirdQuote</span><span class=p>.</span><span class=n>content</span><span class=p>]</span>
</span></span><span class=line><span class=cl>        <span class=bp>print</span><span class=p>(</span><span class=n>quotes</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>조금 전 얘기했던대로 비동기 함수의 리턴값을 <code>async let</code> 로 선언한 변수에 할당하고 해당 값을 배열에 할당할 때 <code>await</code> 키워드로 비동기 작업을 기다리게 해주었습니다.</p><p>이전 코드와 결과물에는 차이가 없지만 작동방식은 완전히 달라졌습니다. 이렇게 <code>async let</code> 으로 선언을 하면 더 이상 먼저 시작된 비동기 작업이 끝날 때까지 기다리지 않고 다음 작업을 시작합니다. 사용법이 정말 간단하지 않나요?</p><p>단 사용 시에 몇가지 반드시 알아두어야 할 것 들이 있습니다. <code>asyncs let</code> 은 이전 작업의 완료 시점과 관계없이 바로 다음 요청을 보내므로 <strong>끝나는 순서가 보장되지 않습니다</strong>. 그리고 함수 내부 즉 <strong>local variable 형태로만 사용</strong>할 수 있습니다. 즉 전역변수나 클래스 변수로는 사용할 수 없다는 것 기억해 두세요!</p><hr><h2 id=wrap-up>Wrap Up<a hidden class=anchor aria-hidden=true href=#wrap-up>#</a></h2><p>이렇게 <code>async let</code> 에 대해 알아보았습니다. <code>async let</code> 은 비동기 작업 시 다른 작업이 끝나는 것을 기다리지 않고 시작할 수 있게 할 뿐만 아니라, 모든 비동기 작업이 끝난 후 다음 필요한 작업을 처리할 수 있게 보장해 주기도 한다는 것 알아두시면 필요할 때 유용하게 사용할 수 있을거에요.</p><hr><h2 id=entire-code>Entire Code<a hidden class=anchor aria-hidden=true href=#entire-code>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>import</span> <span class=nc>UIKit</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nv>url</span> <span class=p>=</span> <span class=n>URL</span><span class=p>(</span><span class=n>string</span><span class=p>:</span> <span class=s>&#34;https://api.quotable.io/random&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>enum</span> <span class=nc>NetworkError</span><span class=p>:</span> <span class=n>Error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>badUrl</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>badResponse</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>communicationError</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>decodeFailed</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>noData</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>struct</span> <span class=nc>Quote</span><span class=p>:</span> <span class=n>Decodable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nv>content</span><span class=p>:</span> <span class=nb>String</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>class</span> <span class=nc>ViewController</span><span class=p>:</span> <span class=n>UIViewController</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kr>override</span> <span class=kd>func</span> <span class=nf>viewDidLoad</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kc>super</span><span class=p>.</span><span class=n>viewDidLoad</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>getQuotes</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=kd>func</span> <span class=nf>getQuote</span><span class=p>(</span><span class=n>from</span><span class=p>:</span> <span class=n>URL</span><span class=p>?)</span> <span class=n>async</span> <span class=kr>throws</span> <span class=p>-&gt;</span> <span class=n>Quote</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>guard</span> <span class=kd>let</span> <span class=nv>url</span> <span class=p>=</span> <span class=n>url</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=n>NetworkError</span><span class=p>.</span><span class=n>badUrl</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=kd>let</span> <span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>response</span><span class=p>)</span> <span class=p>=</span> <span class=k>try</span> <span class=n>await</span> <span class=n>URLSession</span><span class=p>.</span><span class=n>shared</span><span class=p>.</span><span class=n>data</span><span class=p>(</span><span class=n>from</span><span class=p>:</span> <span class=n>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=kd>let</span> <span class=nv>response</span> <span class=p>=</span> <span class=n>response</span> <span class=k>as</span><span class=p>?</span> <span class=n>HTTPURLResponse</span><span class=p>,</span>
</span></span><span class=line><span class=cl>           <span class=o>!</span><span class=p>(</span><span class=mf>200.</span><span class=p>.&lt;</span><span class=mi>300</span><span class=p>).</span><span class=bp>contains</span><span class=p>(</span><span class=n>response</span><span class=p>.</span><span class=n>statusCode</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=n>NetworkError</span><span class=p>.</span><span class=n>badResponse</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>guard</span> <span class=kd>let</span> <span class=nv>quote</span> <span class=p>=</span> <span class=k>try</span><span class=p>?</span> <span class=n>JSONDecoder</span><span class=p>().</span><span class=n>decode</span><span class=p>(</span><span class=n>Quote</span><span class=p>.</span><span class=kc>self</span><span class=p>,</span> <span class=n>from</span><span class=p>:</span> <span class=n>data</span><span class=p>)</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>throw</span> <span class=n>NetworkError</span><span class=p>.</span><span class=n>decodeFailed</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>quote</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>func</span> <span class=nf>getQuotes</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>Task</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>async</span> <span class=kd>let</span> <span class=nv>firstQuote</span> <span class=p>=</span> <span class=n>getQuote</span><span class=p>(</span><span class=n>from</span><span class=p>:</span> <span class=n>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>async</span> <span class=kd>let</span> <span class=nv>secondQuote</span> <span class=p>=</span> <span class=n>getQuote</span><span class=p>(</span><span class=n>from</span><span class=p>:</span> <span class=n>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>async</span> <span class=kd>let</span> <span class=nv>thirdQuote</span> <span class=p>=</span> <span class=n>getQuote</span><span class=p>(</span><span class=n>from</span><span class=p>:</span> <span class=n>url</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=kd>let</span> <span class=nv>quotes</span> <span class=p>=</span> <span class=k>try</span> <span class=n>await</span> <span class=p>[</span><span class=n>firstQuote</span><span class=p>.</span><span class=n>content</span><span class=p>,</span> <span class=n>secondQuote</span><span class=p>.</span><span class=n>content</span><span class=p>,</span> <span class=n>thirdQuote</span><span class=p>.</span><span class=n>content</span><span class=p>]</span>
</span></span><span class=line><span class=cl>            <span class=bp>print</span><span class=p>(</span><span class=n>quotes</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><hr><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><p><a href=https://www.avanderlee.com/swift/async-let-asynchronous-functions-in-parallel/>Async let explained: call async functions in parallel</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://kasroid.github.io/tags/concurrency/>Concurrency</a></li><li><a href=https://kasroid.github.io/tags/async/await/>Async/Await</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://kasroid.github.io>SDY - Developer Kas</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>