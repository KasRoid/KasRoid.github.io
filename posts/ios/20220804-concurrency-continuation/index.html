<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Concurrency - Continuation 활용하기 | SDY - Developer Kas</title><meta name=keywords content="Concurrency,Async/Await"><meta name=description content="이 포스트는 다음 버전을 기준으로 작성되었습니다.
iOS 15.6 Swift 5.6.1 Xcode 13.4.1 Intro 오늘은 Continuation 이라는 것을 공부해 보겠습니다. 본격적으로 설명을 시작하기 전에 이것을 어디에 사용하는지를 알아야 공부에 대한 동기부여가 될테니, Continuation 이 언제 필요한지를 먼저 알아보도록 할게요.
우리는 이전 포스트에서 async/await 의 기본적인 사용법을 익혔습니다. 기존 @escaping 키워드를 사용해 콜백 스타일로 비동기 작업을 처리하는 함수를, 새로운 Async, Await API 를 적용시킨 함수로 리팩토링하여 훨씬 간결하고 가독성 좋은 비동기 함수를 만들 수 있었어요."><meta name=author content="Doyoung Song"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9464825723074024" crossorigin=anonymous></script>
<link rel=canonical href=https://kasroid.github.io/posts/ios/20220804-concurrency-continuation/><meta name=google-site-verification content="43_MOEW0diGtfoxWtXZ65iT24CFf_i63QMcMBiLkAUs"><link crossorigin=anonymous href=/assets/css/stylesheet.e25c039fcca7cb994b37c6f8ebbbca4c2f45a76107a5c9cf00996f9649d57ca6.css integrity="sha256-4lwDn8yny5lLN8b467vKTC9Fp2EHpcnPAJlvlknVfKY=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://kasroid.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://kasroid.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://kasroid.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://kasroid.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://kasroid.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-177150852-1","auto"),ga("send","pageview"))</script><meta property="og:title" content="Concurrency - Continuation 활용하기"><meta property="og:description" content="이 포스트는 다음 버전을 기준으로 작성되었습니다.
iOS 15.6 Swift 5.6.1 Xcode 13.4.1 Intro 오늘은 Continuation 이라는 것을 공부해 보겠습니다. 본격적으로 설명을 시작하기 전에 이것을 어디에 사용하는지를 알아야 공부에 대한 동기부여가 될테니, Continuation 이 언제 필요한지를 먼저 알아보도록 할게요.
우리는 이전 포스트에서 async/await 의 기본적인 사용법을 익혔습니다. 기존 @escaping 키워드를 사용해 콜백 스타일로 비동기 작업을 처리하는 함수를, 새로운 Async, Await API 를 적용시킨 함수로 리팩토링하여 훨씬 간결하고 가독성 좋은 비동기 함수를 만들 수 있었어요."><meta property="og:type" content="article"><meta property="og:url" content="https://kasroid.github.io/posts/ios/20220804-concurrency-continuation/"><meta property="og:image" content="https://kasroid.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-08-04T08:17:00+09:00"><meta property="article:modified_time" content="2022-08-04T08:17:00+09:00"><meta property="og:site_name" content="SDY - Dev Log"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://kasroid.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Concurrency - Continuation 활용하기"><meta name=twitter:description content="이 포스트는 다음 버전을 기준으로 작성되었습니다.
iOS 15.6 Swift 5.6.1 Xcode 13.4.1 Intro 오늘은 Continuation 이라는 것을 공부해 보겠습니다. 본격적으로 설명을 시작하기 전에 이것을 어디에 사용하는지를 알아야 공부에 대한 동기부여가 될테니, Continuation 이 언제 필요한지를 먼저 알아보도록 할게요.
우리는 이전 포스트에서 async/await 의 기본적인 사용법을 익혔습니다. 기존 @escaping 키워드를 사용해 콜백 스타일로 비동기 작업을 처리하는 함수를, 새로운 Async, Await API 를 적용시킨 함수로 리팩토링하여 훨씬 간결하고 가독성 좋은 비동기 함수를 만들 수 있었어요."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://kasroid.github.io/posts/"},{"@type":"ListItem","position":3,"name":"iOS","item":"https://kasroid.github.io/posts/ios/"},{"@type":"ListItem","position":4,"name":"Concurrency - Continuation 활용하기","item":"https://kasroid.github.io/posts/ios/20220804-concurrency-continuation/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Concurrency - Continuation 활용하기","name":"Concurrency - Continuation 활용하기","description":"이 포스트는 다음 버전을 기준으로 작성되었습니다.\niOS 15.6 Swift 5.6.1 Xcode 13.4.1 Intro 오늘은 Continuation 이라는 것을 공부해 보겠습니다. 본격적으로 설명을 시작하기 전에 이것을 어디에 사용하는지를 알아야 공부에 대한 동기부여가 될테니, Continuation 이 언제 필요한지를 먼저 알아보도록 할게요.\n우리는 이전 포스트에서 async/await 의 기본적인 사용법을 익혔습니다. 기존 @escaping 키워드를 사용해 콜백 스타일로 비동기 작업을 처리하는 함수를, 새로운 Async, Await API 를 적용시킨 함수로 리팩토링하여 훨씬 간결하고 가독성 좋은 비동기 함수를 만들 수 있었어요.","keywords":["Concurrency","Async/Await"],"articleBody":" 이 포스트는 다음 버전을 기준으로 작성되었습니다.\niOS 15.6 Swift 5.6.1 Xcode 13.4.1 Intro 오늘은 Continuation 이라는 것을 공부해 보겠습니다. 본격적으로 설명을 시작하기 전에 이것을 어디에 사용하는지를 알아야 공부에 대한 동기부여가 될테니, Continuation 이 언제 필요한지를 먼저 알아보도록 할게요.\n우리는 이전 포스트에서 async/await 의 기본적인 사용법을 익혔습니다. 기존 @escaping 키워드를 사용해 콜백 스타일로 비동기 작업을 처리하는 함수를, 새로운 Async, Await API 를 적용시킨 함수로 리팩토링하여 훨씬 간결하고 가독성 좋은 비동기 함수를 만들 수 있었어요.\n하지만 막상 새롭게 배운 내용들을 회사 프로젝트에 적용하려고 보니 다음과 같은 상황이 발생했다고 생각해보세요.\n기존 함수가 패키지 안에 감싸져 있어 우리가 임의로 수정할 수 없습니다. 레거시 코드가 너무 복잡하게 엉켜있어 수정 시 크리티컬한 사이드 이펙트가 발생할 수 있습니다. 아쉽지만 회사에서 새로운 프로젝트를 시작할 때까지 async/await 사용을 포기해야 할까요?\n아니요 포기는 배추를 셀 때나.. 바로 이러한 상황에서 사용할 수 있도록 위해 애플이 Continuation 을 준비해 두었습니다. 기존 콜백 스타일의 비동기 함수는 수정하지 않으면서, 브릿지 역할을 하는 Continuation 함수를 만들어 Async, Await API 를 적용하는 것 입니다.\nContinuation 정의 Continuation 은 다음 두가지로 나뉘어 있습니다.\nCheckedContinuation UnsafeContinuation 그렇다면 둘 사이에 어떤 차이점이 있을까요? 여느 때처럼 공식 문서에서 한번 찾아보겠습니다.\nCheckedContinuation 은 동기, 비동기 코드 간의 인터페이스 메커니즘이라고 합니다.\n음… 메커니즘…?? 개념적인 설명이라 그런지 조금 모호한 듯한 느낌이 있네요. 위에서 얘기했던 대로 콜백함수를 Async 함수로 변환하는 브릿지 역할을 한다는 것을 이렇게 표현한 걸까요?\n다음 것도 읽어보면 좀 더 이해가 잘 갈 수도 있으니 UnsafeContinuation 의 설명을 보겠습니다.\n또커니즘… 그래도 CheckedContinuation 과 다른 점을 찾았습니다. 메커니즘이 정확히 무엇을 의미하건 간에 정확성 검사의 유무라는 차이가 있네요. 그렇다면 정확성 검사가 무엇인지를 알아야겠죠.\n정확성 검사 Continuation 은 사용 시 개발자가 반드시 지켜야 하는 두가지 규칙이 있습니다.\nContinuation 클로저 안에서 반드시 resume 을 호출해야 합니다. 그리고 resume 은 단 한 번만 호출 되어야 합니다. 우리가 작성한 코드가 이 두가지 규칙을 위배하는지에 대한 체크해 주는 것이 바로 정확성 검사입니다.\n정확성 검사 조건 위배 시 발생하는 현상 조건을 위배한 코드를 작성하면 어떤 일이 일어날까요?\nresume 이 단 한 번도 호출되지 않았다면 Continuation 이 실행되고 값이나 에러를 리턴하지 않게 됩니다. 즉 Continuation 이 무한 대기상태에 빠져 리소스 낭비가 발생하게 됩니다. 두번 이상 resume 을 호출하면 앱에 크래시가 발생합니다. 사실 정확성 검사 기능을 제공하는 CheckedContinuation 을 사용한다고 스위프트 문법 검사를 하듯이 resume 규칙에 대한 위배를 미리 체크하고 막아주는 것은 아닙니다.\n대신 앱이 실행되는 동안 규칙이 위배된 것을 발견하면 경고 메세지가 콘솔에 출력됩니다. 그 이유는 정확성 검사가 런타임에 이루어지기 때문이에요.\nCheckedContinuation 의 문제점 지금까지 살펴보았듯 보다 안전한 코드를 작성하려면 CheckedContinuation 를 사용하면 됩니다. 그렇다면 안전하지 않은 옵션인 UnsafeContinuation 은 왜 만들어 놓았을까요?\n그것은 바로 CheckedContinuation 의 정확성 검사가 런타임에 이루어지다보니 오버헤드가 발생한다는 단점이 있기 대문입니다. 안전한 대신 성능 상에서 손해를 보는 방식인 것 입니다.\n어떤 것을 사용하는 것이 좋을까? 장단점도 알았으니 이제 어떤 것을 사용하는 것이 좀 더 좋을지만 결정하면 됩니다. 사실 둘 다 사용하라고 만들어 놓은 것이니 정답은 없어요. 그래도 저는 CheckedContinuation 을 사용을 권장합니다.\n그 이유는 CheckedContinuation 으로 발생하는 오버헤드가 사용자 입장에서 체감할 수 있을만큼 심각한 성능저하를 야기하지 않을 것이 확실하고, UnsafeContinuation 사용으로 발생할 수 있는 잠재적 메모리 릭의 위험성이나 크래시 상황에서 디버깅에 대한 비용이 훨씬 크다고 생각하기 때문이에요.\n하이브리드 옵션으로 개발 도중에는 CheckedContinuation 을 사용하고 충분한 테스트를 거쳐 안전하다고 판단되면, 출시 시점에 UnsafeContinuation 로 변경하는 것도 방법일 수 있습니다. 하지만 이 경우에도 업데이트를 위한 코드 수정을 거치다 보면, 다시 정확성 검사를 위해 CheckedContinuation 으로 변경해야 하는 수고로움과 시간적인 손해가 발생할 수 있다는 것을 알아두세요.\n다시 한번 결론을 내드리면 저는 거의 모든 케이스에 CheckedContinuation 사용을 권장합니다.\n사용 가능한 4가지 메서드 Continuation 의 종류 및 차이를 충분히 알아보았으니 기존 Callback 스타일 함수를 Async 하게 사용할 수 있게 도와주는 메서드에 어떤 종류가 있는지 살펴보겠습니다.\nCheckedContinuation, UnsafeContinuation 은 코드 문맥상 에러가 발생할 여지가 있는지에 따라 throwing 을 하는 함수와 그렇지 않은 함수로 2가지로 나뉘어, 총 4가지 종류를 사용할 수 있습니다.\nwithCheckedContinuation(function:_:) withCheckedThrowingContinuation(function:_:) withUnsafeContinuation(_:) withUnsafeThrowingContinuation(_:) 안전한 코드를 위해 CheckedContinuation 을 사용하려면 withCheckedContinuation 이나 withCheckedThrowingContinuation(function:_:) 중 상황에 적합한 것을 사용하면 됩니다. 기존 함수에 에러가 발생하는 상황이 있다면 Throwing 이 들어간 메서드를 사용하면 되겠죠?\nUsage Examples 중요한 내용이 많다보니 설명이 길어졌네요. 이제 드디어 예제 코드를 작성하며 실습을 해 볼 시간입니다! 이번 예제에서는 @escaping 을 사용하는 Callback 함수를 Continuation 을 활용해 async/await API 를 활용할 수 있는 함수로 변경해 보겠습니다.\n공통 부분 Concurrency - Async, Await, 그리고 Task 알아보기에서 사용한 코드와 동일합니다.\nlet url = URL(string: \"https://api.quotable.io/random\") enum NetworkError: Error { case badUrl case badResponse case communicationError case decodeFailed case noData } struct Quote: Decodable { let content: String } Callback 이 부분도 Concurrency - Async, Await, 그리고 Task 알아보기에서 사용한 코드를 그대로 가져왔습니다.\nfunc getQuote(from url: URL?, completion: @escaping (Result\u003cQuote, NetworkError\u003e) -\u003e Void) { guard let url = url else { completion(.failure(.badUrl)) return } URLSession.shared.dataTask(with: url, completionHandler: { data, response, error in if let error = error { completion(.failure(.communicationError)) print(error) return } if let response = response as? HTTPURLResponse, !(200..\u003c300).contains(response.statusCode) { completion(.failure(.badResponse)) return } guard let data = data else { completion(.failure(.noData)) return } do { let quote = try JSONDecoder().decode(Quote.self, from: data) completion(.success(quote)) } catch { completion(.failure(.decodeFailed)) } }).resume() } Continuation 이제 Continuation 을 사용헤 기존 콜백함수를 Wrapping 해보겠습니다. resume(returning:) 을 사용해 값을 전달하고 에러는 resume(throwing:) 으로 처리하겠습니다.\nfunc getQuote(from url: URL?) async throws -\u003e Quote { return try await withCheckedThrowingContinuation({ continuation in getQuote(from: url, completion: { result in switch result { case .success(let quote): continuation.resume(returning: quote) case .failure(let networkError): continuation.resume(throwing: networkError) } }) }) } 에러 발생에 대한 처리를 이후로 미루려면 resume(with:) 를 사용해 Result 타입을 그대로 전달할 수도 있습니다.\nfunc getQuoteResult(from url: URL?) async throws -\u003e Quote { return try await withCheckedThrowingContinuation({ continuation in getQuote(from: url, completion: { result in continuation.resume(with: result) }) }) } resume 을 호출하지 않은 경우 마지막으로 resume 규칙을 위배하는 케이스들에 대한 테스트를 해보겠습니다. 먼저 resume 을 한 번도 호출하지 않으면 어떻게 되는지 볼게요.\nfunc getQuote(from url: URL?) async throws -\u003e Quote { return try await withCheckedThrowingContinuation({ continuation in getQuote(from: url, completion: { result in }) }) } 위 코드를 실행해 보면 다음과 같은 경고 메세지가 출력됩니다.\nSWIFT TASK CONTINUATION MISUSE: getQuote(from:) leaked its continuation! Continuation 을 잘못 사용해서 메모리 릭이 발생했다고 하네요. 이것은 우리가 CheckedContinuation 을 사용했기 때문에 메세지가 출력되는 것이고 UnsafeContinuation 을 사용한 경우에는 다른 메세지 없이 조용히 메모리 릭이 발생하게 됩니다.\nresume 을 두번 이상 호출하는 경우 resume 을 호출하지 않는 경우에 메모리 릭이 발생하는 것은 확인했고, 그렇다면 두번 이상 호출하면 어떻게 될까요?\nfunc getQuote(from url: URL?) async throws -\u003e Quote { return try await withCheckedThrowingContinuation({ continuation in getQuote(from: url, completion: { result in continuation.resume(with: result) continuation.resume(with: result) }) }) } 앱에 크래시가 발생하며 다음과 같은 경고 메세지가 출력되었습니다.\nFatal error: SWIFT TASK CONTINUATION MISUSE: getQuote(from:) tried to resume its continuation more than once, returning ()! 이것 역시 CheckedContinuation 을 사용했기 때문에 출력되는 메세지 입니다. UnsafeContinuation 역시 앱 크래시가 발생하지만 이유를 명확하게 알려주지 않습니다.\n이렇게 Continuation 의 규칙 위배는 크리티컬한 상황을 초래하니 Continuation 을 사용할 때는 resume 사용의 2가지 규칙을 꼭 기억해주세요!\nWrap Up Continuation 으로 이제 기존 모든 CallBack 스타일 함수를 Async 하게 바꿀 수 있게 되었어요 ㅎㅎ 다만 아직도 async / await 에 관해 배울 내용들이 많이 남았습니다. 다음 포스트 async let 으로 또 찾아오겠습니다 :)\nReferences Wrapping existing asynchronous code in async/await in Swift\nThe difference between checked and unsafe continuations in Swift\n","wordCount":"1152","inLanguage":"en","datePublished":"2022-08-04T08:17:00+09:00","dateModified":"2022-08-04T08:17:00+09:00","author":{"@type":"Person","name":"Doyoung Song"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://kasroid.github.io/posts/ios/20220804-concurrency-continuation/"},"publisher":{"@type":"Organization","name":"SDY - Developer Kas","logo":{"@type":"ImageObject","url":"https://kasroid.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://kasroid.github.io accesskey=h title="SDY (Alt + H)">SDY</a><div class=logo-switches></div></div><ul id=menu><li><a href=https://kasroid.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://kasroid.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://kasroid.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://kasroid.github.io>Home</a>&nbsp;»&nbsp;<a href=https://kasroid.github.io/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://kasroid.github.io/posts/ios/>iOS</a></div><h1 class=post-title>Concurrency - Continuation 활용하기</h1><div class=post-meta><span title='2022-08-04 08:17:00 +0900 KST'>2022-08-04</span>&nbsp;·&nbsp;Doyoung Song</div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#intro>Intro</a></li><li><a href=#continuation-정의>Continuation 정의</a><ul><li><a href=#정확성-검사>정확성 검사</a></li><li><a href=#사용-가능한-4가지-메서드>사용 가능한 4가지 메서드</a></li></ul></li><li><a href=#usage-examples>Usage Examples</a><ul><li><a href=#공통-부분>공통 부분</a></li><li><a href=#callback>Callback</a></li><li><a href=#continuation>Continuation</a></li></ul></li><li><a href=#wrap-up>Wrap Up</a></li><li><a href=#references>References</a></li></ul></nav></div></details></div><div class=post-content><blockquote><p>이 포스트는 다음 버전을 기준으로 작성되었습니다.</p><ul><li>iOS 15.6</li><li>Swift 5.6.1</li><li>Xcode 13.4.1</li></ul></blockquote><h2 id=intro>Intro<a hidden class=anchor aria-hidden=true href=#intro>#</a></h2><p>오늘은 <strong>Continuation</strong> 이라는 것을 공부해 보겠습니다. 본격적으로 설명을 시작하기 전에 이것을 어디에 사용하는지를 알아야 공부에 대한 동기부여가 될테니, Continuation 이 언제 필요한지를 먼저 알아보도록 할게요.</p><p>우리는 <a href=https://kasroid.github.io/posts/ios/20220731-concurrency-async-await-task/>이전 포스트</a>에서 <strong>async/await</strong> 의 기본적인 사용법을 익혔습니다. 기존 <code>@escaping</code> 키워드를 사용해 콜백 스타일로 비동기 작업을 처리하는 함수를, 새로운 Async, Await API 를 적용시킨 함수로 리팩토링하여 훨씬 간결하고 가독성 좋은 비동기 함수를 만들 수 있었어요.</p><p>하지만 막상 새롭게 배운 내용들을 회사 프로젝트에 적용하려고 보니 다음과 같은 상황이 발생했다고 생각해보세요.</p><ul><li>기존 함수가 패키지 안에 감싸져 있어 우리가 임의로 수정할 수 없습니다.</li><li>레거시 코드가 너무 복잡하게 엉켜있어 수정 시 크리티컬한 사이드 이펙트가 발생할 수 있습니다.</li></ul><p>아쉽지만 회사에서 새로운 프로젝트를 시작할 때까지 <strong>async/await</strong> 사용을 포기해야 할까요?</p><p><del>아니요 포기는 배추를 셀 때나..</del> 바로 이러한 상황에서 사용할 수 있도록 위해 애플이 <strong>Continuation</strong> 을 준비해 두었습니다. 기존 콜백 스타일의 비동기 함수는 수정하지 않으면서, <strong>브릿지 역할</strong>을 하는 Continuation 함수를 만들어 Async, Await API 를 적용하는 것 입니다.</p><hr><h2 id=continuation-정의>Continuation 정의<a hidden class=anchor aria-hidden=true href=#continuation-정의>#</a></h2><p>Continuation 은 다음 두가지로 나뉘어 있습니다.</p><ul><li>CheckedContinuation</li><li>UnsafeContinuation</li></ul><p>그렇다면 둘 사이에 어떤 차이점이 있을까요? 여느 때처럼 공식 문서에서 한번 찾아보겠습니다.</p><p><img loading=lazy src=/ios/Continuation/Document-CheckedContinuation.png alt="Documentation CheckedContinuation"></p><p>CheckedContinuation 은 <strong>동기, 비동기 코드 간의 인터페이스 메커니즘</strong>이라고 합니다.</p><p>음&mldr; 메커니즘&mldr;?? 개념적인 설명이라 그런지 조금 모호한 듯한 느낌이 있네요. 위에서 얘기했던 대로 콜백함수를 Async 함수로 변환하는 브릿지 역할을 한다는 것을 이렇게 표현한 걸까요?</p><p>다음 것도 읽어보면 좀 더 이해가 잘 갈 수도 있으니 UnsafeContinuation 의 설명을 보겠습니다.</p><p><img loading=lazy src=/ios/Continuation/Document-UnsafeContinuation.png alt="Documentation UnsafeContinuation"></p><p>또커니즘&mldr; 그래도 CheckedContinuation 과 다른 점을 찾았습니다. 메커니즘이 정확히 무엇을 의미하건 간에 <strong>정확성 검사의 유무</strong>라는 차이가 있네요. 그렇다면 정확성 검사가 무엇인지를 알아야겠죠.</p><h3 id=정확성-검사>정확성 검사<a hidden class=anchor aria-hidden=true href=#정확성-검사>#</a></h3><p>Continuation 은 사용 시 개발자가 <strong>반드시 지켜야 하는 두가지 규칙</strong>이 있습니다.</p><ul><li>Continuation 클로저 안에서 반드시 <code>resume</code> 을 호출해야 합니다.</li><li>그리고 <code>resume</code> 은 단 한 번만 호출 되어야 합니다.</li></ul><p>우리가 작성한 코드가 <strong>이 두가지 규칙을 위배하는지에 대한 체크</strong>해 주는 것이 바로 정확성 검사입니다.</p><h4 id=정확성-검사-조건-위배-시-발생하는-현상>정확성 검사 조건 위배 시 발생하는 현상<a hidden class=anchor aria-hidden=true href=#정확성-검사-조건-위배-시-발생하는-현상>#</a></h4><p>조건을 위배한 코드를 작성하면 어떤 일이 일어날까요?</p><ul><li><code>resume</code> 이 단 한 번도 호출되지 않았다면 Continuation 이 실행되고 값이나 에러를 리턴하지 않게 됩니다. 즉 Continuation 이 무한 대기상태에 빠져 리소스 낭비가 발생하게 됩니다.</li><li>두번 이상 <code>resume</code> 을 호출하면 앱에 크래시가 발생합니다.</li></ul><p>사실 정확성 검사 기능을 제공하는 CheckedContinuation 을 사용한다고 스위프트 문법 검사를 하듯이 <code>resume</code> 규칙에 대한 위배를 미리 체크하고 막아주는 것은 아닙니다.</p><p>대신 앱이 실행되는 동안 규칙이 위배된 것을 발견하면 경고 메세지가 콘솔에 출력됩니다. 그 이유는 정확성 검사가 런타임에 이루어지기 때문이에요.</p><h4 id=checkedcontinuation-의-문제점>CheckedContinuation 의 문제점<a hidden class=anchor aria-hidden=true href=#checkedcontinuation-의-문제점>#</a></h4><p>지금까지 살펴보았듯 보다 안전한 코드를 작성하려면 CheckedContinuation 를 사용하면 됩니다. 그렇다면 안전하지 않은 옵션인 UnsafeContinuation 은 왜 만들어 놓았을까요?</p><p>그것은 바로 CheckedContinuation 의 정확성 검사가 런타임에 이루어지다보니 <strong>오버헤드가 발생</strong>한다는 단점이 있기 대문입니다. 안전한 대신 성능 상에서 손해를 보는 방식인 것 입니다.</p><h4 id=어떤-것을-사용하는-것이-좋을까>어떤 것을 사용하는 것이 좋을까?<a hidden class=anchor aria-hidden=true href=#어떤-것을-사용하는-것이-좋을까>#</a></h4><p>장단점도 알았으니 이제 어떤 것을 사용하는 것이 좀 더 좋을지만 결정하면 됩니다. 사실 둘 다 사용하라고 만들어 놓은 것이니 정답은 없어요. 그래도 저는 <strong>CheckedContinuation 을 사용을 권장</strong>합니다.</p><p>그 이유는 CheckedContinuation 으로 발생하는 오버헤드가 사용자 입장에서 체감할 수 있을만큼 심각한 성능저하를 야기하지 않을 것이 확실하고, UnsafeContinuation 사용으로 발생할 수 있는 잠재적 메모리 릭의 위험성이나 크래시 상황에서 디버깅에 대한 비용이 훨씬 크다고 생각하기 때문이에요.</p><p>하이브리드 옵션으로 개발 도중에는 CheckedContinuation 을 사용하고 충분한 테스트를 거쳐 안전하다고 판단되면, 출시 시점에 UnsafeContinuation 로 변경하는 것도 방법일 수 있습니다. 하지만 이 경우에도 업데이트를 위한 코드 수정을 거치다 보면, 다시 정확성 검사를 위해 CheckedContinuation 으로 변경해야 하는 수고로움과 시간적인 손해가 발생할 수 있다는 것을 알아두세요.</p><p>다시 한번 결론을 내드리면 저는 거의 모든 케이스에 CheckedContinuation 사용을 권장합니다.</p><h3 id=사용-가능한-4가지-메서드>사용 가능한 4가지 메서드<a hidden class=anchor aria-hidden=true href=#사용-가능한-4가지-메서드>#</a></h3><p>Continuation 의 종류 및 차이를 충분히 알아보았으니 기존 Callback 스타일 함수를 Async 하게 사용할 수 있게 도와주는 메서드에 어떤 종류가 있는지 살펴보겠습니다.</p><p>CheckedContinuation, UnsafeContinuation 은 코드 문맥상 에러가 발생할 여지가 있는지에 따라 <code>throwing</code> 을 하는 함수와 그렇지 않은 함수로 2가지로 나뉘어, <strong>총 4가지 종류</strong>를 사용할 수 있습니다.</p><ul><li>withCheckedContinuation(function:_:)</li><li>withCheckedThrowingContinuation(function:_:)</li><li>withUnsafeContinuation(_:)</li><li>withUnsafeThrowingContinuation(_:)</li></ul><p>안전한 코드를 위해 CheckedContinuation 을 사용하려면 <code>withCheckedContinuation</code> 이나 <code>withCheckedThrowingContinuation(function:_:)</code> 중 상황에 적합한 것을 사용하면 됩니다. 기존 함수에 에러가 발생하는 상황이 있다면 Throwing 이 들어간 메서드를 사용하면 되겠죠?</p><hr><h2 id=usage-examples>Usage Examples<a hidden class=anchor aria-hidden=true href=#usage-examples>#</a></h2><p>중요한 내용이 많다보니 설명이 길어졌네요. 이제 드디어 예제 코드를 작성하며 실습을 해 볼 시간입니다! 이번 예제에서는 <code>@escaping</code> 을 사용하는 Callback 함수를 Continuation 을 활용해 async/await API 를 활용할 수 있는 함수로 변경해 보겠습니다.</p><h3 id=공통-부분>공통 부분<a hidden class=anchor aria-hidden=true href=#공통-부분>#</a></h3><p><a href=https://kasroid.github.io/posts/ios/20220731-concurrency-async-await-task/>Concurrency - Async, Await, 그리고 Task 알아보기</a>에서 사용한 코드와 동일합니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>let</span> <span class=nv>url</span> <span class=p>=</span> <span class=n>URL</span><span class=p>(</span><span class=n>string</span><span class=p>:</span> <span class=s>&#34;https://api.quotable.io/random&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>enum</span> <span class=nc>NetworkError</span><span class=p>:</span> <span class=n>Error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>badUrl</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>badResponse</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>communicationError</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>decodeFailed</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=n>noData</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>struct</span> <span class=nc>Quote</span><span class=p>:</span> <span class=n>Decodable</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nv>content</span><span class=p>:</span> <span class=nb>String</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=callback>Callback<a hidden class=anchor aria-hidden=true href=#callback>#</a></h3><p>이 부분도 <a href=https://kasroid.github.io/posts/ios/20220731-concurrency-async-await-task/>Concurrency - Async, Await, 그리고 Task 알아보기</a>에서 사용한 코드를 그대로 가져왔습니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>func</span> <span class=nf>getQuote</span><span class=p>(</span><span class=n>from</span> <span class=n>url</span><span class=p>:</span> <span class=n>URL</span><span class=p>?,</span> <span class=n>completion</span><span class=p>:</span> <span class=p>@</span><span class=n>escaping</span> <span class=p>(</span><span class=n>Result</span><span class=p>&lt;</span><span class=n>Quote</span><span class=p>,</span> <span class=n>NetworkError</span><span class=p>&gt;)</span> <span class=p>-&gt;</span> <span class=nb>Void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>guard</span> <span class=kd>let</span> <span class=nv>url</span> <span class=p>=</span> <span class=n>url</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>completion</span><span class=p>(.</span><span class=n>failure</span><span class=p>(.</span><span class=n>badUrl</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>URLSession</span><span class=p>.</span><span class=n>shared</span><span class=p>.</span><span class=n>dataTask</span><span class=p>(</span><span class=n>with</span><span class=p>:</span> <span class=n>url</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                               <span class=n>completionHandler</span><span class=p>:</span> <span class=p>{</span> <span class=n>data</span><span class=p>,</span> <span class=n>response</span><span class=p>,</span> <span class=n>error</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=kd>let</span> <span class=nv>error</span> <span class=p>=</span> <span class=n>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>completion</span><span class=p>(.</span><span class=n>failure</span><span class=p>(.</span><span class=n>communicationError</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=bp>print</span><span class=p>(</span><span class=n>error</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=kd>let</span> <span class=nv>response</span> <span class=p>=</span> <span class=n>response</span> <span class=k>as</span><span class=p>?</span> <span class=n>HTTPURLResponse</span><span class=p>,</span>
</span></span><span class=line><span class=cl>           <span class=o>!</span><span class=p>(</span><span class=mf>200.</span><span class=p>.&lt;</span><span class=mi>300</span><span class=p>).</span><span class=bp>contains</span><span class=p>(</span><span class=n>response</span><span class=p>.</span><span class=n>statusCode</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>completion</span><span class=p>(.</span><span class=n>failure</span><span class=p>(.</span><span class=n>badResponse</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>guard</span> <span class=kd>let</span> <span class=nv>data</span> <span class=p>=</span> <span class=n>data</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>completion</span><span class=p>(.</span><span class=n>failure</span><span class=p>(.</span><span class=n>noData</span><span class=p>))</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>do</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kd>let</span> <span class=nv>quote</span> <span class=p>=</span> <span class=k>try</span> <span class=n>JSONDecoder</span><span class=p>().</span><span class=n>decode</span><span class=p>(</span><span class=n>Quote</span><span class=p>.</span><span class=kc>self</span><span class=p>,</span> <span class=n>from</span><span class=p>:</span> <span class=n>data</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>completion</span><span class=p>(.</span><span class=n>success</span><span class=p>(</span><span class=n>quote</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span> <span class=k>catch</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>completion</span><span class=p>(.</span><span class=n>failure</span><span class=p>(.</span><span class=n>decodeFailed</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}).</span><span class=n>resume</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=continuation>Continuation<a hidden class=anchor aria-hidden=true href=#continuation>#</a></h3><p>이제 Continuation 을 사용헤 기존 콜백함수를 Wrapping 해보겠습니다. <code>resume(returning:)</code> 을 사용해 값을 전달하고 에러는 <code>resume(throwing:)</code> 으로 처리하겠습니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>func</span> <span class=nf>getQuote</span><span class=p>(</span><span class=n>from</span> <span class=n>url</span><span class=p>:</span> <span class=n>URL</span><span class=p>?)</span> <span class=n>async</span> <span class=kr>throws</span> <span class=p>-&gt;</span> <span class=n>Quote</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>try</span> <span class=n>await</span> <span class=n>withCheckedThrowingContinuation</span><span class=p>({</span> <span class=n>continuation</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>        <span class=n>getQuote</span><span class=p>(</span><span class=n>from</span><span class=p>:</span> <span class=n>url</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                 <span class=n>completion</span><span class=p>:</span> <span class=p>{</span> <span class=n>result</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>            <span class=k>switch</span> <span class=n>result</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>case</span> <span class=p>.</span><span class=n>success</span><span class=p>(</span><span class=kd>let</span> <span class=nv>quote</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=n>continuation</span><span class=p>.</span><span class=n>resume</span><span class=p>(</span><span class=n>returning</span><span class=p>:</span> <span class=n>quote</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>case</span> <span class=p>.</span><span class=n>failure</span><span class=p>(</span><span class=kd>let</span> <span class=nv>networkError</span><span class=p>):</span>
</span></span><span class=line><span class=cl>                <span class=n>continuation</span><span class=p>.</span><span class=n>resume</span><span class=p>(</span><span class=n>throwing</span><span class=p>:</span> <span class=n>networkError</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>에러 발생에 대한 처리를 이후로 미루려면 <code>resume(with:)</code> 를 사용해 Result 타입을 그대로 전달할 수도 있습니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>func</span> <span class=nf>getQuoteResult</span><span class=p>(</span><span class=n>from</span> <span class=n>url</span><span class=p>:</span> <span class=n>URL</span><span class=p>?)</span> <span class=n>async</span> <span class=kr>throws</span> <span class=p>-&gt;</span> <span class=n>Quote</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>try</span> <span class=n>await</span> <span class=n>withCheckedThrowingContinuation</span><span class=p>({</span> <span class=n>continuation</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>        <span class=n>getQuote</span><span class=p>(</span><span class=n>from</span><span class=p>:</span> <span class=n>url</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                 <span class=n>completion</span><span class=p>:</span> <span class=p>{</span> <span class=n>result</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>            <span class=n>continuation</span><span class=p>.</span><span class=n>resume</span><span class=p>(</span><span class=n>with</span><span class=p>:</span> <span class=n>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=resume-을-호출하지-않은-경우>resume 을 호출하지 않은 경우<a hidden class=anchor aria-hidden=true href=#resume-을-호출하지-않은-경우>#</a></h4><p>마지막으로 <code>resume</code> 규칙을 위배하는 케이스들에 대한 테스트를 해보겠습니다. 먼저 <code>resume</code> 을 <strong>한 번도 호출하지 않으면</strong> 어떻게 되는지 볼게요.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>func</span> <span class=nf>getQuote</span><span class=p>(</span><span class=n>from</span> <span class=n>url</span><span class=p>:</span> <span class=n>URL</span><span class=p>?)</span> <span class=n>async</span> <span class=kr>throws</span> <span class=p>-&gt;</span> <span class=n>Quote</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>try</span> <span class=n>await</span> <span class=n>withCheckedThrowingContinuation</span><span class=p>({</span> <span class=n>continuation</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>        <span class=n>getQuote</span><span class=p>(</span><span class=n>from</span><span class=p>:</span> <span class=n>url</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                 <span class=n>completion</span><span class=p>:</span> <span class=p>{</span> <span class=n>result</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>        <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>위 코드를 실행해 보면 다음과 같은 경고 메세지가 출력됩니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>SWIFT TASK CONTINUATION MISUSE: getQuote(from:) leaked its continuation!
</span></span></code></pre></div><p>Continuation 을 잘못 사용해서 메모리 릭이 발생했다고 하네요. 이것은 우리가 CheckedContinuation 을 사용했기 때문에 메세지가 출력되는 것이고 UnsafeContinuation 을 사용한 경우에는 다른 메세지 없이 조용히 메모리 릭이 발생하게 됩니다.</p><h4 id=resume-을-두번-이상-호출하는-경우>resume 을 두번 이상 호출하는 경우<a hidden class=anchor aria-hidden=true href=#resume-을-두번-이상-호출하는-경우>#</a></h4><p><code>resume</code> 을 호출하지 않는 경우에 메모리 릭이 발생하는 것은 확인했고, 그렇다면 <strong>두번 이상 호출</strong>하면 어떻게 될까요?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>func</span> <span class=nf>getQuote</span><span class=p>(</span><span class=n>from</span> <span class=n>url</span><span class=p>:</span> <span class=n>URL</span><span class=p>?)</span> <span class=n>async</span> <span class=kr>throws</span> <span class=p>-&gt;</span> <span class=n>Quote</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>try</span> <span class=n>await</span> <span class=n>withCheckedThrowingContinuation</span><span class=p>({</span> <span class=n>continuation</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>        <span class=n>getQuote</span><span class=p>(</span><span class=n>from</span><span class=p>:</span> <span class=n>url</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                 <span class=n>completion</span><span class=p>:</span> <span class=p>{</span> <span class=n>result</span> <span class=k>in</span>
</span></span><span class=line><span class=cl>            <span class=n>continuation</span><span class=p>.</span><span class=n>resume</span><span class=p>(</span><span class=n>with</span><span class=p>:</span> <span class=n>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=n>continuation</span><span class=p>.</span><span class=n>resume</span><span class=p>(</span><span class=n>with</span><span class=p>:</span> <span class=n>result</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>})</span>
</span></span><span class=line><span class=cl>    <span class=p>})</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>앱에 크래시가 발생하며 다음과 같은 경고 메세지가 출력되었습니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>Fatal error: SWIFT TASK CONTINUATION MISUSE: getQuote(from:) tried to resume its continuation more than once, returning ()!
</span></span></code></pre></div><p>이것 역시 CheckedContinuation 을 사용했기 때문에 출력되는 메세지 입니다. UnsafeContinuation 역시 앱 크래시가 발생하지만 이유를 명확하게 알려주지 않습니다.</p><p>이렇게 Continuation 의 규칙 위배는 크리티컬한 상황을 초래하니 Continuation 을 사용할 때는 <code>resume</code> 사용의 <strong>2가지 규칙</strong>을 꼭 기억해주세요!</p><hr><h2 id=wrap-up>Wrap Up<a hidden class=anchor aria-hidden=true href=#wrap-up>#</a></h2><p>Continuation 으로 이제 기존 모든 CallBack 스타일 함수를 Async 하게 바꿀 수 있게 되었어요 ㅎㅎ 다만 아직도 async / await 에 관해 배울 내용들이 많이 남았습니다. 다음 포스트 async let 으로 또 찾아오겠습니다 :)</p><hr><h2 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h2><p><a href=https://www.donnywals.com/wrapping-existing-asynchronous-code-in-async-await-in-swift/>Wrapping existing asynchronous code in async/await in Swift</a><br><a href=https://www.donnywals.com/the-difference-between-checked-and-unsafe-continuation-in-swift/>The difference between checked and unsafe continuations in Swift</a></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://kasroid.github.io/tags/concurrency/>Concurrency</a></li><li><a href=https://kasroid.github.io/tags/async/await/>Async/Await</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://kasroid.github.io>SDY - Developer Kas</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>